<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rabbit R1 Web App - Cool Edition</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Press+Start+2P&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/css-spinner/1.1.1/css-spinner.min.css">

    <style>
        /* --- Global Variables --- */
        :root {
            --rabbit-orange: #ff7e00;
            --rabbit-orange-dark: #e67200;
            --off-white: #f9f9f9; /* Slightly brighter */
            --light-gray: #e8e8e8;
            --medium-gray: #cccccc;
            --dark-gray: #333333;
            --device-gray: #d8d8d8; /* Slightly lighter device body */
            --error-red: #e74c3c; /* Brighter red */
            --success-green: #2ecc71; /* Brighter green */
            --glass-bg: rgba(50, 50, 50, 0.45); /* Darker glass for better contrast on video */
            --glass-border: rgba(255, 255, 255, 0.3);
            --glass-blur: 12px; /* More blur */
            --transition-speed: 0.4s; /* Consistent transition speed */
            --transition-timing: cubic-bezier(0.25, 0.8, 0.25, 1); /* Smoother ease-out */
        }

        /* --- Base Styles --- */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%); /* Subtle gradient background */
            color: var(--dark-gray);
            display: flex; justify-content: center; align-items: center;
            min-height: 100vh; padding: 20px;
            -webkit-tap-highlight-color: transparent;
            overflow: hidden; /* Prevent body scroll */
        }

        /* --- Device Container --- */
        .device-container {
            width: 100%;
            max-width: 370px; /* Slightly wider */
            margin: 0 auto;
            perspective: 1000px; /* For 3D effects if needed */
        }
        .rabbit-device {
            background-color: var(--device-gray);
            border-radius: 30px; /* More rounded */
            padding: 18px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.15), 0 5px 15px rgba(0, 0, 0, 0.1); /* Deeper shadow */
            display: flex; flex-direction: column; align-items: center; gap: 18px;
            border: 1px solid rgba(255, 255, 255, 0.5); /* Subtle inner border */
        }

        /* --- Main Display --- */
        .main-display {
            background-color: var(--off-white);
            border-radius: 20px; /* More rounded inner display */
            width: 100%;
            aspect-ratio: 1 / 1;
            overflow: hidden;
            position: relative;
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        /* --- Screens (General) --- */
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center;
            padding: 25px; /* Default padding */
            opacity: 0; visibility: hidden;
            transition: opacity var(--transition-speed) var(--transition-timing),
                        transform var(--transition-speed) var(--transition-timing),
                        visibility var(--transition-speed) var(--transition-timing);
            transform: translateY(30px) scale(0.98); /* Start slightly scaled down and below */
            overflow-y: auto; /* Enable scrolling within screen */
            background-color: var(--off-white);
            scrollbar-width: thin; /* Firefox */
            scrollbar-color: var(--medium-gray) var(--light-gray); /* Firefox */
        }
        /* Scrollbar styling for Webkit browsers */
        .screen::-webkit-scrollbar { width: 6px; }
        .screen::-webkit-scrollbar-track { background: var(--light-gray); border-radius: 3px; }
        .screen::-webkit-scrollbar-thumb { background-color: var(--medium-gray); border-radius: 3px; }

        .active-screen {
            opacity: 1; visibility: visible;
            transform: translateY(0) scale(1); /* Animate to final position */
        }
        /* Specific transition for listening screen (fade only) */
        .listening-screen { transform: none; transition: opacity 0.2s ease; }
        .listening-screen.active-screen { transform: none; }

        /* --- Common Screen Title --- */
        .screen h2 {
            font-size: 22px; font-weight: 600; margin-bottom: 20px;
            text-align: center; width: 100%; color: var(--dark-gray);
            flex-shrink: 0;
            animation: fadeInDown 0.5s var(--transition-timing) backwards;
            animation-delay: 0.1s; /* Slight delay for title */
        }

        /* --- Back Button (Common) --- */
        .back-button {
            padding: 10px 20px; /* Larger padding */
            background: linear-gradient(145deg, var(--medium-gray), var(--light-gray)); /* Subtle gradient */
            border: none; border-radius: 8px; /* More rounded */
            color: var(--dark-gray); cursor: pointer;
            transition: all 0.2s ease; /* Smooth transition for hover/active */
            font-size: 14px; display: inline-flex;
            align-items: center; gap: 8px;
            z-index: 10; /* Ensure above most content */
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            font-weight: 500;
        }
        .back-button:hover {
            background: linear-gradient(145deg, var(--light-gray), var(--medium-gray));
            box-shadow: 0 4px 8px rgba(0,0,0,0.08);
            transform: translateY(-1px);
        }
        .back-button:active {
            transform: translateY(0px);
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }
        /* Default positioning for back button (absolute for specific screens) */
        .response-screen .back-button, .error-screen .back-button, .notes-screen .back-button,
        .gallery-screen .back-button {
             position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
             animation: fadeInUp 0.5s var(--transition-timing) backwards;
             animation-delay: 0.3s; /* Delay for back button */
        }
         /* Standard margin for others */
        .calendar-screen .back-button, .alarms-screen .back-button, .timer-screen .back-button,
        .music-screen .back-button {
            margin-top: auto; /* Push to bottom */
            margin-bottom: 5px; /* Small space from bottom */
            animation: fadeInUp 0.5s var(--transition-timing) backwards;
            animation-delay: 0.3s;
        }
        /* Specific back button position for camera screens (absolute) */
        .vision-screen .back-button, .look-at-this-screen .back-button {
             position: absolute; bottom: 20px; left: 50%;
             transform: translateX(-50%);
             animation: fadeInUp 0.5s var(--transition-timing) backwards;
             animation-delay: 0.6s; /* Delay more */
             /* Style adjustment for better visibility on video */
             background: var(--glass-bg);
             color: var(--off-white);
             border: 1px solid var(--glass-border);
             backdrop-filter: blur(5px);
             -webkit-backdrop-filter: blur(5px);
        }
         .vision-screen .back-button:hover, .look-at-this-screen .back-button:hover {
             background: rgba(80, 80, 80, 0.6);
             box-shadow: 0 4px 8px rgba(0,0,0,0.15);
             transform: translateX(-50%) translateY(-1px); /* Adjust transform */
         }
         .vision-screen .back-button:active, .look-at-this-screen .back-button:active {
             transform: translateX(-50%) translateY(0px); /* Adjust transform */
             box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);
         }


        /* --- Specific Screen Styles --- */

        /* Home Screen */
        .home-screen { justify-content: center; text-align: center; }
        .greeting { font-size: 28px; font-weight: 700; margin-bottom: 10px; animation: fadeInScale 0.6s var(--transition-timing) backwards; animation-delay: 0.1s; }
        .instruction { font-size: 17px; color: #555; margin-bottom: 20px; animation: fadeInScale 0.6s var(--transition-timing) backwards; animation-delay: 0.2s; }
        .permission-status { font-size: 13px; color: #666; margin-top: 15px; min-height: 1.2em; font-weight: 500; animation: fadeInScale 0.6s var(--transition-timing) backwards; animation-delay: 0.3s; }
        .permission-status.error { color: var(--error-red); font-weight: 600; }

        /* Listening Screen */
        .listening-screen { justify-content: center; background-color: rgba(0,0,0,0.05); /* Slight overlay */ }
        .listening-indicator { text-align: center; }
        .listening-text { font-size: 20px; margin-bottom: 25px; animation: pulse 1.5s infinite alternate ease-in-out; }
        .waveform { display: flex; justify-content: center; align-items: flex-end; gap: 6px; height: 50px; }
        .waveform span {
            display: inline-block; width: 6px;
            background-color: var(--rabbit-orange);
            border-radius: 3px;
            animation: wave 1s infinite ease-in-out alternate;
        }
        /* Staggered animation delays for waveform */
        .waveform span:nth-child(1) { height: 10px; animation-delay: 0s; }
        .waveform span:nth-child(2) { height: 20px; animation-delay: 0.1s; }
        .waveform span:nth-child(3) { height: 30px; animation-delay: 0.2s; }
        .waveform span:nth-child(4) { height: 25px; animation-delay: 0.3s; }
        .waveform span:nth-child(5) { height: 15px; animation-delay: 0.4s; } /* Added a 5th bar */

        @keyframes wave {
            0% { height: 5px; opacity: 0.5; transform: scaleY(0.5); }
            100% { height: 45px; opacity: 1; transform: scaleY(1); }
        }
        @keyframes pulse {
            0% { opacity: 0.7; transform: scale(1); }
            100% { opacity: 1; transform: scale(1.03); }
        }

        /* Response Screen */
        .response-screen { justify-content: flex-start; align-items: flex-start; padding-bottom: 75px; /* More space for back button */ }
        .query-text { font-weight: 600; margin-bottom: 16px; align-self: flex-start; width: 100%; color: #555; border-bottom: 1px solid var(--light-gray); padding-bottom: 10px; word-wrap: break-word; animation: fadeInDown 0.4s var(--transition-timing) backwards; animation-delay: 0.1s; }
        .response-text { width: 100%; font-size: 15px; line-height: 1.7; /* Increased line height */ word-wrap: break-word; padding-bottom: 30px; animation: fadeInUp 0.5s var(--transition-timing) backwards; animation-delay: 0.2s; }
        .response-text p i { color: #777; } /* Slightly darker italic */
        .response-text p.error-message { color: var(--error-red); font-weight: 600; background-color: rgba(231, 76, 60, 0.1); padding: 8px; border-radius: 4px; }
        .response-text .loading-indicator { display: flex; justify-content: center; align-items: center; min-height: 50px; color: #888; font-style: italic; }

        /* Markdown Styles (Refined) */
        .response-text p { margin-bottom: 1.2em; }
        .response-text h1, .response-text h2, .response-text h3 { margin-top: 1.8em; margin-bottom: 1em; line-height: 1.4; color: var(--dark-gray); }
        .response-text h1 { font-size: 1.7em; border-bottom: 2px solid var(--rabbit-orange); padding-bottom: 0.4em; }
        .response-text h2 { font-size: 1.5em; }
        .response-text h3 { font-size: 1.3em; }
        .response-text ul, .response-text ol { margin-left: 30px; margin-bottom: 1.2em; }
        .response-text li { margin-bottom: 0.6em; }
        .response-text code { background-color: #eee; padding: 0.3em 0.5em; border-radius: 4px; font-family: 'Courier New', Courier, monospace; font-size: 0.95em; word-wrap: break-word; border: 1px solid #ddd; }
        .response-text pre { background-color: #f0f0f0; padding: 18px; border-radius: 8px; overflow-x: auto; margin-bottom: 1.2em; border: 1px solid #ddd; box-shadow: inset 0 1px 3px rgba(0,0,0,0.05); }
        .response-text pre code { background-color: transparent; padding: 0; font-size: 0.95em; word-wrap: normal; border: none; }
        .response-text blockquote { border-left: 5px solid var(--rabbit-orange); padding-left: 18px; margin: 1.5em 0; color: #555; font-style: italic; background-color: #fdf8f2; }
        .response-text table { border-collapse: collapse; width: 100%; margin: 1.8em 0; border: 1px solid var(--medium-gray); box-shadow: 0 1px 3px rgba(0,0,0,0.05); border-radius: 4px; overflow: hidden; }
        .response-text th, .response-text td { border: 1px solid var(--medium-gray); padding: 12px; text-align: left; }
        .response-text th { background-color: var(--light-gray); font-weight: 600; }
        .response-text tr:nth-child(even) { background-color: #f8f8f8; }
        .response-text hr { border: none; border-top: 2px dashed var(--light-gray); margin: 2.5em 0; }
        .response-text a { color: var(--rabbit-orange); text-decoration: none; font-weight: 500; transition: color 0.2s; }
        .response-text a:hover { color: var(--rabbit-orange-dark); text-decoration: underline; }
        .response-text img { max-width: 100%; height: auto; border-radius: 8px; margin: 1em 0; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }

        /* Alarms Screen */
        .alarms-screen { justify-content: flex-start; }
        .alarms-list { list-style: none; width: 100%; padding: 0; animation: fadeInUpList 0.6s var(--transition-timing) backwards; animation-delay: 0.1s; }
        .alarms-list li {
            padding: 15px; border-bottom: 1px solid var(--light-gray);
            transition: background-color 0.2s;
            border-radius: 4px; margin-bottom: 5px;
        }
        .alarms-list li:hover { background-color: rgba(0,0,0,0.03); }

        /* Timer Screen */
        .timer-screen { justify-content: center; /* Center content vertically */ }
        .timer-display { font-family: 'Press Start 2P', cursive; font-size: 36px; margin: 25px 0; color: var(--dark-gray); animation: pulse 1.5s infinite alternate ease-in-out; animation-play-state: paused; }
        .timer-display.running { animation-play-state: running; }
        .timer-controls { display: flex; gap: 15px; margin-bottom: 25px; animation: fadeInUp 0.5s var(--transition-timing) backwards; animation-delay: 0.2s; }
        .timer-btn { padding: 10px 20px; background: linear-gradient(145deg, var(--medium-gray), var(--light-gray)); border: none; border-radius: 8px; color: var(--dark-gray); cursor: pointer; transition: all 0.2s ease; font-weight: 500; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .timer-btn:hover { background: linear-gradient(145deg, var(--light-gray), var(--medium-gray)); box-shadow: 0 4px 8px rgba(0,0,0,0.08); transform: translateY(-1px); }
        .timer-btn:active { transform: translateY(0px); box-shadow: inset 0 1px 3px rgba(0,0,0,0.1); }

        /* Music Screen */
        .music-screen { justify-content: center; /* Center content */ }
        .album-art { width: 140px; height: 140px; background-color: var(--medium-gray); border-radius: 12px; margin-bottom: 20px; display: flex; justify-content: center; align-items: center; font-size: 50px; color: #fff; background-image: linear-gradient(45deg, #a0a0a0, #c0c0c0); box-shadow: 0 5px 15px rgba(0,0,0,0.1); animation: fadeInScale 0.6s var(--transition-timing) backwards; animation-delay: 0.1s; }
        .album-art::before { content: '\f001'; font-family: 'Font Awesome 6 Free'; font-weight: 900; }
        .track-info { text-align: center; margin-bottom: 20px; animation: fadeInUp 0.5s var(--transition-timing) backwards; animation-delay: 0.2s; }
        .track-title { font-weight: 600; font-size: 18px; margin-bottom: 5px; }
        .artist-name { font-size: 15px; color: #666; }
        .music-controls { display: flex; gap: 20px; margin-bottom: 25px; animation: fadeInUp 0.5s var(--transition-timing) backwards; animation-delay: 0.3s; }
        .music-btn { width: 45px; height: 45px; border-radius: 50%; background: linear-gradient(145deg, var(--medium-gray), var(--light-gray)); border: none; display: flex; justify-content: center; align-items: center; cursor: pointer; transition: all 0.2s ease; font-size: 18px; color: var(--dark-gray); box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .music-btn:hover { background: linear-gradient(145deg, var(--light-gray), var(--medium-gray)); box-shadow: 0 4px 8px rgba(0,0,0,0.08); transform: scale(1.05); }
        .music-btn:active { transform: scale(0.98); box-shadow: inset 0 1px 3px rgba(0,0,0,0.1); }
        #play-pause .fa-play, #play-pause .fa-pause { transition: transform 0.2s ease; }
        #play-pause.playing .fa-play { transform: scale(0); }
        #play-pause.playing .fa-pause { transform: scale(1); }
        #play-pause:not(.playing) .fa-play { transform: scale(1); }
        #play-pause:not(.playing) .fa-pause { transform: scale(0); }


        /* --- Camera Screens Styling --- */
        .vision-screen, .look-at-this-screen {
            justify-content: flex-start; /* Align items to top */
            padding: 0; /* Remove padding to allow full screen */
            /* Keep overflow auto for potential content later, though camera fills it */
            overflow: hidden; /* Hide scrollbars for full screen camera */
        }
        /* Style title specifically for camera screens */
        .vision-screen h2, .look-at-this-screen h2 {
            position: absolute; /* Position over the camera view */
            top: 15px; left: 50%; transform: translateX(-50%);
            z-index: 5; /* Ensure title is above video but below PTT */
            background: rgba(0, 0, 0, 0.4); /* Semi-transparent background */
            color: white;
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 16px; /* Smaller title */
            margin-bottom: 0; /* Remove default margin */
            animation: fadeInDown 0.5s var(--transition-timing) backwards;
            animation-delay: 0.2s;
            pointer-events: none; /* Allow clicks through title */
        }

        /* Camera Container (Make it fill the screen) */
        .camera-container {
            width: 100%; height: 100%; /* Fill the parent screen */
            flex-grow: 1; /* Ensure it takes space if screen is flex */
            background-color: #000; /* Black background */
            border-radius: 0; /* Remove border-radius, inherits from main-display */
            overflow: hidden;
            position: relative; /* Keep for absolute positioning inside */
            display: flex; justify-content: center; align-items: center;
            margin-bottom: 0; /* Remove margin */
            box-shadow: none; /* Remove shadow */
            animation: none; /* Remove entrance animation */
        }
        .camera-container i.placeholder-icon {
            font-size: 60px; color: #444; z-index: 0;
            transition: opacity 0.3s ease;
        }
        .camera-container.video-active i.placeholder-icon {
            opacity: 0;
        }

        /* Live Video Element (Make it fill the container) */
        .live-video {
            display: block;
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            object-fit: cover; /* Cover the container */
            z-index: 1; /* Below overlays */
            border-radius: 0; /* Match container */
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        .live-video.active {
            opacity: 1;
        }

        /* Captured Image Preview (Make it fill the container) */
        .captured-image-preview {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            object-fit: cover; z-index: 2; /* Above video */
            border-radius: 0; /* Match container */
            animation: fadeIn 0.3s ease;
        }

        /* Glassmorphism Overlay Style (Adjusted) */
        .glass-overlay {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            background: var(--glass-bg);
            backdrop-filter: blur(var(--glass-blur));
            -webkit-backdrop-filter: blur(var(--glass-blur));
            border: 1px solid var(--glass-border);
            border-radius: 16px; /* More rounded */
            padding: 10px 18px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
            z-index: 3; /* Above video/preview, below back button potentially */
            color: var(--off-white); /* White text on darker glass */
            text-align: center;
            transition: transform 0.3s var(--transition-timing), opacity 0.3s ease;
        }
        .glass-overlay:hover {
             transform: translateX(-50%) scale(1.03);
        }

        /* Specific Overlays (Adjusted Positions) */
        .vision-capture-overlay { bottom: 75px; animation: fadeInUp 0.5s var(--transition-timing) backwards; animation-delay: 0.4s; }
        .look-capture-overlay { bottom: 75px; animation: fadeInUp 0.5s var(--transition-timing) backwards; animation-delay: 0.4s; }
        .look-status-overlay { bottom: 130px; /* Position above capture button */ font-size: 14px; min-width: 220px; animation: fadeInUp 0.5s var(--transition-timing) backwards; animation-delay: 0.5s; padding: 8px 15px;}

        .capture-btn, .look-capture-btn {
            padding: 10px 20px; background: var(--rabbit-orange); border: none;
            border-radius: 10px; color: white; cursor: pointer;
            transition: all 0.2s ease; font-size: 16px; font-weight: 600; /* Bolder */
            display: inline-flex; align-items: center; gap: 8px;
            box-shadow: 0 3px 6px rgba(255, 126, 0, 0.2);
        }
        .capture-btn:hover, .look-capture-btn:hover { background-color: var(--rabbit-orange-dark); box-shadow: 0 5px 10px rgba(255, 126, 0, 0.3); transform: translateY(-1px); }
        .capture-btn:active, .look-capture-btn:active { transform: translateY(0px) scale(0.98); box-shadow: inset 0 1px 3px rgba(0,0,0,0.1); }
        .look-capture-btn:disabled { background-color: var(--medium-gray); cursor: not-allowed; box-shadow: none; transform: none; opacity: 0.7; }
        .look-capture-btn:disabled:hover { background-color: var(--medium-gray); transform: none; }


        /* Error Screen */
        .error-screen { justify-content: center; text-align: center; padding-bottom: 75px; }
        .error-screen h2 { color: var(--error-red); animation: shake 0.5s ease; }
        #error-message { margin-bottom: 25px; color: var(--error-red); font-weight: 500; font-size: 16px; background-color: rgba(231, 76, 60, 0.1); padding: 15px; border-radius: 8px; animation: fadeInUp 0.4s var(--transition-timing) backwards; animation-delay: 0.1s; }

        /* Calendar Screen */
        .calendar-screen { justify-content: center; }
        .calendar-placeholder { width: 100%; max-width: 300px; height: 220px; background-color: #eee; border: 1px solid var(--light-gray); display: flex; flex-direction: column; justify-content: center; align-items: center; font-style: italic; color: #999; border-radius: 12px; box-shadow: 0 2px 5px rgba(0,0,0,0.05); animation: fadeInScale 0.6s var(--transition-timing) backwards; animation-delay: 0.1s; }
        .calendar-placeholder::before { content: '\f073'; font-family: 'Font Awesome 6 Free'; font-weight: 900; font-size: 40px; margin-bottom: 10px; color: var(--medium-gray); }

        /* Notes Screen */
        .notes-screen { justify-content: flex-start; padding-bottom: 95px; /* Extra space for save button + feedback + back */ }
        .notes-textarea { width: 100%; flex-grow: 1; margin-bottom: 15px; padding: 15px; border: 1px solid var(--light-gray); border-radius: 8px; font-family: inherit; font-size: 15px; resize: vertical; box-shadow: inset 0 1px 3px rgba(0,0,0,0.05); transition: border-color 0.2s, box-shadow 0.2s; animation: fadeInUp 0.5s var(--transition-timing) backwards; animation-delay: 0.1s; }
        .notes-textarea:focus { border-color: var(--rabbit-orange); box-shadow: 0 0 0 3px rgba(255, 126, 0, 0.2), inset 0 1px 3px rgba(0,0,0,0.05); outline: none; }
        .save-note-btn { padding: 10px 20px; background-color: var(--success-green); color: white; border: none; border-radius: 8px; cursor: pointer; transition: all 0.2s; margin-bottom: 10px; /* Space before feedback */ font-weight: 600; display: inline-flex; align-items: center; gap: 8px; box-shadow: 0 3px 6px rgba(46, 204, 113, 0.2); animation: fadeInUp 0.5s var(--transition-timing) backwards; animation-delay: 0.2s; }
        .save-note-btn:hover { background-color: #27ae60; box-shadow: 0 5px 10px rgba(46, 204, 113, 0.3); transform: translateY(-1px); }
        .save-note-btn:active { transform: translateY(0px) scale(0.98); box-shadow: inset 0 1px 3px rgba(0,0,0,0.1); }
        #notes-feedback { font-size: 13px; color: var(--success-green); min-height: 1.2em; text-align: center; margin-bottom: 15px; font-weight: 500; transition: opacity 0.3s; opacity: 0; }
        #notes-feedback.visible { opacity: 1; }

        /* Gallery Screen */
        .gallery-screen { justify-content: flex-start; padding-bottom: 75px; }
        .gallery-container { display: grid; grid-template-columns: repeat(auto-fill, minmax(90px, 1fr)); gap: 12px; width: 100%; margin-top: 15px; animation: fadeInUpList 0.6s var(--transition-timing) backwards; animation-delay: 0.1s; }
        .gallery-item { position: relative; overflow: hidden; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); transition: transform 0.2s ease; }
        .gallery-item:hover { transform: scale(1.03); z-index: 5; }
        .gallery-item img { display: block; width: 100%; height: 90px; object-fit: cover; border-radius: 8px; border: 1px solid var(--light-gray); }
        .gallery-item .download-link { position: absolute; bottom: 6px; right: 6px; background-color: rgba(0,0,0,0.7); color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; justify-content: center; align-items: center; text-decoration: none; font-size: 11px; transition: background-color 0.2s, transform 0.2s; opacity: 0; transform: scale(0.8); }
        .gallery-item:hover .download-link { opacity: 1; transform: scale(1); }
        .gallery-item .download-link:hover { background-color: var(--rabbit-orange); transform: scale(1.1); }
        #gallery-empty-msg { font-style: italic; color: #999; text-align: center; width: 100%; margin-top: 30px; animation: fadeIn 0.5s ease; }


        /* --- Controls (Bottom) --- */
        .controls { display: flex; flex-direction: column; align-items: center; gap: 18px; width: 100%; padding-top: 5px; /* Add slight space above PTT */ }
        .ptt-button {
            width: 65px; height: 65px; border-radius: 50%;
            background: linear-gradient(145deg, var(--rabbit-orange), #ff9a33); /* Gradient PTT */
            border: none; display: flex; justify-content: center; align-items: center;
            cursor: pointer; color: white; font-size: 28px;
            box-shadow: 0 5px 15px rgba(255, 126, 0, 0.35), inset 0 -2px 3px rgba(0,0,0,0.1); /* Enhanced shadow */
            transition: transform 0.15s ease, background 0.2s, box-shadow 0.2s;
            user-select: none; -webkit-user-select: none; touch-action: manipulation;
            position: relative; /* For pseudo-elements */
            overflow: hidden;
            z-index: 20; /* Ensure PTT is above overlays */
        }
        .ptt-button::before { /* Subtle shine effect */
            content: ''; position: absolute; top: 0; left: -75%; width: 50%; height: 100%;
            background: linear-gradient(to right, rgba(255,255,255,0) 0%, rgba(255,255,255,0.3) 50%, rgba(255,255,255,0) 100%);
            transform: skewX(-25deg); transition: left 0.5s ease;
        }
        .ptt-button:not(:disabled):hover::before { left: 125%; }

        .ptt-button:active, .ptt-button.active {
            transform: scale(0.94);
            background: linear-gradient(145deg, var(--rabbit-orange-dark), var(--rabbit-orange));
            box-shadow: 0 3px 8px rgba(255, 126, 0, 0.3), inset 0 2px 4px rgba(0,0,0,0.15);
        }
        .ptt-button.active { animation: ptt-pulse 1.2s infinite ease-in-out; } /* Faster pulse */
        @keyframes ptt-pulse {
            0% { box-shadow: 0 3px 8px rgba(255, 126, 0, 0.3), inset 0 2px 4px rgba(0,0,0,0.15); }
            50% { box-shadow: 0 6px 18px rgba(255, 126, 0, 0.45), inset 0 2px 4px rgba(0,0,0,0.15); }
            100% { box-shadow: 0 3px 8px rgba(255, 126, 0, 0.3), inset 0 2px 4px rgba(0,0,0,0.15); }
        }
        .ptt-button:disabled { background: var(--medium-gray); cursor: not-allowed; box-shadow: none; transform: none; animation: none; opacity: 0.6; }
        .ptt-button:disabled:active { transform: none; }
        .ptt-button:disabled::before { display: none; }

        .scroll-controls { display: flex; gap: 25px; }
        .scroll-button {
            width: 42px; height: 42px; border-radius: 50%;
            background: linear-gradient(145deg, var(--medium-gray), var(--light-gray));
            border: none; display: flex; justify-content: center; align-items: center;
            cursor: pointer; color: var(--dark-gray);
            transition: all 0.2s ease;
            user-select: none; -webkit-user-select: none; touch-action: manipulation;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .scroll-button:hover {
            background: linear-gradient(145deg, var(--light-gray), var(--medium-gray));
            box-shadow: 0 4px 8px rgba(0,0,0,0.08);
            transform: translateY(-1px);
        }
        .scroll-button:active { transform: translateY(0px) scale(0.96); box-shadow: inset 0 1px 3px rgba(0,0,0,0.1); }

        /* --- Animation Keyframes --- */
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes fadeInScale {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }
        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes fadeInDown {
            from { opacity: 0; transform: translateY(-15px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes fadeInUpList { /* Staggered list items */
            from { opacity: 0; transform: translateY(15px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .alarms-list li, .gallery-item { /* Apply base for staggering */
            opacity: 0; animation: fadeInUpList 0.5s var(--transition-timing) forwards;
        }
        /* Example staggering (can be done with JS for more items) */
        .alarms-list li:nth-child(1), .gallery-item:nth-child(1) { animation-delay: 0.1s; }
        .alarms-list li:nth-child(2), .gallery-item:nth-child(2) { animation-delay: 0.15s; }
        .alarms-list li:nth-child(3), .gallery-item:nth-child(3) { animation-delay: 0.2s; }
        .alarms-list li:nth-child(4), .gallery-item:nth-child(4) { animation-delay: 0.25s; }
        /* etc. */

        @keyframes shake {
            10%, 90% { transform: translateX(-1px); }
            20%, 80% { transform: translateX(2px); }
            30%, 50%, 70% { transform: translateX(-3px); }
            40%, 60% { transform: translateX(3px); }
        }


        /* --- Responsive Adjustments --- */
        @media (max-width: 400px) {
            body { padding: 10px; }
            .device-container { max-width: 100%; }
            .rabbit-device { border-radius: 24px; padding: 15px; gap: 15px; }
            .main-display { border-radius: 16px; }
            .screen { padding: 20px; } /* Restore default padding */
            .vision-screen, .look-at-this-screen { padding: 0; } /* Keep no padding for camera */
            .screen h2 { font-size: 20px; margin-bottom: 15px; }
            .vision-screen h2, .look-at-this-screen h2 { font-size: 14px; padding: 5px 10px; top: 10px; } /* Adjust title on camera */
            .greeting { font-size: 24px; }
            .instruction { font-size: 16px; }
            .timer-display { font-size: 30px; }
            .album-art { width: 120px; height: 120px; }
            /* camera-container already full screen */
            .response-text { font-size: 14px; line-height: 1.6; }
            .response-text th, .response-text td { padding: 10px; }
            .gallery-container { grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 10px; }
            .gallery-item img { height: 80px; }
            .glass-overlay { padding: 8px 15px; border-radius: 12px; }
            .capture-btn, .look-capture-btn { font-size: 15px; padding: 9px 18px; }
            .vision-capture-overlay { bottom: 65px; } /* Adjust overlay positions for smaller screens */
            .look-capture-overlay { bottom: 65px; }
            .look-status-overlay { bottom: 115px; font-size: 13px; min-width: 180px; }
            .ptt-button { width: 60px; height: 60px; font-size: 26px; }
            .scroll-button { width: 40px; height: 40px; }
            .scroll-controls { gap: 20px; }
            .back-button { padding: 9px 18px; }
            .response-screen .back-button, .error-screen .back-button, .notes-screen .back-button,
            .gallery-screen .back-button { bottom: 15px; }
             .vision-screen .back-button, .look-at-this-screen .back-button { bottom: 15px; } /* Adjust camera back button */
        }

    </style>
</head>
<body>
    <div class="device-container">
        <div class="rabbit-device">
            <div class="main-display" id="main-display">

                <div class="screen home-screen active-screen" data-screen-name="home">
                    <div class="greeting">Bonjour Matéo</div>
                    <div class="instruction">Maintenez pour parler</div>
                    <div class="permission-status" id="permission-status">Vérification...</div>
                </div>

                <div class="screen listening-screen" data-screen-name="listening">
                    <div class="listening-indicator">
                        <div class="listening-text">Écoute en cours...</div>
                        <div class="waveform">
                            <span></span><span></span><span></span><span></span><span></span>
                        </div>
                    </div>
                </div>

                <div class="screen response-screen" data-screen-name="response">
                    <div class="query-text" id="query-text"></div>
                    <div class="response-text" id="response-text">
                        </div>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                <div class="screen alarms-screen" data-screen-name="alarms">
                    <h2>Alarmes</h2>
                    <ul class="alarms-list">
                        <li>7:00 - Réveil</li>
                        <li>12:30 - Déjeuner</li>
                        <li>18:00 - Sport</li>
                    </ul>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                <div class="screen timer-screen" data-screen-name="timer">
                    <h2>Minuteur</h2>
                    <div class="timer-display" id="timer-display">00:00</div>
                    <div class="timer-controls">
                        <button class="timer-btn" id="timer-start" aria-label="Démarrer le minuteur">Démarrer</button>
                        <button class="timer-btn" id="timer-reset" aria-label="Réinitialiser le minuteur">Réinitialiser</button>
                    </div>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                <div class="screen music-screen" data-screen-name="music">
                    <h2>Musique</h2>
                    <div class="album-art" role="img" aria-label="Pochette d'album"></div>
                    <div class="track-info">
                        <div class="track-title">Titre de la chanson</div>
                        <div class="artist-name">Nom de l'artiste</div>
                    </div>
                    <div class="music-controls">
                        <button class="music-btn" id="prev-track" aria-label="Piste précédente"><i class="fas fa-step-backward"></i></button>
                        <button class="music-btn" id="play-pause" aria-label="Lecture/Pause">
                            <i class="fas fa-play"></i>
                            <i class="fas fa-pause" style="position: absolute; transform: scale(0);"></i>
                        </button>
                        <button class="music-btn" id="next-track" aria-label="Piste suivante"><i class="fas fa-step-forward"></i></button>
                    </div>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                <div class="screen vision-screen" data-screen-name="vision">
                    <h2>Vision</h2>
                    <div class="camera-container" id="vision-camera-container">
                        <i class="fas fa-camera placeholder-icon"></i>
                        <div class="glass-overlay vision-capture-overlay">
                             <button class="capture-btn" id="vision-capture-btn" aria-label="Capturer l'image">
                                 <i class="fas fa-camera"></i> Capturer
                             </button>
                        </div>
                    </div>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                <div class="screen calendar-screen" data-screen-name="calendar">
                    <h2>Calendrier</h2>
                    <div class="calendar-placeholder">Placeholder Calendrier</div>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                <div class="screen notes-screen" data-screen-name="notes">
                    <h2>Notes</h2>
                    <textarea id="notes-textarea" class="notes-textarea" placeholder="Écrivez vos notes ici..."></textarea>
                    <button id="save-note-btn" class="save-note-btn"><i class="fas fa-save"></i> Enregistrer</button>
                    <div id="notes-feedback"></div>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                <div class="screen gallery-screen" data-screen-name="gallery">
                    <h2>Galerie Photos</h2>
                    <div id="gallery-container" class="gallery-container">
                        </div>
                    <p id="gallery-empty-msg" style="display: none;">Aucune photo capturée.</p>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                 <div class="screen look-at-this-screen" data-screen-name="look_and_ask">
                     <h2>Regarder & Demander</h2>
                      <div class="camera-container" id="look-camera-container">
                          <i class="fas fa-camera placeholder-icon"></i>
                          <div class="glass-overlay look-status-overlay" id="look-status-text">
                              Visez, puis capturez l'image.
                          </div>
                          <div class="glass-overlay look-capture-overlay">
                              <button class="look-capture-btn" id="look-capture-btn" aria-label="Capturer l'image pour l'IA">
                                  <i class="fas fa-camera"></i> Capturer
                              </button>
                          </div>
                      </div>
                     <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                 </div>

                <div class="screen error-screen" data-screen-name="error">
                    <h2><i class="fas fa-exclamation-triangle"></i> Erreur</h2>
                    <p id="error-message">Une erreur s'est produite.</p>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

            </div>

            <div class="controls">
                <button class="ptt-button" id="ptt-button" aria-label="Maintenir pour parler" aria-pressed="false" disabled>
                    <i class="fas fa-microphone"></i>
                </button>
                <div class="scroll-controls">
                    <button class="scroll-button" id="scroll-up" aria-label="Faire défiler vers le haut">
                        <i class="fas fa-chevron-up"></i>
                    </button>
                    <button class="scroll-button" id="scroll-down" aria-label="Faire défiler vers le bas">
                        <i class="fas fa-chevron-down"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Elements ---
            const mainDisplay = document.getElementById('main-display');
            const pttButton = document.getElementById('ptt-button');
            const scrollUpButton = document.getElementById('scroll-up');
            const scrollDownButton = document.getElementById('scroll-down');
            const queryTextElement = document.getElementById('query-text');
            const responseTextElement = document.getElementById('response-text');
            const permissionStatusElement = document.getElementById('permission-status');
            const errorMessageElement = document.getElementById('error-message');

            // Screen elements map
            const screens = {};
            document.querySelectorAll('.screen').forEach(screen => {
                const screenName = screen.dataset.screenName;
                if (screenName) screens[screenName] = screen;
            });

            // --- Screen Navigation Order ---
            const screenOrder = [
                'home', 'calendar', 'notes', 'gallery', 'alarms',
                'timer', 'music', 'vision', 'look_and_ask' // Added look_and_ask here
            ];
            let currentScreenIndex = 0;

            // --- State Variables ---
            let isListening = false;
            let recognitionActive = false;
            let speechPromiseCallbacks = null;
            let recognition = null;
            let speechApiAvailable = false;
            let permissionGranted = null; // null, true, false
            let conversationHistory = [];
            let lastInteractionTime = Date.now();
            const CONTEXT_TIMEOUT = 5 * 60 * 1000; // 5 minutes context

            // Timer Elements & State
            const timerStartButton = document.getElementById('timer-start');
            const timerResetButton = document.getElementById('timer-reset');
            const timerDisplayElement = document.getElementById('timer-display'); // Renamed for clarity
            let timerInterval = null;
            let timerSeconds = 0;
            let isTimerRunning = false;

            // Music Elements & State
            const playPauseButton = document.getElementById('play-pause');
            const prevTrackButton = document.getElementById('prev-track');
            const nextTrackButton = document.getElementById('next-track');
            let isMusicPlaying = false;

            // Vision (Simple Capture) Elements
            const visionCaptureButton = document.getElementById('vision-capture-btn');
            const visionCameraContainer = document.getElementById('vision-camera-container'); // The container

            // Notes Elements
            const notesTextarea = document.getElementById('notes-textarea');
            const saveNoteButton = document.getElementById('save-note-btn');
            const notesFeedback = document.getElementById('notes-feedback');

            // Gallery Elements
            const galleryContainer = document.getElementById('gallery-container');
            const galleryEmptyMsg = document.getElementById('gallery-empty-msg');
            let capturedPhotos = []; // In-memory storage for demo

            // Look & Ask (Multimodal) Elements & State
            const lookCameraContainer = document.getElementById('look-camera-container'); // The container
            const lookCaptureButton = document.getElementById('look-capture-btn');
            const lookStatusText = document.getElementById('look-status-text'); // The text element inside overlay
            let capturedImageDataForPrompt = null; // Base64 image data
            let isMultimodalPrompt = false; // Flag for PTT handler

            // Shared Media Elements
            let videoStream = null;
            const videoElement = document.createElement('video');
            videoElement.setAttribute('playsinline', ''); // Important for iOS
            videoElement.classList.add('live-video'); // Add class for styling & transitions
            // Append to specific containers when needed

            const canvasElement = document.createElement('canvas'); // For capturing frames

            // --- Configuration ---
            // WARNING: Storing API keys client-side is insecure. Use a backend proxy in production.
             const GEMINI_API_KEY = 'AIzaSyBW5xJAUSzhJP5n5p8znA39QFDR8JqtwPY'; // REPLACE WITH YOUR ACTUAL KEY
            const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`;
            const GEMINI_SAFETY_SETTINGS = [
                { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
            ];

            // --- System Instruction for Gemini (Pre-prompt) ---
            const SYSTEM_INSTRUCTION = `Tu es un assistant vocal intégré dans une interface web simulant un appareil Rabbit R1. Ton nom est Rabbit. Tu réponds à Matéo.
            Tu peux répondre aux questions de l'utilisateur et exécuter certaines actions. Tu peux afficher du texte formaté en Markdown (listes, gras, italique, titres, blocs de code, tableaux simples). Pour les questions simples ne nécessitant pas d'action, réponds directement en texte. Sois concis et direct.
            Pour exécuter une action, commence ta réponse EXACTEMENT par "% nom_fonction %" suivi de ta réponse textuelle normale (qui peut être vide si l'action est évidente). Ne mets rien avant le %.
            N'utilise qu'une seule commande de fonction par réponse, au tout début.
            Les fonctions disponibles sont :
            - % start_timer % : Démarre ou reprend le minuteur.
            - % reset_timer % : Réinitialise le minuteur.
            - % play_pause_music % : Met en lecture ou en pause la musique (simulation).
            - % prev_track % : Passe à la piste précédente (simulation).
            - % next_track % : Passe à la piste suivante (simulation).
            - % capture_image % : Prend une photo simple (depuis l'écran Vision) et l'ajoute à la galerie. Doit être sur l'écran Vision pour fonctionner. Confirme l'action.
            - % go_home % : Affiche l'écran d'accueil.
            - % show_alarms % : Affiche l'écran des alarmes.
            - % show_timer % : Affiche l'écran du minuteur.
            - % show_music % : Affiche l'écran de musique.
            - % show_vision % : Affiche l'écran de vision (pour capture simple).
            - % show_calendar % : Affiche l'écran du calendrier (placeholder).
            - % show_notes % : Affiche l'écran des notes et charge la dernière note sauvegardée.
            - % save_current_note % : Sauvegarde le texte actuellement présent dans la zone de notes. Confirme l'action.
            - % show_gallery % : Affiche la galerie des photos capturées.
            - % look_and_ask % : Active le mode caméra spécial pour que l'utilisateur prenne une photo et pose une question dessus. Réponds avec un texte invitant l'utilisateur, par exemple "% look_and_ask % D'accord, montre-le moi. Capture l'image puis pose ta question."

            Exemple 1: User: "lance le minuteur" -> AI: "% start_timer % Minuteur démarré."
            Exemple 2: User: "quelle heure est-il ?" -> AI: "Il est [heure actuelle]." (pas de fonction)
            Exemple 3: User: "montre la galerie" -> AI: "% show_gallery % Voici vos photos."
            Exemple 4: User: "sauvegarde cette note" -> AI: "% save_current_note % Note sauvegardée."
            Exemple 5: User: "qu'est-ce que c'est ?" -> AI: "% look_and_ask % D'accord, montre-le moi. Capture l'image puis pose ta question."
            Adapte ta réponse textuelle après la commande pour confirmer l'action ou répondre à la question.`;

            // --- Core Functions ---

            /**
             * Switches the active screen with animations.
             * @param {string} screenName - The target screen name.
             */
            async function switchScreen(screenName) {
                console.log(`Switching to screen: ${screenName}`);
                const currentActiveScreen = document.querySelector('.screen.active-screen');
                const targetScreen = screens[screenName];

                if (!targetScreen) {
                    console.error(`Screen "${screenName}" not found. Switching to home.`);
                    screenName = 'home';
                    targetScreen = screens.home;
                }

                // Don't do anything if already on the target screen
                if (currentActiveScreen === targetScreen) return;

                const previousScreenName = currentActiveScreen?.dataset.screenName;

                // Deactivate current screen
                if (currentActiveScreen) {
                    currentActiveScreen.classList.remove('active-screen');
                }

                // Activate target screen
                targetScreen.classList.add('active-screen');

                // Update current index for scroll navigation
                const navigableIndex = screenOrder.indexOf(screenName);
                if (navigableIndex !== -1) currentScreenIndex = navigableIndex;

                // Handle screen-specific actions AFTER transition starts
                if (screenName === 'response') screens.response.scrollTop = 0;
                if (screenName === 'gallery') displayGallery(); // Refresh gallery view
                if (screenName === 'notes') loadNote(); // Load note when entering

                // --- Camera Management ---
                const needsCamera = ['vision', 'look_and_ask'].includes(screenName);
                const cameraWasActive = ['vision', 'look_and_ask'].includes(previousScreenName);

                // Detach video from previous container immediately if it exists
                if (cameraWasActive && videoElement.parentElement) {
                    const oldContainer = videoElement.parentElement;
                    videoElement.classList.remove('active'); // Start fade out
                    videoElement.remove(); // Detach
                    oldContainer.classList.remove('video-active');
                    oldContainer.querySelector('.placeholder-icon')?.style.removeProperty('display');
                }

                if (needsCamera) {
                    // Pass the correct screen name to startVideoStream
                    await startVideoStream(screenName);
                } else if (cameraWasActive) {
                    stopVideoStream(); // Stop stream fully if leaving a camera screen
                }

                // Reset multimodal state if leaving look_and_ask screen
                 if (previousScreenName === 'look_and_ask' && screenName !== 'look_and_ask') {
                     resetLookAskState();
                 }
            }

            /** Displays an error message on the dedicated error screen or fallback. */
            function showErrorScreen(message) {
                console.error("Displaying error:", message);
                if (errorMessageElement && screens.error) {
                    errorMessageElement.textContent = message;
                    switchScreen('error');
                } else {
                    console.error("Error screen elements not found. Fallback display.");
                    switchScreen('response'); // Fallback to response screen
                    queryTextElement.textContent = "Erreur";
                    responseTextElement.innerHTML = `<p class="error-message">${message}</p>`;
                }
                lastInteractionTime = Date.now();
            }

            /** Updates the permission status message on the home screen. */
            function updatePermissionStatus(message, isError = false) {
                if (permissionStatusElement) {
                    permissionStatusElement.textContent = message;
                    permissionStatusElement.classList.toggle('error', isError);
                    console.log(`Permission status updated: "${message}" (isError: ${isError})`);
                }
            }

            // --- Speech Recognition ---
            async function initializeSpeechRecognition() {
                console.log("Initializing Speech Recognition...");
                updatePermissionStatus("Initialisation...");

                const SpeechRecognitionAPI = window.SpeechRecognition || window.webkitSpeechRecognition;
                if (!SpeechRecognitionAPI) { updatePermissionStatus("Reconnaissance vocale non supportée.", true); return false; }
                if (window.location.protocol !== 'https:' && !['localhost', '127.0.0.1'].includes(window.location.hostname)) { updatePermissionStatus("Connexion non sécurisée (HTTPS requis).", true); return false; }
                if (!navigator.mediaDevices?.getUserMedia) { updatePermissionStatus("Accès aux périphériques média impossible.", true); return false; }

                // Request Permissions
                try {
                    updatePermissionStatus("Demande des permissions...");
                    // Request both audio and video upfront for simplicity
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
                    permissionGranted = true;
                    updatePermissionStatus("Microphone et caméra prêts.");
                    stream.getTracks().forEach(track => track.stop()); // Stop the temporary stream

                    // Monitor permission changes (optional but good practice)
                    if (navigator.permissions?.query) {
                         const handlePermissionChange = (status, type) => {
                            console.log(`${type} permission state changed: ${status.state}`);
                            const isMic = type === 'microphone';
                            const currentlyGranted = status.state === 'granted';
                            if (isMic) permissionGranted = currentlyGranted;

                            updatePermissionStatus(currentlyGranted ? "Microphone et caméra prêts." : `Accès ${type} refusé.`, !currentlyGranted);
                            if (isMic) pttButton.disabled = !currentlyGranted;
                            if (!currentlyGranted) {
                                if (isMic && recognitionActive) recognition?.abort();
                                stopVideoStream(); // Stop camera if permission revoked
                            }
                        };
                        try {
                            const micStatus = await navigator.permissions.query({ name: 'microphone' });
                            micStatus.onchange = () => handlePermissionChange(micStatus, 'microphone');
                            const camStatus = await navigator.permissions.query({ name: 'camera' });
                            camStatus.onchange = () => handlePermissionChange(camStatus, 'camera');
                        } catch (e) { console.warn("Permission query API not fully supported or failed:", e); }
                    }

                } catch (err) {
                    permissionGranted = false;
                    let userMessage = "Impossible d'accéder aux périphériques.";
                    if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') userMessage = "Accès microphone/caméra refusé.";
                    else if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') userMessage = "Aucun microphone/caméra trouvé.";
                    else if (err.name === 'NotReadableError') userMessage = "Périphérique déjà utilisé ou problème matériel.";
                    else userMessage = `Erreur accès périphériques: ${err.name}`;
                    updatePermissionStatus(userMessage, true);
                    return false;
                }

                // Initialize SpeechRecognition Instance
                try {
                    recognition = new SpeechRecognitionAPI();
                    recognition.lang = 'fr-FR';
                    recognition.continuous = true; // Keep listening until stopped
                    recognition.interimResults = false; // Only final results
                    speechApiAvailable = true;
                    if (pttButton) pttButton.disabled = false;

                    let currentTranscript = '';
                    recognition.onstart = () => {
                        console.log("SpeechRecognition: onstart");
                        recognitionActive = true;
                        currentTranscript = '';
                        pttButton?.classList.add('active');
                        const currentScreen = document.querySelector('.screen.active-screen')?.dataset.screenName;
                        if (currentScreen === 'look_and_ask') {
                            lookStatusText.textContent = "Écoute en cours...";
                        } else {
                            switchScreen('listening');
                        }
                    };
                    recognition.onresult = (event) => {
                        let segment = '';
                        for (let i = event.resultIndex; i < event.results.length; ++i) {
                            if (event.results[i].isFinal) segment += event.results[i][0].transcript + ' ';
                        }
                        if (segment) currentTranscript += segment;
                        console.log("Transcript final accumulé:", currentTranscript.trim());
                       // We wait for onend triggered by ptt release
                    };
                    recognition.onerror = (event) => {
                        console.error(`SpeechRecognition: onerror - ${event.error}`, event.message);
                        recognitionActive = false;
                        pttButton?.classList.remove('active');
                        let userMessage = `Erreur reconnaissance: ${event.error}`;
                        if (event.error === 'not-allowed') { permissionGranted = false; updatePermissionStatus("Accès microphone refusé.", true); pttButton.disabled = true; userMessage = "Accès microphone refusé."; }
                        else if (event.error === 'no-speech') userMessage = "Je n'ai rien entendu.";
                        else if (event.error === 'audio-capture') userMessage = "Problème capture audio.";
                        else if (event.error === 'network') userMessage = "Erreur réseau reconnaissance.";

                        if (speechPromiseCallbacks?.reject && event.error !== 'aborted') { speechPromiseCallbacks.reject(new Error(userMessage)); }
                        else if (event.error !== 'aborted') { // Don't show error if user just aborted
                            const currentScreen = document.querySelector('.screen.active-screen')?.dataset.screenName;
                            if (currentScreen === 'look_and_ask') { lookStatusText.textContent = userMessage; setTimeout(resetLookAskState, 3000); }
                            else { showErrorScreen(userMessage); }
                        }
                        speechPromiseCallbacks = null; isListening = false;
                    };
                    recognition.onend = () => {
                        console.log("SpeechRecognition: onend");
                        recognitionActive = false;
                        pttButton?.classList.remove('active');
                        // Resolve the promise with the final transcript when recognition ends
                        if (speechPromiseCallbacks?.resolve) speechPromiseCallbacks.resolve(currentTranscript.trim());
                        speechPromiseCallbacks = null;
                        // Update UI state if needed (e.g., if on look_and_ask)
                        const currentScreen = document.querySelector('.screen.active-screen')?.dataset.screenName;
                        if (currentScreen === 'look_and_ask' && lookStatusText.textContent === "Écoute en cours...") {
                            lookStatusText.textContent = "Traitement..."; // Indicate processing after listening stops
                        }
                    };
                } catch (error) { console.error("Error initializing SpeechRecognition instance:", error); updatePermissionStatus("Erreur init reconnaissance.", true); return false; }
                return true; // Success
            }

            /** Starts the speech recognition process, returning a promise. */
            async function startSpeechRecognition() {
                return new Promise(async (resolve, reject) => {
                    if (!speechApiAvailable || !recognition) return reject(new Error("Reco. non initialisée."));
                    if (recognitionActive) return reject(new Error("Écoute déjà en cours."));
                    if (permissionGranted === false) return reject(new Error("Accès microphone refusé."));

                    // Quick permission re-check
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                        stream.getTracks().forEach(track => track.stop());
                        permissionGranted = true; if (pttButton) pttButton.disabled = false;
                    } catch (err) {
                        permissionGranted = false; updatePermissionStatus("Accès microphone refusé.", true); if (pttButton) pttButton.disabled = true;
                        return reject(new Error("Accès microphone refusé."));
                    }

                    console.log("Attempting to start listening...");
                    speechPromiseCallbacks = { resolve, reject };
                    try {
                        recognition.start();
                    } catch (e) {
                        console.error("Immediate error on recognition.start():", e);
                        recognitionActive = false; speechPromiseCallbacks = null;
                        reject(new Error(`Erreur démarrage reco: ${e.message || e.name}`));
                    }
                });
            }

            // --- PTT Button Handlers ---
            function handlePttStart(event) {
                event.preventDefault(); // Prevent default actions like text selection
                console.log("PTT Start");
                if (!speechApiAvailable || permissionGranted === false) { console.warn("PTT ignored: API/Permission issue."); return; }
                if (isListening || recognitionActive) { console.warn("PTT ignored: Already listening."); return; }

                // Check for multimodal context
                const currentScreen = document.querySelector('.screen.active-screen')?.dataset.screenName;
                isMultimodalPrompt = (currentScreen === 'look_and_ask' && !!capturedImageDataForPrompt);
                if (currentScreen === 'look_and_ask' && !capturedImageDataForPrompt) {
                    console.warn("PTT on Look&Ask screen but no image captured yet.");
                    lookStatusText.textContent = "Veuillez d'abord capturer une image.";
                    // Flash the capture button maybe?
                    lookCaptureButton.style.animation = 'shake 0.5s ease';
                    setTimeout(() => { lookCaptureButton.style.animation = ''; }, 500);
                    return; // Don't start listening without image
                }

                isListening = true;
                pttButton?.setAttribute('aria-pressed', 'true');
                // Class 'active' is added by recognition.onstart

                startSpeechRecognition()
                    .then(result => {
                        console.log("Recognition promise resolved.");
                        processSpeechResult(result); // Process the final transcript
                    })
                    .catch(error => {
                        console.error("Recognition promise rejected:", error);
                         // Avoid showing redundant errors if already handled by recognition.onerror
                        if (!error.message.includes("reconnaissance") && !error.message.includes("microphone") && !error.message.includes("entendu")) {
                            if (isMultimodalPrompt) { lookStatusText.textContent = `Erreur: ${error.message}`; setTimeout(resetLookAskState, 3000); }
                            else { showErrorScreen(error.message); }
                        }
                        isListening = false; pttButton?.classList.remove('active'); pttButton?.setAttribute('aria-pressed', 'false');
                        isMultimodalPrompt = false; // Reset flag on error
                    });
            }

            function handlePttEnd(event) {
                event.preventDefault();
                console.log("PTT End");
                if (!isListening) { console.warn("PTT End ignored: Not listening."); return; }
                isListening = false;
                pttButton?.setAttribute('aria-pressed', 'false');
                // Class 'active' is removed by recognition.onend

                if (recognitionActive && recognition) {
                    console.log("Stopping recognition via recognition.stop()...");
                    try {
                        recognition.stop(); // This will trigger recognition.onend eventually
                    } catch (e) {
                        console.error("Error on recognition.stop():", e);
                        // Manually reject the promise if stop fails immediately
                        if (speechPromiseCallbacks?.reject) speechPromiseCallbacks.reject(new Error("Échec arrêt reco."));
                        speechPromiseCallbacks = null;
                        // Update UI immediately if stop fails
                        if (isMultimodalPrompt) { lookStatusText.textContent = "Erreur lors de l'arrêt."; setTimeout(resetLookAskState, 3000); }
                        else { showErrorScreen("Erreur lors de l'arrêt de l'écoute."); }
                        isMultimodalPrompt = false; // Reset flag
                    }
                } else {
                    console.warn("PTT End: Recognition not active or already stopped.");
                    // If recognition wasn't active, reject any pending promise
                    if (speechPromiseCallbacks?.reject) speechPromiseCallbacks.reject(new Error("Écoute terminée prématurément."));
                    speechPromiseCallbacks = null;
                    isMultimodalPrompt = false; // Reset flag
                }
            }

            /** Processes the final speech result, calls Gemini, and handles the response. */
            async function processSpeechResult(result) {
                console.log("Processing final speech result:", result);
                lastInteractionTime = Date.now(); // Update context timer

                const wasMultimodal = isMultimodalPrompt; // Store before resetting
                const imageForPrompt = capturedImageDataForPrompt; // Store before resetting

                // Reset multimodal state early, API call handles its own logic
                if (wasMultimodal) {
                    lookStatusText.textContent = "Traitement...";
                } else {
                    switchScreen('response'); // Switch to response screen for normal queries
                }

                if (result instanceof Error) {
                    queryTextElement.textContent = "Erreur de reconnaissance";
                    responseTextElement.innerHTML = `<p class="error-message">${result.message}</p>`;
                    if (wasMultimodal) { lookStatusText.textContent = `Erreur: ${result.message}`; setTimeout(resetLookAskState, 3000); switchScreen('response'); } // Show error on response screen
                } else if (typeof result === 'string') {
                    const query = result.trim();
                    queryTextElement.textContent = query || "[Aucun texte reconnu]"; // Show query

                    if (!query) {
                        const noUnderstandMsg = "<p>Je n'ai pas compris ou rien entendu. Veuillez réessayer.</p>";
                        responseTextElement.innerHTML = noUnderstandMsg;
                        if (wasMultimodal) {
                            lookStatusText.textContent = "Rien entendu. Réessayez.";
                            // Don't reset image, allow user to try speaking again
                            lookCaptureButton.disabled = true; // Keep disabled until reset or new capture
                        }
                    } else {
                        // Show loading indicator
                        if (!wasMultimodal) {
                             responseTextElement.innerHTML = `<div class="loading-indicator"><div class="spinner medium"></div><i>Réflexion en cours...</i></div>`;
                        } else {
                            // Status already shows "Traitement..."
                        }

                        // Call API (normal or multimodal)
                        if (GEMINI_API_KEY && GEMINI_API_KEY !== 'YOUR_API_KEY') {
                            try {
                                let answer;
                                if (wasMultimodal && imageForPrompt) {
                                    console.log("Calling Gemini with Image and Text");
                                    answer = await queryGeminiWithImage(query, imageForPrompt);
                                    // Switch to response screen AFTER getting the multimodal response
                                    switchScreen('response');
                                } else {
                                    console.log("Calling Gemini with Text only");
                                    answer = await queryGemini(query);
                                }
                                processApiResponse(answer); // Process function calls/text and display
                            } catch (geminiError) {
                                console.error("Gemini API call error:", geminiError);
                                const errorHtml = `<p class="error-message">Erreur IA : ${geminiError.message}</p>`;
                                responseTextElement.innerHTML = errorHtml; // Display error on response screen
                                // If it was multimodal, also briefly show error on look screen status before resetting
                                if (wasMultimodal) {
                                    lookStatusText.textContent = `Erreur IA: ${geminiError.message}`;
                                    setTimeout(resetLookAskState, 3500); // Slightly longer timeout for error
                                    switchScreen('response'); // Ensure error is shown on response screen
                                }
                            } finally {
                                // Clean up multimodal state fully AFTER API call attempt
                                if (wasMultimodal) {
                                    // Reset state if not already reset by error timeout
                                    // Use a small delay to ensure it doesn't interfere with screen switch
                                    setTimeout(resetLookAskState, 100);
                                }
                            }
                        } else {
                            // No API Key
                            const noApiKeyMsg = "<p><i>(Fonctionnalité IA non configurée - Veuillez ajouter votre clé API dans le code JS)</i></p>";
                            responseTextElement.innerHTML = noApiKeyMsg;
                            addToHistory('user', query); addToHistory('model', "(Fonctionnalité IA non configurée)");
                            if (wasMultimodal) {
                                lookStatusText.textContent = "Fonctionnalité IA non configurée.";
                                setTimeout(resetLookAskState, 3000);
                                switchScreen('response'); // Show message on response screen
                            }
                        }
                    }
                } else {
                    // Unexpected result type
                    const unexpectedMsg = '<p class="error-message">Problème inattendu (traitement voix).</p>';
                    queryTextElement.textContent = "Erreur Inattendue"; responseTextElement.innerHTML = unexpectedMsg;
                    if (wasMultimodal) { lookStatusText.textContent = "Erreur inattendue."; setTimeout(resetLookAskState, 3000); switchScreen('response'); }
                }
                // Ensure flags are reset
                 isMultimodalPrompt = false;
                 // capturedImageDataForPrompt is reset within resetLookAskState or handled above
            }

            // --- Context and Function Calling ---

            /** Adds a message to the conversation history. */
            function addToHistory(role, text) {
                // Keep history concise, maybe limit length
                if (conversationHistory.length > 10) {
                    conversationHistory = conversationHistory.slice(-10); // Keep last 10 turns (user+model)
                }
                conversationHistory.push({ role, parts: [{ text }] });
                console.log("Added to history:", { role, text: text.substring(0, 60) + '...' });
            }
            /** Checks context timeout and clears history if needed. */
            function checkContextTimeout() {
                const now = Date.now();
                if (now - lastInteractionTime > CONTEXT_TIMEOUT) {
                    console.log("Context timeout. Clearing conversation history.");
                    conversationHistory = [];
                }
                // lastInteractionTime is updated on user input or API response
            }
            /** Executes a local function based on the name provided by the AI. */
            function executeFunction(functionName) {
                console.log(`Executing function: ${functionName}`);
                try {
                    switch (functionName) {
                        case 'start_timer': if (timerStartButton && !isTimerRunning) timerStartButton.click(); break;
                        case 'reset_timer': timerResetButton?.click(); break;
                        case 'play_pause_music': playPauseButton?.click(); break;
                        case 'prev_track': prevTrackButton?.click(); console.log("Simulating previous track"); break;
                        case 'next_track': nextTrackButton?.click(); console.log("Simulating next track"); break;
                        case 'capture_image':
                            if (document.querySelector('.screen.active-screen')?.dataset.screenName === 'vision') {
                                visionCaptureButton?.click(); // Trigger the capture
                            } else {
                                console.warn("Capture_image called outside Vision screen.");
                                // Optionally, switch to vision screen first?
                                // switchScreen('vision');
                                // setTimeout(() => visionCaptureButton?.click(), 500); // Delay capture after screen switch
                            }
                            break;
                        case 'go_home': switchScreen('home'); break;
                        case 'show_alarms': switchScreen('alarms'); break;
                        case 'show_timer': switchScreen('timer'); break;
                        case 'show_music': switchScreen('music'); break;
                        case 'show_vision': switchScreen('vision'); break;
                        case 'show_calendar': switchScreen('calendar'); break;
                        case 'show_notes': switchScreen('notes'); break;
                        case 'save_current_note': saveNote(); break; // Call the save function
                        case 'show_gallery': switchScreen('gallery'); break;
                        case 'look_and_ask': switchScreen('look_and_ask'); break; // Switch to multimodal screen

                        default: console.warn(`Function "${functionName}" not recognized.`);
                    }
                } catch (error) { console.error(`Error executing function "${functionName}":`, error); }
            }
            /** Processes the API response, handles function calls, and displays text. */
            function processApiResponse(apiResponseText) {
                const functionCallRegex = /^\s*%\s*([a-zA-Z0-9_]+)\s*%([\s\S]*)/;
                const match = apiResponseText.match(functionCallRegex);
                let displayText = apiResponseText;

                if (match) {
                    const functionName = match[1].trim();
                    const remainingText = match[2].trim();
                    console.log(`Function call detected: ${functionName}`);
                    executeFunction(functionName);
                    // Use remaining text if available, otherwise provide a generic confirmation
                    displayText = remainingText || `(Action ${functionName} exécutée)`;
                }

                // Display the textual part of the response
                displayMarkdownResponse(displayText, responseTextElement);

                // Add the RAW model response to history for context
                addToHistory('model', apiResponseText);
                lastInteractionTime = Date.now(); // Update context timer after response
            }

            // --- Utility Functions (Timer, Music Simulation) ---
            function formatTime(seconds) { return `${Math.floor(seconds / 60).toString().padStart(2, '0')}:${(seconds % 60).toString().padStart(2, '0')}`; }
            timerStartButton?.addEventListener('click', () => {
                if (!timerDisplayElement) return;
                if (isTimerRunning) {
                    clearInterval(timerInterval);
                    timerStartButton.textContent = 'Reprendre';
                    timerDisplayElement.classList.remove('running');
                } else {
                    timerStartButton.textContent = 'Pause';
                    timerDisplayElement.classList.add('running');
                    // Ensure timer starts immediately, then intervals
                    timerSeconds++;
                    timerDisplayElement.textContent = formatTime(timerSeconds);
                    timerInterval = setInterval(() => {
                        timerSeconds++;
                        timerDisplayElement.textContent = formatTime(timerSeconds);
                    }, 1000);
                }
                isTimerRunning = !isTimerRunning;
                timerStartButton.setAttribute('aria-label', isTimerRunning ? 'Mettre le minuteur en pause' : 'Reprendre le minuteur');
            });
            timerResetButton?.addEventListener('click', () => {
                if (!timerDisplayElement || !timerStartButton) return;
                clearInterval(timerInterval); timerSeconds = 0; isTimerRunning = false;
                timerDisplayElement.textContent = formatTime(timerSeconds);
                timerStartButton.textContent = 'Démarrer';
                timerStartButton.setAttribute('aria-label', 'Démarrer le minuteur');
                timerDisplayElement.classList.remove('running');
            });
            playPauseButton?.addEventListener('click', () => {
                const iconContainer = playPauseButton; // The button itself
                if (!iconContainer) return;
                isMusicPlaying = !isMusicPlaying;
                iconContainer.classList.toggle('playing', isMusicPlaying);
                iconContainer.setAttribute('aria-label', isMusicPlaying ? 'Pause' : 'Lecture');
                console.log(`Music ${isMusicPlaying ? 'playing' : 'paused'} (simulation)`);
            });
            prevTrackButton?.addEventListener('click', () => console.log("Previous track (simulation)"));
            nextTrackButton?.addEventListener('click', () => console.log("Next track (simulation)"));

            // --- Camera Management ---
            async function startVideoStream(targetScreenName) { // targetScreenName is the parameter
                // FIX: Use targetScreenName to determine the container
                const targetContainer = targetScreenName === 'vision' ? visionCameraContainer : (targetScreenName === 'look_and_ask' ? lookCameraContainer : null);
                if (!targetContainer) {
                     console.error(`No valid target container found for screen: ${targetScreenName}`);
                     return false;
                }

                // If stream already exists and is attached to the correct container, just ensure it's visible
                if (videoStream && videoElement.parentElement === targetContainer) {
                    console.log("Video stream already active for this screen.");
                    targetContainer.classList.add('video-active');
                    videoElement.classList.add('active'); // Ensure fade-in transition runs
                    return true;
                }
                // If stream exists but not attached, attach it
                if (videoStream && videoElement.parentElement !== targetContainer) {
                     console.log("Attaching existing video stream to new screen.");
                     targetContainer.appendChild(videoElement);
                     targetContainer.classList.add('video-active');
                     videoElement.play().catch(e => console.error("Error re-playing video:", e)); // Ensure playing
                     setTimeout(() => videoElement.classList.add('active'), 10); // Allow attachment before fade-in
                     return true;
                }

                // If no stream exists, try to start it
                if (!videoStream) {
                    if (permissionGranted === false) { console.warn("Cannot start video: permission denied."); showErrorScreen("Accès caméra refusé."); return false; }

                    try {
                        console.log(`Attempting to start NEW video stream for ${targetScreenName}...`);
                        const constraints = { video: { facingMode: "environment" } }; // Prefer back camera
                        videoStream = await navigator.mediaDevices.getUserMedia(constraints)
                            .catch(async (e) => {
                                console.warn("Environment camera failed, trying default:", e);
                                // Try default camera only if specific error indicates environment cam issue
                                if (e.name === 'OverconstrainedError' || e.name === 'NotFoundError' || e.name === 'NotReadableError') {
                                    return navigator.mediaDevices.getUserMedia({ video: true });
                                }
                                throw e; // Re-throw other errors
                            });

                        videoElement.srcObject = videoStream;
                        await videoElement.play(); // Play returns a promise
                        console.log("Video stream started successfully.");

                        // Attach to the correct container
                        targetContainer.appendChild(videoElement);
                        targetContainer.classList.add('video-active');
                        setTimeout(() => videoElement.classList.add('active'), 10); // Fade in after slight delay

                        return true;
                    } catch (err) {
                        console.error("Error starting video stream:", err);
                        let userMessage = "Impossible de démarrer le flux vidéo.";
                         if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') userMessage = "Accès caméra refusé.";
                         else if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') userMessage = "Aucune caméra trouvée.";
                         else if (err.name === 'NotReadableError' || err.name === 'OverconstrainedError' || err.name === 'TrackStartError' || err.name === 'AbortError') userMessage = "Caméra déjà utilisée ou problème matériel.";
                         else userMessage = `Erreur caméra: ${err.message || err.name}`;
                        showErrorScreen(userMessage); videoStream = null; return false;
                    }
                }
                 return false; // Should be unreachable
            }

            function stopVideoStream() {
                if (videoStream) {
                    console.log("Stopping video stream.");
                    videoStream.getTracks().forEach(track => track.stop());
                    videoStream = null;
                    videoElement.srcObject = null;
                    videoElement.classList.remove('active'); // Fade out
                    if (videoElement.parentElement) {
                        videoElement.parentElement.classList.remove('video-active');
                        videoElement.remove();
                    }
                    // Restore placeholder icons if needed (might already be visible)
                    visionCameraContainer?.querySelector('.placeholder-icon')?.style.removeProperty('display');
                    lookCameraContainer?.querySelector('.placeholder-icon')?.style.removeProperty('display');
                }
            }

            function captureImageFromVideo() {
                if (!videoStream || !videoElement.videoWidth || !videoElement.videoHeight || videoElement.paused || videoElement.ended) {
                    console.error("Cannot capture: video stream not ready or inactive.");
                    showErrorScreen("Impossible de capturer (flux vidéo non prêt).");
                    return null;
                }
                canvasElement.width = videoElement.videoWidth;
                canvasElement.height = videoElement.videoHeight;
                try {
                    const context = canvasElement.getContext('2d');
                    context.drawImage(videoElement, 0, 0, canvasElement.width, canvasElement.height);
                    // Use JPEG for smaller size, adjust quality as needed
                    const imageDataUrl = canvasElement.toDataURL('image/jpeg', 0.9);
                    console.log('Image captured (JPEG):', imageDataUrl.substring(0, 60) + '...');
                    return imageDataUrl;
                } catch (e) {
                    console.error("Error capturing or converting image:", e);
                    // Check for potential SecurityError (tainted canvas) although unlikely with getUserMedia
                    if (e.name === 'SecurityError') {
                         showErrorScreen("Erreur de sécurité lors de la capture.");
                    } else {
                         showErrorScreen("Erreur lors de la capture de l'image.");
                    }
                    return null;
                }
            }

            // --- Vision Screen Capture Handler ---
            visionCaptureButton?.addEventListener('click', () => {
                console.log('Vision Capture button clicked.');
                const imageDataUrl = captureImageFromVideo();
                if (imageDataUrl) {
                    capturedPhotos.push(imageDataUrl);
                    console.log(`Photo added to gallery. Total: ${capturedPhotos.length}`);
                    // Provide feedback - maybe flash the screen or show a temporary message
                    mainDisplay.style.transition = 'opacity 0.1s ease-out';
                    mainDisplay.style.opacity = '0.8';
                    setTimeout(() => { mainDisplay.style.opacity = '1'; }, 100);

                    // Optionally switch to gallery or show confirmation on response screen
                    // switchScreen('gallery');
                    switchScreen('response');
                    queryTextElement.textContent = "Vision";
                    responseTextElement.innerHTML = "<p>Photo capturée et ajoutée à la galerie.</p>";
                }
            });

            // --- Gallery Display ---
            function displayGallery() {
                if (!galleryContainer || !galleryEmptyMsg) return;
                galleryContainer.innerHTML = ''; // Clear previous items
                if (capturedPhotos.length === 0) {
                    galleryEmptyMsg.style.display = 'block';
                } else {
                    galleryEmptyMsg.style.display = 'none';
                    capturedPhotos.forEach((dataUrl, index) => {
                        const item = document.createElement('div'); item.className = 'gallery-item';
                        const img = document.createElement('img'); img.src = dataUrl; img.alt = `Photo capturée ${index + 1}`;
                        img.onerror = () => { img.alt = "Erreur chargement image"; /* Basic fallback */ };
                        const downloadLink = document.createElement('a'); downloadLink.href = dataUrl; downloadLink.download = `rabbit_capture_${index + 1}.jpg`; // Use jpg extension
                        downloadLink.className = 'download-link'; downloadLink.innerHTML = '<i class="fas fa-download"></i>';
                        downloadLink.setAttribute('aria-label', 'Télécharger l\'image'); downloadLink.title = 'Télécharger';
                        item.appendChild(img); item.appendChild(downloadLink);
                        galleryContainer.appendChild(item);
                        // Apply staggered animation delay (can also be done purely in CSS if max items known)
                        item.style.animationDelay = `${index * 0.05}s`;
                    });
                }
            }

            // --- Notes Management ---
            function saveNote() {
                if (notesTextarea) {
                    const noteContent = notesTextarea.value;
                    try {
                        localStorage.setItem('rabbit_note', noteContent);
                        console.log("Note saved to localStorage.");
                        if(notesFeedback) {
                            notesFeedback.textContent = "Note enregistrée !";
                            notesFeedback.classList.add('visible'); // Make visible
                            setTimeout(() => { notesFeedback.classList.remove('visible'); }, 2000); // Fade out
                        }
                    } catch (e) {
                         console.error("Error saving note:", e);
                         if(notesFeedback) {
                             notesFeedback.textContent = "Erreur sauvegarde.";
                             notesFeedback.style.color = 'var(--error-red)'; // Show error color
                             notesFeedback.classList.add('visible');
                             setTimeout(() => {
                                 notesFeedback.classList.remove('visible');
                                 notesFeedback.style.color = 'var(--success-green)'; // Reset color
                             }, 3000);
                         }
                    }
                }
            }
            function loadNote() {
                if (notesTextarea) {
                    try {
                        const savedNote = localStorage.getItem('rabbit_note');
                        if (savedNote !== null) { notesTextarea.value = savedNote; console.log("Note loaded."); }
                        else { notesTextarea.value = ''; } // Clear if no note saved
                    } catch (e) { console.error("Error loading note:", e); notesTextarea.value = ''; }
                }
            }
            saveNoteButton?.addEventListener('click', saveNote);

            // --- Look & Ask (Multimodal) Management ---
            function resetLookAskState() {
                console.log("Resetting Look & Ask state.");
                capturedImageDataForPrompt = null; isMultimodalPrompt = false;
                lookStatusText.textContent = "Visez, puis capturez l'image.";
                lookCaptureButton.disabled = false;

                // Remove preview if exists
                const preview = lookCameraContainer?.querySelector('.captured-image-preview');
                if (preview) preview.remove();

                // Ensure video is visible if stream is active and attached
                if (videoStream && videoElement.parentElement === lookCameraContainer) {
                    videoElement.style.display = 'block'; // Make sure it's not hidden
                    videoElement.classList.add('active'); // Ensure visible
                } else if (!videoStream) {
                    // Ensure placeholder is visible if no stream
                    lookCameraContainer?.classList.remove('video-active');
                    lookCameraContainer?.querySelector('.placeholder-icon')?.style.removeProperty('display');
                }
            }
            lookCaptureButton?.addEventListener('click', () => {
                console.log('Look & Ask Capture button clicked.');
                const imageDataUrl = captureImageFromVideo();
                if (imageDataUrl) {
                    capturedImageDataForPrompt = imageDataUrl; // Store base64 data
                    lookStatusText.textContent = "Image capturée. Parlez maintenant.";
                    lookCaptureButton.disabled = true; // Disable capture until reset

                    // Remove previous preview if any, then add new one
                    const existingPreview = lookCameraContainer?.querySelector('.captured-image-preview');
                    if(existingPreview) existingPreview.remove();

                    const previewImg = document.createElement('img');
                    previewImg.src = imageDataUrl;
                    previewImg.className = 'captured-image-preview';
                    lookCameraContainer.appendChild(previewImg);

                    // Hide live video feed underneath
                    videoElement.style.display = 'none';
                    videoElement.classList.remove('active');

                } else {
                    lookStatusText.textContent = "Échec de la capture. Réessayez.";
                    // Optionally re-enable capture button immediately?
                    // lookCaptureButton.disabled = false;
                }
            });

            // --- Gemini API Calls ---
            async function queryGemini(prompt) {
                console.log("Querying Gemini (Text):", prompt);
                checkContextTimeout();
                addToHistory('user', prompt);

                if (!GEMINI_API_KEY || GEMINI_API_KEY === 'YOUR_API_KEY') { const errorMsg = "Clé API non configurée."; addToHistory('model', errorMsg); throw new Error(errorMsg); }

                // Construct payload including system instruction and history
                const requestContents = [
                    { role: 'user', parts: [{ text: SYSTEM_INSTRUCTION }] }, // Start with system instruction
                    ...conversationHistory // Add the rest of the history
                ];

                try {
                    const response = await fetch(GEMINI_API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: requestContents,
                            safetySettings: GEMINI_SAFETY_SETTINGS
                        })
                    });
                    const data = await response.json();

                    if (!response.ok) {
                        console.error('Gemini API Error:', response.status, data);
                        const errorMessage = data?.error?.message || `Erreur HTTP ${response.status}`;
                        const fullErrorMsg = `Erreur API IA : ${errorMessage}`;
                        addToHistory('model', `Erreur: ${fullErrorMsg}`); // Log error to history
                        throw new Error(fullErrorMsg);
                    }

                    console.log("Gemini API Response (Raw):", data);

                    let responseText = "Désolé, je n'ai pas pu générer de réponse.";
                    if (data.candidates?.length > 0) {
                        const candidate = data.candidates[0];
                        // Check for abnormal finish reasons
                        if (candidate.finishReason && candidate.finishReason !== 'STOP' && candidate.finishReason !== 'MAX_TOKENS') {
                             const reason = candidate.finishReason.replace(/_/g, ' ').toLowerCase();
                             // Append reason to the text if available, otherwise just show the reason
                             responseText = (candidate.content?.parts?.[0]?.text || "") + `\n\n_(Réponse interrompue: ${reason}.)_`;
                             console.warn(`Gemini response finish reason: ${candidate.finishReason}`);
                        } else {
                             responseText = candidate.content?.parts?.[0]?.text || "Format de réponse inattendu.";
                        }
                    } else if (data.promptFeedback?.blockReason) {
                        // Handle blocked responses
                        const reason = data.promptFeedback.blockReason.replace(/_/g, ' ').toLowerCase();
                        responseText = `Réponse bloquée (${reason}).`;
                        console.warn(`Gemini response blocked: ${data.promptFeedback.blockReason}`);
                    }

                    return responseText; // Return the processed text

                } catch (error) {
                    console.error('Error fetching Gemini (Text):', error);
                    // Avoid double-logging API errors already added to history
                    if (!error.message.includes("Erreur API IA")) {
                        addToHistory('model', `Erreur réseau/fetch: ${error.message}`);
                    }
                    throw error; // Re-throw the error to be caught by processSpeechResult
                }
            }

            async function queryGeminiWithImage(prompt, base64ImageData) {
                console.log("Querying Gemini (Multimodal):", prompt);
                checkContextTimeout();
                // Add text part to history, image is added in the request payload below
                addToHistory('user', prompt);

                if (!GEMINI_API_KEY || GEMINI_API_KEY === 'YOUR_API_KEY') { const errorMsg = "Clé API non configurée."; addToHistory('model', errorMsg); throw new Error(errorMsg); }

                // Remove data URL prefix if present
                const pureBase64 = base64ImageData.includes(',') ? base64ImageData.split(',')[1] : base64ImageData;

                // Construct payload: system instruction, history (excluding last user prompt), new multimodal user prompt
                const requestContents = [
                    { role: 'user', parts: [{ text: SYSTEM_INSTRUCTION }] },
                    ...conversationHistory.slice(0, -1), // History up to the last user prompt
                    {
                        role: 'user',
                        parts: [
                            { text: prompt }, // The user's spoken question
                            { inline_data: { mime_type: 'image/jpeg', data: pureBase64 } } // The captured image
                        ]
                    }
                ];

                // Update UI to show analysis is happening (on the response screen)
                 switchScreen('response'); // Switch immediately to show loading
                 queryTextElement.textContent = prompt; // Show the query text
                 responseTextElement.innerHTML = `<div class="loading-indicator"><div class="spinner medium"></div><i>Analyse de l'image...</i></div>`;


                try {
                    const response = await fetch(GEMINI_API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: requestContents,
                            safetySettings: GEMINI_SAFETY_SETTINGS
                         })
                    });
                    const data = await response.json();

                    if (!response.ok) {
                        console.error('Gemini API Error (Multimodal):', response.status, data);
                        const errorMessage = data?.error?.message || `Erreur HTTP ${response.status}`;
                        const fullErrorMsg = `Erreur IA (image) : ${errorMessage}`;
                        addToHistory('model', `Erreur: ${fullErrorMsg}`);
                        throw new Error(fullErrorMsg);
                    }

                    console.log("Gemini API Response (Multimodal Raw):", data);

                    let responseText = "Désolé, je n'ai pas pu analyser l'image.";
                    if (data.candidates?.length > 0) {
                         const candidate = data.candidates[0];
                         if (candidate.finishReason && candidate.finishReason !== 'STOP' && candidate.finishReason !== 'MAX_TOKENS') {
                             const reason = candidate.finishReason.replace(/_/g, ' ').toLowerCase();
                             responseText = (candidate.content?.parts?.[0]?.text || "") + `\n\n_(Analyse interrompue: ${reason}.)_`;
                             console.warn(`Gemini multimodal response finish reason: ${candidate.finishReason}`);
                         } else {
                             responseText = candidate.content?.parts?.[0]?.text || "Je n'ai pas de commentaire sur cette image.";
                         }
                    } else if (data.promptFeedback?.blockReason) {
                         const reason = data.promptFeedback.blockReason.replace(/_/g, ' ').toLowerCase();
                         responseText = `Analyse bloquée (${reason}).`;
                         console.warn(`Gemini multimodal response blocked: ${data.promptFeedback.blockReason}`);
                    }

                    return responseText; // Return the processed text

                } catch (error) {
                    console.error('Error fetching Gemini (Multimodal):', error);
                     if (!error.message.includes("Erreur IA")) {
                         addToHistory('model', `Erreur réseau/fetch (image): ${error.message}`);
                     }
                    throw error; // Re-throw
                }
            }


            // --- Markdown Display ---
            /**
             * Basic Markdown to HTML conversion. Handles common elements.
             * NOTE: This is a simplified parser. For complex Markdown, use a library like Marked.js or Showdown.js.
             * @param {string} markdown - Markdown text.
             * @returns {string} HTML string.
             */
            function markdownToHtml(markdown) {
                 if (typeof markdown !== 'string') return '';

                 let html = markdown;

                 // Block elements first
                 // Code blocks (```lang\ncode``` or ```\ncode```)
                 html = html.replace(/```(?:[a-z]+\n)?([\s\S]*?)```/gs, (match, code) => `<pre><code>${code.trim().replace(/</g, '&lt;').replace(/>/g, '&gt;')}</code></pre>`);
                 // Headings (###, ##, #)
                 html = html.replace(/^### (.*$)/gm, '<h3>$1</h3>');
                 html = html.replace(/^## (.*$)/gm, '<h2>$1</h2>');
                 html = html.replace(/^# (.*$)/gm, '<h1>$1</h1>');
                 // Horizontal rules (---, ___, ***)
                 html = html.replace(/^(?:-{3,}|_{3,}|\*{3,})$/gm, '<hr>');
                 // Blockquotes (> )
                 html = html.replace(/^(?:> (?:.*\n?))+/gm, (match) => `<blockquote>${markdownToHtmlSimpleInline(match.replace(/^> /gm, '').trim())}</blockquote>`); // Recursive call for inline inside quote
                 // Lists (unordered *, +, -; ordered 1.) - Basic implementation, handles simple lists
                 html = html.replace(/^([*+-]) (.*(?:\n(?!\1 | {2,}).*)*)/gm, (match, marker, itemContent) => `<ul><li>${markdownToHtmlSimpleInline(itemContent.trim())}</li></ul>`);
                 html = html.replace(/^(\d+)\. (.*(?:\n(?!\d+\. | {2,}).*)*)/gm, (match, num, itemContent) => `<ol start="${num}"><li>${markdownToHtmlSimpleInline(itemContent.trim())}</li></ol>`);
                 // Combine adjacent lists of the same type
                 html = html.replace(/<\/ul>\s*<ul>/g, '');
                 html = html.replace(/<\/ol>\s*<ol(?: start="\d+")?>/g, '');

                 // Inline elements (after block elements)
                 // Images (![alt](src))
                 html = html.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, '<img src="$2" alt="$1" style="max-width: 100%; height: auto; border-radius: 4px; margin: 0.5em 0;">'); // Added basic styling
                 // Links ([text](url))
                 html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
                 // Apply simple inline formatting (bold, italic, code)
                 html = markdownToHtmlSimpleInline(html);

                 // Paragraphs (handle remaining lines)
                 // Wrap lines that aren't already part of a block element in <p> tags
                 html = html.split('\n').map(line => {
                     line = line.trim();
                     if (line.length === 0) return '';
                     // Check if the line starts with an HTML tag that indicates a block element
                     if (!line.match(/^<\/?(h[1-6]|ul|ol|li|blockquote|hr|pre|img|table|thead|tbody|tr|th|td)/i)) {
                         return `<p>${line}</p>`; // Wrap in paragraph
                     }
                     return line; // Keep as is
                 }).join('');

                 // Cleanup potential empty paragraphs or redundant blockquote tags
                 html = html.replace(/<p>\s*<\/p>/g, '');
                 html = html.replace(/<\/blockquote>\s*<blockquote>/g, ''); // Combine adjacent blockquotes

                 return html;
            }
             /** Handles simple inline markdown: **bold**, *italic*, `code` */
            function markdownToHtmlSimpleInline(text) {
                 // Bold (**)
                 text = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/__(.*?)__/g, '<strong>$1</strong>');
                 // Italic (*)
                 text = text.replace(/\*(.*?)\*/g, '<em>$1</em>').replace(/_(.*?)_/g, '<em>$1</em>');
                 // Inline code (`)
                 text = text.replace(/`([^`]+)`/g, '<code>$1</code>');
                 return text;
            }
            /** Displays the HTML response with a fade-in effect. */
            function displayMarkdownResponse(markdownText, element) {
                if (element) {
                    const htmlContent = markdownToHtml(markdownText);
                    // Fade out old content, then fade in new
                    element.style.transition = 'opacity 0.2s ease-out';
                    element.style.opacity = 0;

                    setTimeout(() => {
                        element.innerHTML = htmlContent;
                        element.scrollTop = 0; // Scroll to top of new content
                        element.style.transition = 'opacity 0.3s ease-in';
                        element.style.opacity = 1;
                    }, 200); // Wait for fade out before changing content

                } else { console.error("Response display element not found."); }
            }


            // --- Scroll & Back Button Handlers ---
            scrollUpButton?.addEventListener('click', () => {
                const currentScreenName = document.querySelector('.screen.active-screen')?.dataset.screenName;
                if (currentScreenName === 'listening') return; // Don't scroll while listening
                currentScreenIndex = (currentScreenIndex - 1 + screenOrder.length) % screenOrder.length;
                switchScreen(screenOrder[currentScreenIndex]);
            });
            scrollDownButton?.addEventListener('click', () => {
                 const currentScreenName = document.querySelector('.screen.active-screen')?.dataset.screenName;
                 if (currentScreenName === 'listening') return;
                 currentScreenIndex = (currentScreenIndex + 1) % screenOrder.length;
                 switchScreen(screenOrder[currentScreenIndex]);
            });
            document.querySelectorAll('.back-button').forEach(button => {
                 button.addEventListener('click', (event) => {
                     const target = event.currentTarget.dataset.targetScreen || 'home';
                     switchScreen(target);
                 });
            });

            // --- App Initialization ---
            async function initializeApp() {
                console.log("Initializing Rabbit R1 Web App (Cool Edition)...");
                switchScreen('home'); // Start on home screen
                loadNote(); // Load initial note state

                const speechReady = await initializeSpeechRecognition();

                if (speechReady && pttButton) {
                    // Use pointer events for better touch & mouse handling
                    pttButton.addEventListener('pointerdown', handlePttStart);
                    pttButton.addEventListener('pointerup', handlePttEnd);
                    pttButton.addEventListener('pointerleave', (e) => { if (isListening) handlePttEnd(e); }); // End if pointer leaves while pressed
                    pttButton.addEventListener('contextmenu', (e) => e.preventDefault()); // Prevent context menu on long press

                    console.log("PTT Handlers attached.");
                } else {
                     console.warn("PTT initialization failed or permissions denied.");
                     if(pttButton) pttButton.disabled = true;
                }
                console.log("Application initialized.");
            }

            // Start the application
            initializeApp();

            // Cleanup: Stop video stream when leaving the page/closing tab
            window.addEventListener('beforeunload', stopVideoStream);

        }); // End DOMContentLoaded
    </script>
</body>
</html>
