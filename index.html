<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rabbit R1 Web App</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Press+Start+2P&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        /* Variables globales */
        :root {
            --rabbit-orange: #ff7e00;
            --off-white: #f8f8f8;
            --light-gray: #e0e0e0;
            --medium-gray: #cccccc;
            --dark-gray: #333333;
            --device-gray: #d0d0d0;
            --error-red: #d9534f; /* Couleur pour les erreurs */
            --success-green: #5cb85c; /* Couleur pour succès */
        }

        /* Styles de base */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--off-white);
            color: var(--dark-gray);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            -webkit-tap-highlight-color: transparent; /* Empêche le flash bleu sur mobile */
        }

        /* Container du dispositif */
        .device-container {
            width: 100%;
            max-width: 360px; /* Limite la largeur max */
            margin: 0 auto;
        }

        .rabbit-device {
            background-color: var(--device-gray);
            border-radius: 24px;
            padding: 16px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 16px; /* Espace entre l'écran et les contrôles */
        }

        /* Écran principal */
        .main-display {
            background-color: var(--off-white);
            border-radius: 16px;
            width: 100%;
            aspect-ratio: 1 / 1; /* Format carré */
            overflow: hidden; /* Cache le contenu qui dépasse */
            position: relative; /* Pour positionner les écrans */
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.1);
        }

        /* Écrans (général) */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            /* justify-content: center; /* Centré par défaut, mais sera surchargé */
            align-items: center; /* Centre horizontalement par défaut */
            padding: 20px;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease, transform 0.3s ease;
            transform: translateX(20px); /* Légère translation pour l'effet d'entrée */
            overflow-y: auto; /* Permet le défilement si le contenu dépasse */
            background-color: var(--off-white); /* Fond pour tous les écrans */
        }

        .active-screen {
            opacity: 1;
            visibility: visible;
            transform: translateX(0); /* Annule la translation */
        }

        /* Bouton Retour (commun à plusieurs écrans) */
        .back-button {
            margin-top: auto; /* Pousse le bouton vers le bas */
            padding: 8px 16px;
            background-color: var(--medium-gray);
            border: none;
            border-radius: 4px;
            color: var(--dark-gray);
            cursor: pointer;
            transition: background-color 0.2s;
            font-size: 14px;
            display: inline-flex; /* Pour aligner l'icône et le texte */
            align-items: center;
            gap: 5px; /* Espace entre icône et texte */
            z-index: 10; /* Pour être au-dessus d'autres éléments */
        }
        .back-button:hover {
            background-color: var(--light-gray);
        }
        /* Positionnement spécifique pour certains écrans */
        .response-screen .back-button,
        .error-screen .back-button,
        .notes-screen .back-button,
        .gallery-screen .back-button,
        .look-at-this-screen .back-button {
             position: absolute;
             bottom: 15px;
             left: 50%;
             transform: translateX(-50%);
        }
         .calendar-screen .back-button,
         .alarms-screen .back-button,
         .timer-screen .back-button,
         .music-screen .back-button,
         .vision-screen .back-button {
            margin-top: 20px; /* Espace standard en bas pour ces écrans */
         }


        /* Titres d'écran communs */
        .screen h2 {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 20px;
            text-align: center;
            width: 100%;
            color: var(--dark-gray);
        }

        /* --- Styles spécifiques aux écrans --- */

        /* Écran d'accueil */
        .home-screen {
            justify-content: center;
            text-align: center;
        }
        .greeting { font-size: 24px; font-weight: 600; margin-bottom: 10px; }
        .instruction { font-size: 16px; color: #666; margin-bottom: 15px; }
        .permission-status { font-size: 12px; color: #666; margin-top: 10px; min-height: 1.2em; font-weight: 500; }
        .permission-status.error { color: var(--error-red); font-weight: 600; }

        /* Écran d'écoute */
        .listening-screen { justify-content: center; }
        .listening-indicator { text-align: center; }
        .listening-text { font-size: 18px; margin-bottom: 20px; animation: pulse 1.5s infinite alternate; }
        .waveform { display: flex; justify-content: center; align-items: center; gap: 5px; height: 40px; }
        .waveform span { display: inline-block; width: 5px; height: 20px; background-color: var(--rabbit-orange); border-radius: 2px; }
        .waveform span:nth-child(1) { animation: wave 0.5s infinite alternate; }
        .waveform span:nth-child(2) { animation: wave 0.5s infinite alternate 0.1s; }
        .waveform span:nth-child(3) { animation: wave 0.5s infinite alternate 0.2s; }
        .waveform span:nth-child(4) { animation: wave 0.5s infinite alternate 0.3s; }
        @keyframes wave { 0% { height: 10px; opacity: 0.7; } 100% { height: 30px; opacity: 1; } }
        @keyframes pulse { 0% { opacity: 0.6; } 100% { opacity: 1; } }

        /* Écran de réponse */
        .response-screen { justify-content: flex-start; align-items: flex-start; padding-bottom: 60px; }
        .query-text { font-weight: 600; margin-bottom: 16px; align-self: flex-start; width: 100%; color: #555; border-bottom: 1px solid var(--light-gray); padding-bottom: 8px; word-wrap: break-word; }
        .response-text { width: 100%; font-size: 15px; line-height: 1.6; word-wrap: break-word; padding-bottom: 30px; }
        .response-text p i { color: #666; }
        .response-text p.error-message { color: var(--error-red); font-weight: 600; }
        /* Styles Markdown (inchangés) */
        .response-text p { margin-bottom: 1em; }
        .response-text h1, .response-text h2, .response-text h3 { margin-top: 1.5em; margin-bottom: 0.8em; line-height: 1.3; }
        .response-text h1 { font-size: 1.6em; border-bottom: 1px solid var(--light-gray); padding-bottom: 0.3em;}
        .response-text h2 { font-size: 1.4em; }
        .response-text h3 { font-size: 1.2em; }
        .response-text ul, .response-text ol { margin-left: 25px; margin-bottom: 1em; }
        .response-text li { margin-bottom: 0.5em; }
        .response-text code { background-color: #eee; padding: 0.2em 0.4em; border-radius: 3px; font-family: monospace; font-size: 0.9em; word-wrap: break-word; }
        .response-text pre { background-color: #eee; padding: 15px; border-radius: 5px; overflow-x: auto; margin-bottom: 1em; }
        .response-text pre code { background-color: transparent; padding: 0; font-size: 0.9em; word-wrap: normal; }
        .response-text blockquote { border-left: 4px solid var(--medium-gray); padding-left: 15px; margin: 1em 0; color: #555; font-style: italic; }
        .response-text table { border-collapse: collapse; width: 100%; margin: 1.5em 0; border: 1px solid var(--dark-gray); }
        .response-text th, .response-text td { border: 1px solid var(--dark-gray); padding: 10px; text-align: left; }
        .response-text th { background-color: var(--light-gray); font-weight: 600; }
        .response-text hr { border: none; border-top: 1px solid var(--light-gray); margin: 2em 0; }
        .response-text a { color: var(--rabbit-orange); text-decoration: none; }
        .response-text a:hover { text-decoration: underline; }
        .response-text img { max-width: 100%; height: auto; border-radius: 4px; margin: 0.5em 0; }

        /* Écran des alarmes */
        .alarms-screen { justify-content: flex-start; }
        .alarms-list { list-style: none; width: 100%; padding: 0; }
        .alarms-list li { padding: 12px; border-bottom: 1px solid var(--light-gray); }

        /* Écran du minuteur */
        .timer-screen { justify-content: flex-start; }
        .timer-display { font-family: 'Press Start 2P', cursive; font-size: 32px; margin: 20px 0; color: var(--dark-gray); }
        .timer-controls { display: flex; gap: 10px; margin-bottom: 20px;}
        .timer-btn { padding: 8px 16px; background-color: var(--medium-gray); border: none; border-radius: 4px; color: var(--dark-gray); cursor: pointer; transition: background-color 0.2s; }
        .timer-btn:hover { background-color: var(--light-gray); }

        /* Écran de musique */
        .music-screen { justify-content: flex-start; }
        .album-art { width: 120px; height: 120px; background-color: var(--medium-gray); border-radius: 8px; margin-bottom: 16px; display: flex; justify-content: center; align-items: center; font-size: 40px; color: #fff; background-image: linear-gradient(45deg, #aaa, #ccc); }
        .album-art::before { content: '\f001'; font-family: 'Font Awesome 6 Free'; font-weight: 900; }
        .track-info { text-align: center; margin-bottom: 16px; }
        .track-title { font-weight: 600; margin-bottom: 4px; }
        .artist-name { font-size: 14px; color: #666; }
        .music-controls { display: flex; gap: 16px; margin-bottom: 20px;}
        .music-btn { width: 40px; height: 40px; border-radius: 50%; background-color: var(--medium-gray); border: none; display: flex; justify-content: center; align-items: center; cursor: pointer; transition: background-color 0.2s; font-size: 16px; color: var(--dark-gray); }
        .music-btn:hover { background-color: var(--light-gray); }

        /* Écran de vision */
        .vision-screen { justify-content: flex-start; }
        .camera-placeholder { width: 200px; height: 150px; background-color: var(--medium-gray); border-radius: 8px; display: flex; justify-content: center; align-items: center; margin-bottom: 20px; border: 2px dashed var(--dark-gray); overflow: hidden; position: relative; }
        .camera-placeholder i { font-size: 48px; color: var(--dark-gray); }
        .capture-btn { padding: 10px 20px; background-color: var(--rabbit-orange); border: none; border-radius: 8px; color: white; cursor: pointer; transition: background-color 0.2s; font-size: 16px; font-weight: 500; }
        .capture-btn:hover { background-color: #e67200; }
        /* Style pour la vidéo live */
        .live-video { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: 1;}

        /* Écran d'erreur */
        .error-screen { justify-content: flex-start; text-align: center; padding-bottom: 60px; }
        .error-screen h2 { color: var(--error-red); }
        #error-message { margin-bottom: 20px; color: var(--error-red); font-weight: 500;}

        /* --- NOUVEAUX ÉCRANS --- */

        /* Écran Calendrier */
        .calendar-screen { justify-content: flex-start; }
        .calendar-placeholder { width: 100%; max-width: 300px; height: 200px; background-color: #eee; border: 1px solid var(--light-gray); display: flex; justify-content: center; align-items: center; font-style: italic; color: #999; border-radius: 8px; }

        /* Écran Notes */
        .notes-screen { justify-content: flex-start; padding-bottom: 60px; } /* Espace pour bouton retour */
        .notes-textarea { width: 100%; height: 150px; margin-bottom: 15px; padding: 10px; border: 1px solid var(--light-gray); border-radius: 4px; font-family: inherit; font-size: 14px; resize: vertical; }
        .save-note-btn { padding: 8px 16px; background-color: var(--success-green); color: white; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.2s; }
        .save-note-btn:hover { background-color: #4cae4c; }
        #notes-feedback { font-size: 12px; color: var(--success-green); margin-top: 10px; min-height: 1em; }

        /* Écran Galerie Photos */
        .gallery-screen { justify-content: flex-start; padding-bottom: 60px; }
        .gallery-container { display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 10px; width: 100%; margin-top: 10px; }
        .gallery-item { position: relative; }
        .gallery-item img { display: block; width: 100%; height: 80px; object-fit: cover; border-radius: 4px; border: 1px solid var(--light-gray); }
        .gallery-item .download-link { position: absolute; bottom: 5px; right: 5px; background-color: rgba(0,0,0,0.6); color: white; border-radius: 50%; width: 20px; height: 20px; display: flex; justify-content: center; align-items: center; text-decoration: none; font-size: 10px; transition: background-color 0.2s; }
        .gallery-item .download-link:hover { background-color: rgba(0,0,0,0.8); }
        #gallery-empty-msg { font-style: italic; color: #999; }

        /* Écran "Look & Ask" (Multimodal) */
        .look-at-this-screen { justify-content: flex-start; padding-bottom: 60px; }
        .look-camera-container { width: 100%; max-width: 240px; height: 180px; background-color: var(--medium-gray); border-radius: 8px; margin-bottom: 15px; border: 2px dashed var(--dark-gray); overflow: hidden; position: relative; display: flex; justify-content: center; align-items: center; }
        .look-camera-container i { font-size: 48px; color: var(--dark-gray); z-index: 0; }
        .look-camera-container .live-video { z-index: 1; } /* Vidéo au-dessus de l'icône */
        .look-camera-container .captured-image-preview { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: 2; border-radius: 8px; /* Pour masquer les coins de la vidéo en dessous */ }
        .look-capture-btn { padding: 10px 20px; background-color: var(--rabbit-orange); border: none; border-radius: 8px; color: white; cursor: pointer; transition: background-color 0.2s; font-size: 16px; font-weight: 500; margin-bottom: 15px; }
        .look-capture-btn:hover { background-color: #e67200; }
        .look-status-text { font-size: 14px; color: #666; text-align: center; min-height: 1.5em; }


        /* --- Contrôles (Bas) --- */
        .controls { display: flex; flex-direction: column; align-items: center; gap: 16px; width: 100%; }
        .ptt-button { width: 60px; height: 60px; border-radius: 50%; background-color: var(--rabbit-orange); border: none; display: flex; justify-content: center; align-items: center; cursor: pointer; color: white; font-size: 24px; box-shadow: 0 4px 8px rgba(255, 126, 0, 0.3); transition: transform 0.1s ease, background-color 0.2s, box-shadow 0.2s; user-select: none; -webkit-user-select: none; touch-action: manipulation; }
        .ptt-button:active, .ptt-button.active { transform: scale(0.95); background-color: #e67200; box-shadow: 0 2px 4px rgba(255, 126, 0, 0.3); }
        .ptt-button.active { animation: ptt-pulse 1.5s infinite ease-in-out; }
        @keyframes ptt-pulse { 0% { box-shadow: 0 2px 4px rgba(255, 126, 0, 0.3); } 50% { box-shadow: 0 4px 12px rgba(255, 126, 0, 0.5); } 100% { box-shadow: 0 2px 4px rgba(255, 126, 0, 0.3); } }
        .scroll-controls { display: flex; gap: 20px; }
        .scroll-button { width: 40px; height: 40px; border-radius: 50%; background-color: var(--medium-gray); border: none; display: flex; justify-content: center; align-items: center; cursor: pointer; color: var(--dark-gray); transition: background-color 0.2s, transform 0.1s ease; user-select: none; -webkit-user-select: none; touch-action: manipulation; }
        .scroll-button:active { background-color: var(--light-gray); transform: scale(0.95); }
        .ptt-button:disabled { background-color: var(--medium-gray); cursor: not-allowed; box-shadow: none; transform: none; animation: none; opacity: 0.7; }
        .ptt-button:disabled:active { transform: none; }

        /* Responsive */
        @media (max-width: 400px) {
            body { padding: 10px; }
            .device-container { max-width: 100%; }
            .rabbit-device { border-radius: 16px; padding: 12px; }
            .timer-display { font-size: 28px; }
            .album-art { width: 100px; height: 100px; }
            .camera-placeholder { width: 180px; height: 135px; }
            .look-camera-container { width: 100%; height: 180px; max-width: none; }
            .response-text { font-size: 14px; }
            .response-text th, .response-text td { padding: 8px; }
            .gallery-container { grid-template-columns: repeat(auto-fill, minmax(70px, 1fr)); }
            .gallery-item img { height: 70px; }
        }
    </style>
</head>
<body>
    <div class="device-container">
        <div class="rabbit-device">
            <div class="main-display" id="main-display">
                <div class="screen home-screen active-screen" data-screen-name="home">
                    <div class="greeting">Bonjour Matéo</div>
                    <div class="instruction">Maintenez pour parler</div>
                    <div class="permission-status" id="permission-status">Vérification des permissions...</div>
                </div>

                <div class="screen listening-screen" data-screen-name="listening">
                    <div class="listening-indicator">
                        <div class="listening-text">Écoute en cours...</div>
                        <div class="waveform">
                            <span></span><span></span><span></span><span></span>
                        </div>
                    </div>
                </div>

                <div class="screen response-screen" data-screen-name="response">
                    <div class="query-text" id="query-text"></div>
                    <div class="response-text" id="response-text"></div>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                <div class="screen alarms-screen" data-screen-name="alarms">
                    <h2>Alarmes</h2>
                    <ul class="alarms-list">
                        <li>7:00 - Réveil</li>
                        <li>12:30 - Déjeuner</li>
                        <li>18:00 - Sport</li>
                    </ul>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                <div class="screen timer-screen" data-screen-name="timer">
                    <h2>Minuteur</h2>
                    <div class="timer-display">00:00</div>
                    <div class="timer-controls">
                        <button class="timer-btn" id="timer-start" aria-label="Démarrer le minuteur">Démarrer</button>
                        <button class="timer-btn" id="timer-reset" aria-label="Réinitialiser le minuteur">Réinitialiser</button>
                    </div>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                <div class="screen music-screen" data-screen-name="music">
                    <h2>Musique</h2>
                    <div class="album-art" role="img" aria-label="Pochette d'album"></div>
                    <div class="track-info">
                        <div class="track-title">Titre de la chanson</div>
                        <div class="artist-name">Nom de l'artiste</div>
                    </div>
                    <div class="music-controls">
                        <button class="music-btn" id="prev-track" aria-label="Piste précédente"><i class="fas fa-step-backward"></i></button>
                        <button class="music-btn" id="play-pause" aria-label="Lecture/Pause"><i class="fas fa-play"></i></button>
                        <button class="music-btn" id="next-track" aria-label="Piste suivante"><i class="fas fa-step-forward"></i></button>
                    </div>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                <div class="screen vision-screen" data-screen-name="vision">
                    <h2>Vision</h2>
                    <div class="camera-placeholder" id="vision-camera-placeholder" aria-hidden="true">
                        <i class="fas fa-camera"></i>
                         </div>
                    <button class="capture-btn" id="vision-capture-btn" aria-label="Capturer l'image">Capturer</button>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                <div class="screen calendar-screen" data-screen-name="calendar">
                    <h2>Calendrier</h2>
                    <div class="calendar-placeholder">Placeholder Calendrier</div>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                <div class="screen notes-screen" data-screen-name="notes">
                    <h2>Notes</h2>
                    <textarea id="notes-textarea" class="notes-textarea" placeholder="Écrivez vos notes ici..."></textarea>
                    <button id="save-note-btn" class="save-note-btn"><i class="fas fa-save"></i> Enregistrer</button>
                    <div id="notes-feedback"></div>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                <div class="screen gallery-screen" data-screen-name="gallery">
                    <h2>Galerie Photos</h2>
                    <div id="gallery-container" class="gallery-container">
                        </div>
                    <p id="gallery-empty-msg" style="display: none;">Aucune photo capturée pour le moment.</p>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                 <div class="screen look-at-this-screen" data-screen-name="look_and_ask">
                    <h2>Regarder & Demander</h2>
                    <div class="look-camera-container" id="look-camera-container">
                        <i class="fas fa-camera"></i>
                        </div>
                    <button class="look-capture-btn" id="look-capture-btn" aria-label="Capturer l'image pour l'IA">Capturer l'image</button>
                    <div class="look-status-text" id="look-status-text">Visez, puis capturez l'image.</div>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                <div class="screen error-screen" data-screen-name="error">
                    <h2>Erreur</h2>
                    <p id="error-message">Une erreur s'est produite.</p>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

            </div>

            <div class="controls">
                <button class="ptt-button" id="ptt-button" aria-label="Maintenir pour parler" aria-pressed="false" disabled>
                    <i class="fas fa-microphone"></i>
                </button>

                <div class="scroll-controls">
                    <button class="scroll-button" id="scroll-up" aria-label="Faire défiler vers le haut">
                        <i class="fas fa-chevron-up"></i>
                    </button>
                    <button class="scroll-button" id="scroll-down" aria-label="Faire défiler vers le bas">
                        <i class="fas fa-chevron-down"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Éléments DOM ---
            const mainDisplay = document.getElementById('main-display');
            const pttButton = document.getElementById('ptt-button');
            const scrollUpButton = document.getElementById('scroll-up');
            const scrollDownButton = document.getElementById('scroll-down');
            const queryTextElement = document.getElementById('query-text');
            const responseTextElement = document.getElementById('response-text');
            const permissionStatusElement = document.getElementById('permission-status');
            const errorMessageElement = document.getElementById('error-message');

            // Récupération dynamique des écrans
            const screens = {};
            document.querySelectorAll('.screen').forEach(screen => {
                const screenName = screen.dataset.screenName;
                if (screenName) {
                    screens[screenName] = screen;
                }
            });

            // --- NOUVEAU: Ordre de navigation incluant les nouveaux écrans ---
            const screenOrder = [
                'home',
                'calendar', // Ajouté
                'notes',    // Ajouté
                'gallery',  // Ajouté
                'alarms',
                'timer',
                'music',
                'vision',
                // 'look_and_ask' n'est pas dans la navigation standard par scroll
            ];
            let currentScreenIndex = 0; // Index dans screenOrder

            // --- Variables d'état ---
            let isListening = false;
            let recognitionActive = false;
            let speechPromiseCallbacks = null;
            let recognition = null;
            let speechApiAvailable = false;
            let permissionGranted = null; // null, true, false
            let conversationHistory = [];
            let lastInteractionTime = Date.now();
            const CONTEXT_TIMEOUT = 60 * 1000; // 1 minute

            // Minuteur
            const timerStartButton = document.getElementById('timer-start');
            const timerResetButton = document.getElementById('timer-reset');
            const timerDisplay = document.querySelector('.timer-display');
            let timerInterval = null;
            let timerSeconds = 0;
            let isTimerRunning = false;

            // Musique
            const playPauseButton = document.getElementById('play-pause');
            const prevTrackButton = document.getElementById('prev-track');
            const nextTrackButton = document.getElementById('next-track');
            let isMusicPlaying = false;

            // Vision (Capture simple)
            const visionCaptureButton = document.getElementById('vision-capture-btn');
            const visionCameraPlaceholder = document.getElementById('vision-camera-placeholder');

            // --- NOUVEAU: Notes ---
            const notesTextarea = document.getElementById('notes-textarea');
            const saveNoteButton = document.getElementById('save-note-btn');
            const notesFeedback = document.getElementById('notes-feedback');

            // --- NOUVEAU: Galerie ---
            const galleryContainer = document.getElementById('gallery-container');
            const galleryEmptyMsg = document.getElementById('gallery-empty-msg');
            let capturedPhotos = []; // Stockage en mémoire pour la démo

            // --- NOUVEAU: Look & Ask (Multimodal) ---
            const lookCameraContainer = document.getElementById('look-camera-container');
            const lookCaptureButton = document.getElementById('look-capture-btn');
            const lookStatusText = document.getElementById('look-status-text');
            let capturedImageDataForPrompt = null; // Stocke l'image Base64 pour la requête multimodale
            let isMultimodalPrompt = false; // Flag pour le PTT

            // Vidéo Elements (partagés potentiellement)
            let videoStream = null;
            const videoElement = document.createElement('video');
            videoElement.style.display = 'none'; // Caché par défaut
            videoElement.setAttribute('playsinline', '');
            document.body.appendChild(videoElement);

            const canvasElement = document.createElement('canvas');
            const context = canvasElement.getContext('2d');


            // --- Configuration ---
            const GEMINI_API_KEY = 'AIzaSyBW5xJAUSzhJP5n5p8znA39QFDR8JqtwPY'; // REMPLACEZ PAR VOTRE VRAIE CLÉ API GEMINI
            const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${GEMINI_API_KEY}`; // Modèle Flash pour potentiellement multimodal

            // --- NOUVEAU: Instruction Système pour Gemini (Mise à jour) ---
            const SYSTEM_INSTRUCTION = `Tu es un assistant vocal intégré dans une interface web simulant un appareil Rabbit R1.
            Tu peux répondre aux questions de l'utilisateur et exécuter certaines actions. Tu peux afficher du texte formaté en Markdown, y compris des tableaux.
            Pour exécuter une action, commence ta réponse EXACTEMENT par "% nom_fonction %" suivi de ta réponse textuelle normale. Ne mets rien avant le %.
            N'utilise qu'une seule commande de fonction par réponse, au tout début. Si aucune action n'est requise, réponds simplement en texte.
            Les fonctions disponibles sont :
            - % start_timer % : Démarre ou reprend le minuteur.
            - % reset_timer % : Réinitialise le minuteur.
            - % play_pause_music % : Met en lecture ou en pause la musique (simulation).
            - % prev_track % : Passe à la piste précédente (simulation).
            - % next_track % : Passe à la piste suivante (simulation).
            - % capture_image % : Prend une photo simple (depuis l'écran Vision) et l'ajoute à la galerie.
            - % go_home % : Affiche l'écran d'accueil.
            - % show_alarms % : Affiche l'écran des alarmes.
            - % show_timer % : Affiche l'écran du minuteur.
            - % show_music % : Affiche l'écran de musique.
            - % show_vision % : Affiche l'écran de vision (pour capture simple).
            - % show_calendar % : Affiche l'écran du calendrier.
            - % show_notes % : Affiche l'écran des notes et charge la dernière note sauvegardée.
            - % save_current_note % : Sauvegarde le texte actuellement présent dans la zone de notes.
            - % show_gallery % : Affiche la galerie des photos capturées.
            - % look_and_ask % : Demande à l'utilisateur de montrer quelque chose via la caméra pour ensuite poser une question dessus.

            Exemple 1: Si l'utilisateur demande "lance le minuteur", réponds "% start_timer % Minuteur démarré."
            Exemple 2: Si l'utilisateur demande "quelle heure est-il ?", réponds simplement l'heure actuelle sans commande de fonction.
            Exemple 3: Si l'utilisateur demande "montre moi l'écran de musique", réponds "% show_music % Voici l'écran de musique."
            Exemple 4: Si l'utilisateur demande "sauvegarde cette note", réponds "% save_current_note % Note sauvegardée."
            Exemple 5: Si l'utilisateur demande "qu'est-ce que c'est ?", réponds "% look_and_ask % D'accord, montre-le moi. Capture l'image puis pose ta question."
            Adapte ta réponse textuelle après la commande pour confirmer l'action ou répondre à la question.`;

            // --- Fonctions ---

            /**
             * Affiche un écran spécifique et masque les autres.
             * Gère aussi le démarrage/arrêt du flux vidéo pour les écrans caméra.
             * @param {string} screenName - Le nom de l'écran à afficher.
             */
            async function switchScreen(screenName) {
                console.log(`Switching to screen: ${screenName}`);
                const previousScreen = document.querySelector('.screen.active-screen');
                const previousScreenName = previousScreen?.dataset.screenName;

                let foundScreen = false;
                Object.entries(screens).forEach(([name, screenElement]) => {
                    if (name === screenName) {
                        screenElement.classList.add('active-screen');
                        foundScreen = true;
                        const navigableIndex = screenOrder.indexOf(screenName);
                        if (navigableIndex !== -1) {
                            currentScreenIndex = navigableIndex;
                        }
                        if (name === 'response') screenElement.scrollTop = 0;
                        if (name === 'gallery') displayGallery(); // Mettre à jour la galerie quand on l'affiche
                        if (name === 'notes') loadNote(); // Charger la note sauvegardée

                    } else {
                        screenElement.classList.remove('active-screen');
                    }
                });

                if (!foundScreen) {
                    console.error(`Screen "${screenName}" not found. Switching to home.`);
                    screenName = 'home'; // Fallback
                    screens.home.classList.add('active-screen');
                }

                // Gérer la caméra
                const needsCamera = ['vision', 'look_and_ask'].includes(screenName);
                const cameraWasActive = ['vision', 'look_and_ask'].includes(previousScreenName);

                if (needsCamera) {
                    await startVideoStream(screenName); // Démarrer ou s'assurer que c'est démarré
                } else if (cameraWasActive && !needsCamera) {
                    stopVideoStream(); // Arrêter si on quitte un écran caméra
                }

                 // Réinitialiser l'état multimodal si on quitte l'écran look_and_ask
                 if (previousScreenName === 'look_and_ask' && screenName !== 'look_and_ask') {
                     resetLookAskState();
                 }
            }

            /**
             * Affiche un message d'erreur.
             * @param {string} message - Le message d'erreur.
             */
            function showErrorScreen(message) {
                console.error("Displaying error:", message);
                if (errorMessageElement && screens.error) {
                    errorMessageElement.textContent = message;
                    switchScreen('error');
                } else {
                    console.error("Error screen elements not found. Fallback display.");
                     switchScreen('response');
                     queryTextElement.textContent = "Erreur";
                     responseTextElement.innerHTML = `<p class="error-message">${message}</p>`;
                }
                lastInteractionTime = Date.now();
            }

            /**
             * Met à jour le statut des permissions.
             * @param {string} message - Le message.
             * @param {boolean} [isError=false] - Si c'est une erreur.
             */
            function updatePermissionStatus(message, isError = false) {
                if (permissionStatusElement) {
                    permissionStatusElement.textContent = message;
                    permissionStatusElement.classList.toggle('error', isError);
                    console.log(`Permission status updated: "${message}" (isError: ${isError})`);
                }
            }

            // --- Initialisation Speech Recognition (inchangée globalement) ---
            async function initializeSpeechRecognition() {
                // ... (Code précédent pour vérifier compatibilité, contexte sécurisé, demander permissions) ...
                // Garder le code existant ici, il est déjà fonctionnel pour mic/caméra
                 console.log("Initializing Speech Recognition and requesting permissions...");
                updatePermissionStatus("Initialisation...");

                const SpeechRecognitionAPI = window.SpeechRecognition || window.webkitSpeechRecognition;
                if (!SpeechRecognitionAPI) {
                    updatePermissionStatus("Reconnaissance vocale non supportée.", true);
                    return false;
                }
                if (window.location.protocol !== 'https:' && !['localhost', '127.0.0.1'].includes(window.location.hostname)) {
                    updatePermissionStatus("Connexion non sécurisée (HTTPS requis).", true);
                    return false;
                }
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    updatePermissionStatus("Accès aux périphériques média impossible.", true);
                    return false;
                }

                try {
                    updatePermissionStatus("Demande des permissions...");
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
                    permissionGranted = true;
                    updatePermissionStatus("Microphone et caméra prêts.");
                    stream.getTracks().forEach(track => track.stop());

                    // Suivi des changements de permission (optionnel mais bon)
                    if (navigator.permissions?.query) {
                        navigator.permissions.query({ name: 'microphone' }).then(status => {
                            status.onchange = () => {
                                permissionGranted = status.state === 'granted';
                                updatePermissionStatus(permissionGranted ? "Microphone prêt." : "Accès microphone refusé.", !permissionGranted);
                                pttButton.disabled = !permissionGranted;
                                if (!permissionGranted && recognitionActive) recognition?.abort();
                            };
                        });
                         navigator.permissions.query({ name: 'camera' }).then(status => {
                            status.onchange = () => {
                                // Gérer si la permission caméra est révoquée en cours d'utilisation
                                console.log("Camera permission state changed:", status.state);
                                if (status.state !== 'granted') stopVideoStream();
                            };
                        });
                    }

                } catch (err) {
                    permissionGranted = false;
                    let userMessage = "Impossible d'accéder aux périphériques.";
                    if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                        userMessage = "Accès microphone/caméra refusé.";
                    } else if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') {
                         userMessage = "Aucun microphone/caméra trouvé.";
                    } // ... autres cas d'erreur ...
                    updatePermissionStatus(userMessage, true);
                    return false;
                }

                // Initialisation de l'instance SpeechRecognition
                try {
                    recognition = new SpeechRecognitionAPI();
                    recognition.lang = 'fr-FR';
                    recognition.continuous = true;
                    recognition.interimResults = false;
                    speechApiAvailable = true;
                    if (pttButton) pttButton.disabled = false;

                    let currentTranscript = '';
                    recognition.onstart = () => {
                        console.log("SpeechRecognition: onstart");
                        recognitionActive = true;
                        currentTranscript = '';
                        pttButton?.classList.add('active');
                         // Ne change d'écran que si on n'est pas déjà sur un écran spécial (look&ask)
                        const currentScreen = document.querySelector('.screen.active-screen')?.dataset.screenName;
                        if (currentScreen !== 'look_and_ask') {
                            switchScreen('listening');
                        } else {
                             lookStatusText.textContent = "Écoute en cours..."; // Mettre à jour le statut sur l'écran multimodal
                        }
                    };
                    recognition.onresult = (event) => {
                        let segment = '';
                        for (let i = event.resultIndex; i < event.results.length; ++i) {
                            if (event.results[i].isFinal) {
                                segment += event.results[i][0].transcript + ' ';
                            }
                        }
                        if (segment) currentTranscript += segment;
                        console.log("Transcript final accumulé:", currentTranscript.trim());
                    };
                    recognition.onerror = (event) => {
                        console.error(`SpeechRecognition: onerror - ${event.error}`, event.message);
                        recognitionActive = false;
                        pttButton?.classList.remove('active');
                        let userMessage = `Erreur reconnaissance: ${event.error}`;
                        // ... (gestion détaillée des erreurs comme avant) ...
                         if (event.error === 'not-allowed') {
                             permissionGranted = false;
                             updatePermissionStatus("Accès microphone refusé.", true);
                             pttButton.disabled = true;
                             userMessage = "Accès microphone refusé.";
                         } else if (event.error === 'no-speech') {
                              userMessage = "Je n'ai rien entendu.";
                         }

                        if (speechPromiseCallbacks?.reject && event.error !== 'aborted') {
                            speechPromiseCallbacks.reject(new Error(userMessage));
                        } else if (event.error !== 'aborted') {
                            // Afficher l'erreur si elle n'est pas liée à une promesse en cours ou à un arrêt normal
                            const currentScreen = document.querySelector('.screen.active-screen')?.dataset.screenName;
                            if (currentScreen === 'look_and_ask') {
                                lookStatusText.textContent = userMessage; // Afficher sur l'écran multimodal
                                setTimeout(resetLookAskState, 3000); // Réinitialiser après un délai
                            } else {
                                showErrorScreen(userMessage);
                            }
                        }
                        speechPromiseCallbacks = null;
                        isListening = false;
                    };
                    recognition.onend = () => {
                        console.log("SpeechRecognition: onend");
                        recognitionActive = false;
                        pttButton?.classList.remove('active');
                        if (speechPromiseCallbacks?.resolve) {
                            speechPromiseCallbacks.resolve(currentTranscript.trim());
                        }
                        speechPromiseCallbacks = null;
                        // isListening est géré dans handlePttEnd ou onerror
                        // Réinitialiser le statut sur l'écran multimodal si on était dessus
                        const currentScreen = document.querySelector('.screen.active-screen')?.dataset.screenName;
                        if (currentScreen === 'look_and_ask' && lookStatusText.textContent === "Écoute en cours...") {
                             lookStatusText.textContent = "Traitement...";
                        }
                    };
                } catch (error) {
                    console.error("Erreur init SpeechRecognition instance:", error);
                    updatePermissionStatus("Erreur init reconnaissance.", true);
                    return false;
                }

                return true; // Initialisation réussie
            }

            // --- Démarrage Speech Recognition (inchangé globalement) ---
            async function startSpeechRecognition() {
                return new Promise(async (resolve, reject) => {
                    if (!speechApiAvailable || !recognition) return reject(new Error("Reco. non initialisée."));
                    if (recognitionActive) return reject(new Error("Écoute déjà en cours."));
                    if (permissionGranted === false) return reject(new Error("Accès microphone refusé."));

                    // Re-vérification rapide de la permission
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                        stream.getTracks().forEach(track => track.stop());
                        permissionGranted = true; // Confirmer
                         if (pttButton) pttButton.disabled = false;
                    } catch (err) {
                        permissionGranted = false;
                        updatePermissionStatus("Accès microphone refusé.", true);
                         if (pttButton) pttButton.disabled = true;
                        return reject(new Error("Accès microphone refusé."));
                    }

                    console.log("Tentative de démarrage de l'écoute...");
                    speechPromiseCallbacks = { resolve, reject };
                    try {
                        recognition.start();
                    } catch (e) {
                        console.error("Erreur immédiate à recognition.start():", e);
                        recognitionActive = false;
                        speechPromiseCallbacks = null;
                        reject(new Error(`Erreur démarrage reco: ${e.message || e.name}`));
                    }
                });
            }

            // --- Gestion PTT (MODIFIED for Multimodal Context) ---
            function handlePttStart(event) {
                event.preventDefault();
                console.log("PTT Start");

                if (!speechApiAvailable || permissionGranted === false) { /* ... gestion erreur ... */ return; }
                if (isListening || recognitionActive) { /* ... déjà en écoute ... */ return; }

                 // --- NOUVEAU: Vérification pour le mode multimodal ---
                 const currentScreen = document.querySelector('.screen.active-screen')?.dataset.screenName;
                 isMultimodalPrompt = (currentScreen === 'look_and_ask' && !!capturedImageDataForPrompt);
                 if (currentScreen === 'look_and_ask' && !capturedImageDataForPrompt) {
                     console.warn("PTT sur écran Look&Ask mais pas d'image capturée.");
                     lookStatusText.textContent = "Veuillez d'abord capturer une image.";
                     return; // Ne pas démarrer l'écoute si pas d'image
                 }
                 // --- Fin Vérification Multimodal ---


                isListening = true;
                pttButton?.classList.add('active');
                pttButton?.setAttribute('aria-pressed', 'true');

                startSpeechRecognition()
                    .then(result => {
                        console.log("Promesse résolue par onend.");
                        processSpeechResult(result); // Traitement normal ou multimodal selon le flag
                    })
                    .catch(error => {
                        console.error("Promesse rejetée:", error);
                        // Afficher l'erreur si nécessaire (déjà géré en partie dans onerror)
                        if (!error.message.includes("reconnaissance") && !error.message.includes("microphone")) {
                             if (isMultimodalPrompt) {
                                 lookStatusText.textContent = `Erreur: ${error.message}`;
                                 setTimeout(resetLookAskState, 3000);
                             } else {
                                 showErrorScreen(error.message);
                             }
                        }
                        isListening = false; // Assurer la réinitialisation
                        pttButton?.classList.remove('active');
                        pttButton?.setAttribute('aria-pressed', 'false');
                        isMultimodalPrompt = false; // Réinitialiser le flag
                    });
            }

            function handlePttEnd(event) { // Globalement inchangé
                event.preventDefault();
                console.log("PTT End");
                if (!isListening) return;
                isListening = false;
                pttButton?.classList.remove('active');
                pttButton?.setAttribute('aria-pressed', 'false');

                if (recognitionActive && recognition) {
                    console.log("Arrêt de la reconnaissance via recognition.stop()...");
                    try {
                        recognition.stop();
                    } catch (e) {
                        console.error("Erreur à recognition.stop():", e);
                        if (speechPromiseCallbacks?.reject) {
                            speechPromiseCallbacks.reject(new Error("Échec arrêt reco."));
                        }
                        if (isMultimodalPrompt) {
                             lookStatusText.textContent = "Erreur lors de l'arrêt.";
                             setTimeout(resetLookAskState, 3000);
                        } else {
                             showErrorScreen("Erreur lors de l'arrêt de l'écoute.");
                        }
                        speechPromiseCallbacks = null;
                        isMultimodalPrompt = false; // Réinitialiser
                    }
                } else {
                    console.warn("PTT End: Recognition non active.");
                     if (speechPromiseCallbacks?.reject) {
                         speechPromiseCallbacks.reject(new Error("Écoute terminée prématurément."));
                     }
                     speechPromiseCallbacks = null;
                     isMultimodalPrompt = false; // Réinitialiser
                }
            }

            /**
             * Traite le résultat vocal, appelle Gemini (normal ou multimodal).
             * @param {string | Error} result - Texte reconnu ou erreur.
             */
            async function processSpeechResult(result) {
                console.log("Traitement du résultat final:", result);
                lastInteractionTime = Date.now(); // Mettre à jour le timer de contexte

                // Déterminer l'écran de destination (réponse normale ou rester sur look&ask)
                const destinationScreen = isMultimodalPrompt ? 'look_and_ask' : 'response';
                if (!isMultimodalPrompt) {
                     switchScreen('response'); // Aller à l'écran réponse standard
                } else {
                     lookStatusText.textContent = "Traitement..."; // Mettre à jour statut sur look&ask
                }

                if (result instanceof Error) {
                    queryTextElement.textContent = "Erreur de reconnaissance";
                    responseTextElement.innerHTML = `<p class="error-message">${result.message}</p>`;
                     if (isMultimodalPrompt) {
                         lookStatusText.textContent = `Erreur: ${result.message}`;
                         setTimeout(resetLookAskState, 3000);
                     }
                } else if (typeof result === 'string') {
                    const query = result.trim();
                    // Afficher la requête sur l'écran réponse standard, même si on traite en multimodal
                    queryTextElement.textContent = query || "[Aucun texte reconnu]";

                    if (!query) {
                        const noUnderstandMsg = "<p>Je n'ai pas compris ou rien entendu. Veuillez réessayer.</p>";
                        responseTextElement.innerHTML = noUnderstandMsg;
                         if (isMultimodalPrompt) {
                             lookStatusText.textContent = "Rien entendu. Réessayez.";
                             // Ne pas réinitialiser l'image, permettre de réessayer le PTT
                         }
                    } else {
                        // Appel API (normal ou multimodal)
                        if (GEMINI_API_KEY && GEMINI_API_KEY !== 'YOUR_API_KEY') {
                            if (!isMultimodalPrompt) {
                                responseTextElement.innerHTML = "<p><i>Réflexion en cours...</i></p>";
                            } // Sur look&ask, le statut est déjà mis à jour
                            try {
                                let answer;
                                if (isMultimodalPrompt && capturedImageDataForPrompt) {
                                    console.log("Calling Gemini with Image and Text");
                                    answer = await queryGeminiWithImage(query, capturedImageDataForPrompt);
                                    // Afficher la réponse sur l'écran réponse standard *après* traitement multimodal
                                    switchScreen('response');
                                } else {
                                    console.log("Calling Gemini with Text only");
                                    answer = await queryGemini(query);
                                }
                                processApiResponse(answer); // Traite la réponse (fonction/texte) et affiche
                            } catch (geminiError) {
                                console.error("Erreur appel Gemini:", geminiError);
                                const errorHtml = `<p class="error-message">Erreur IA : ${geminiError.message}</p>`;
                                responseTextElement.innerHTML = errorHtml;
                                if (isMultimodalPrompt) {
                                     lookStatusText.textContent = `Erreur IA: ${geminiError.message}`;
                                     setTimeout(resetLookAskState, 3000);
                                }
                                // Assurer l'affichage sur l'écran réponse si l'erreur vient du multimodal
                                if (isMultimodalPrompt) switchScreen('response');
                            } finally {
                                // Nettoyer l'état multimodal APRES l'appel API
                                if (isMultimodalPrompt) {
                                    resetLookAskState();
                                }
                            }
                        } else {
                             // Pas de clé API
                             const noApiKeyMsg = "<p><i>(Fonctionnalité IA non configurée)</i></p>";
                             responseTextElement.innerHTML = noApiKeyMsg;
                             addToHistory('user', query);
                             addToHistory('model', "(Fonctionnalité IA non configurée)");
                             if (isMultimodalPrompt) {
                                 lookStatusText.textContent = "Fonctionnalité IA non configurée.";
                                 setTimeout(resetLookAskState, 3000);
                                 switchScreen('response'); // Afficher le message sur l'écran réponse
                             }
                        }
                    }
                } else {
                     // Résultat inattendu
                     const unexpectedMsg = '<p class="error-message">Problème inattendu (traitement voix).</p>';
                     queryTextElement.textContent = "Erreur Inattendue";
                     responseTextElement.innerHTML = unexpectedMsg;
                      if (isMultimodalPrompt) {
                          lookStatusText.textContent = "Erreur inattendue.";
                          setTimeout(resetLookAskState, 3000);
                          switchScreen('response');
                      }
                }
                // Réinitialiser le flag au cas où il serait resté actif par erreur
                 isMultimodalPrompt = false;
            }


            // --- Fonctions Contexte & Appel de Fonction ---

            function addToHistory(role, text) {
                conversationHistory.push({ role, parts: [{ text }] });
                console.log("Added to history:", { role, text: text.substring(0, 50) + '...' });
            }

            function checkContextTimeout() {
                const now = Date.now();
                if (now - lastInteractionTime > CONTEXT_TIMEOUT) {
                    console.log("Context timeout. Clearing conversation history.");
                    conversationHistory = [];
                }
                lastInteractionTime = now;
            }

             /**
             * Exécute une fonction locale basée sur le nom fourni.
             * @param {string} functionName - Le nom de la fonction à exécuter.
             */
             function executeFunction(functionName) {
                console.log(`Executing function: ${functionName}`);
                try {
                    switch (functionName) {
                        // Fonctions existantes
                        case 'start_timer':
                            if (timerStartButton && !isTimerRunning) timerStartButton.click();
                            break;
                        case 'reset_timer':
                            timerResetButton?.click();
                            break;
                        case 'play_pause_music':
                            playPauseButton?.click();
                            break;
                        case 'prev_track':
                            prevTrackButton?.click();
                            console.log("Simulating previous track");
                            break;
                        case 'next_track':
                            nextTrackButton?.click();
                            console.log("Simulating next track");
                            break;
                        case 'capture_image': // Capture simple depuis écran Vision
                             if (document.querySelector('.screen.active-screen')?.dataset.screenName === 'vision') {
                                 visionCaptureButton?.click(); // Déclenche la capture sur l'écran vision
                             } else {
                                 console.warn("Capture_image appelée hors de l'écran vision.");
                                 // Optionnel: forcer l'affichage de l'écran vision d'abord?
                                 // switchScreen('vision');
                             }
                            break;
                        case 'go_home': switchScreen('home'); break;
                        case 'show_alarms': switchScreen('alarms'); break;
                        case 'show_timer': switchScreen('timer'); break;
                        case 'show_music': switchScreen('music'); break;
                        case 'show_vision': switchScreen('vision'); break;
                        // Nouvelles fonctions
                        case 'show_calendar': switchScreen('calendar'); break;
                        case 'show_notes': switchScreen('notes'); break;
                        case 'save_current_note': saveNote(); break; // Appelle la fonction de sauvegarde
                        case 'show_gallery': switchScreen('gallery'); break;
                        case 'look_and_ask': switchScreen('look_and_ask'); break; // Affiche l'écran multimodal

                        default:
                            console.warn(`Function "${functionName}" not recognized.`);
                    }
                } catch (error) {
                    console.error(`Error executing function "${functionName}":`, error);
                }
            }

            /**
             * Traite la réponse de l'API Gemini, recherche les appels de fonction et affiche le résultat.
             * @param {string} apiResponseText - Le texte brut reçu de l'API Gemini.
             */
            function processApiResponse(apiResponseText) {
                const functionCallRegex = /^\s*%\s*([a-zA-Z0-9_]+)\s*%([\s\S]*)/;
                const match = apiResponseText.match(functionCallRegex);

                let displayText = apiResponseText;

                if (match) {
                    const functionName = match[1].trim();
                    const remainingText = match[2].trim();
                    console.log(`Function call detected: ${functionName}`);
                    executeFunction(functionName); // Exécuter la fonction
                    displayText = remainingText || `(Action ${functionName} exécutée)`;
                }

                // Afficher la partie textuelle de la réponse (sur l'écran 'response')
                displayMarkdownResponse(displayText, responseTextElement);

                // Ajouter la réponse BRUTE du modèle à l'historique pour le contexte
                addToHistory('model', apiResponseText);
            }


            // --- Fonctions Utilitaires (Minuteur, Musique, Capture, Gemini, Markdown) ---

            // Minuteur (inchangé)
            function formatTime(seconds) { /* ... */ return `${Math.floor(seconds / 60).toString().padStart(2, '0')}:${(seconds % 60).toString().padStart(2, '0')}`; }
            timerStartButton?.addEventListener('click', () => { /* ... */ });
            timerResetButton?.addEventListener('click', () => { /* ... */ });

            // Musique (inchangé - simulation)
            playPauseButton?.addEventListener('click', () => { /* ... */ });
            prevTrackButton?.addEventListener('click', () => console.log("Piste précédente (simulation)"));
            nextTrackButton?.addEventListener('click', () => console.log("Piste suivante (simulation)"));

            // --- Gestion Caméra (Revu pour partage) ---

            /**
             * Démarre le flux vidéo et l'affiche dans le conteneur approprié.
             * @param {string} targetScreenName - Nom de l'écran ('vision' ou 'look_and_ask').
             */
            async function startVideoStream(targetScreenName) {
                if (videoStream) {
                    console.log("Video stream already potentially active, ensuring display.");
                     // S'assurer que l'élément vidéo est visible et attaché au bon conteneur
                     attachVideoToScreen(targetScreenName);
                    return true;
                }
                if (permissionGranted === false) {
                    console.warn("Cannot start video stream: camera permission denied.");
                    showErrorScreen("L'accès à la caméra a été refusé.");
                    return false;
                }

                try {
                    console.log(`Attempting to start video stream for ${targetScreenName}...`);
                    videoStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } }); // Préférer caméra arrière
                    videoElement.srcObject = videoStream;
                    videoElement.play();
                    await new Promise((resolve, reject) => {
                        videoElement.onloadedmetadata = resolve;
                        videoElement.onerror = reject;
                    });
                    console.log("Video stream started successfully.");
                    attachVideoToScreen(targetScreenName); // Attacher au bon conteneur
                    return true;
                } catch (err) {
                    console.error("Error starting video stream:", err);
                    // ... (gestion des erreurs comme avant) ...
                    let userMessage = "Impossible de démarrer le flux vidéo.";
                     if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') userMessage = "Accès caméra refusé.";
                     else if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') userMessage = "Aucune caméra trouvée.";
                     else if (err.name === 'NotReadableError' || err.name === 'OverconstrainedError') userMessage = "Caméra déjà utilisée ou problème.";
                     else userMessage = `Erreur caméra: ${err.message || err.name}`;
                    showErrorScreen(userMessage);
                    videoStream = null;
                    return false;
                }
            }

            /** Attache l'élément vidéo au conteneur du bon écran */
            function attachVideoToScreen(screenName) {
                 videoElement.style.display = 'block'; // Rendre visible
                 videoElement.classList.add('live-video'); // Appliquer style
                 if (screenName === 'vision' && visionCameraPlaceholder) {
                     visionCameraPlaceholder.appendChild(videoElement);
                     visionCameraPlaceholder.querySelector('i')?.style.setProperty('display', 'none'); // Cacher icône
                 } else if (screenName === 'look_and_ask' && lookCameraContainer) {
                     lookCameraContainer.appendChild(videoElement);
                     lookCameraContainer.querySelector('i')?.style.setProperty('display', 'none'); // Cacher icône
                 } else {
                      videoElement.style.display = 'none'; // Cacher si pas sur un écran caméra
                 }
            }

            /** Arrête proprement le flux vidéo */
            function stopVideoStream() {
                if (videoStream) {
                    console.log("Stopping video stream.");
                    videoStream.getTracks().forEach(track => track.stop());
                    videoStream = null;
                    videoElement.srcObject = null;
                    videoElement.remove(); // Détacher du DOM
                    videoElement.style.display = 'none';
                    // Réafficher les icônes placeholder
                    visionCameraPlaceholder?.querySelector('i')?.style.removeProperty('display');
                    lookCameraContainer?.querySelector('i')?.style.removeProperty('display');
                }
            }

            /** Capture une image depuis la vidéo live */
            function captureImageFromVideo() {
                 if (!videoStream || !videoElement.videoWidth || !videoElement.videoHeight) {
                     console.error("Cannot capture: video stream not ready or dimensions invalid.");
                     showErrorScreen("Impossible de capturer l'image (flux vidéo non prêt).");
                     return null;
                 }
                 canvasElement.width = videoElement.videoWidth;
                 canvasElement.height = videoElement.videoHeight;
                 try {
                    context.drawImage(videoElement, 0, 0, canvasElement.width, canvasElement.height);
                    const imageDataUrl = canvasElement.toDataURL('image/png');
                    console.log('Image captured:', imageDataUrl.substring(0, 50) + '...');
                    return imageDataUrl;
                 } catch (e) {
                     console.error("Error capturing or converting image:", e);
                     showErrorScreen("Erreur lors de la capture de l'image.");
                     return null;
                 }
            }

            // --- Gestion Capture Simple (Écran Vision) ---
            visionCaptureButton?.addEventListener('click', () => {
                console.log('Vision Capture button clicked.');
                const imageDataUrl = captureImageFromVideo();
                if (imageDataUrl) {
                    // Ajouter à la galerie
                    capturedPhotos.push(imageDataUrl);
                    console.log(`Photo added to gallery. Total: ${capturedPhotos.length}`);
                    // Afficher confirmation (optionnel)
                    switchScreen('response'); // Aller à l'écran réponse pour confirmation
                    queryTextElement.textContent = "Vision";
                    responseTextElement.innerHTML = "<p>Photo capturée et ajoutée à la galerie.</p>";
                    // Optionnel: Aller directement à la galerie ?
                    // switchScreen('gallery');
                }
            });

            // --- Gestion Galerie Photos ---
            function displayGallery() {
                if (!galleryContainer || !galleryEmptyMsg) return;
                galleryContainer.innerHTML = ''; // Vider la galerie actuelle
                if (capturedPhotos.length === 0) {
                    galleryEmptyMsg.style.display = 'block';
                } else {
                    galleryEmptyMsg.style.display = 'none';
                    capturedPhotos.forEach((dataUrl, index) => {
                        const item = document.createElement('div');
                        item.className = 'gallery-item';

                        const img = document.createElement('img');
                        img.src = dataUrl;
                        img.alt = `Photo capturée ${index + 1}`;

                        const downloadLink = document.createElement('a');
                        downloadLink.href = dataUrl;
                        downloadLink.download = `rabbit_capture_${index + 1}.png`;
                        downloadLink.className = 'download-link';
                        downloadLink.innerHTML = '<i class="fas fa-download"></i>';
                        downloadLink.setAttribute('aria-label', 'Télécharger l\'image');
                        downloadLink.title = 'Télécharger l\'image'; // Tooltip

                        item.appendChild(img);
                        item.appendChild(downloadLink);
                        galleryContainer.appendChild(item);
                    });
                }
            }

             // --- Gestion Notes ---
             function saveNote() {
                 if (notesTextarea) {
                     const noteContent = notesTextarea.value;
                     try {
                         localStorage.setItem('rabbit_note', noteContent);
                         console.log("Note saved to localStorage.");
                         if(notesFeedback) {
                             notesFeedback.textContent = "Note enregistrée !";
                             setTimeout(() => { notesFeedback.textContent = ""; }, 2000); // Message temporaire
                         }
                     } catch (e) {
                         console.error("Error saving note to localStorage:", e);
                          if(notesFeedback) notesFeedback.textContent = "Erreur sauvegarde.";
                     }
                 }
             }

             function loadNote() {
                  if (notesTextarea) {
                     try {
                         const savedNote = localStorage.getItem('rabbit_note');
                         if (savedNote !== null) {
                             notesTextarea.value = savedNote;
                             console.log("Note loaded from localStorage.");
                         }
                     } catch (e) {
                          console.error("Error loading note from localStorage:", e);
                     }
                 }
             }
             saveNoteButton?.addEventListener('click', saveNote); // Sauvegarde manuelle

             // --- Gestion Look & Ask (Multimodal) ---
             function resetLookAskState() {
                 console.log("Resetting Look & Ask state.");
                 capturedImageDataForPrompt = null;
                 isMultimodalPrompt = false;
                 lookStatusText.textContent = "Visez, puis capturez l'image.";
                 lookCaptureButton.disabled = false; // Réactiver le bouton capture
                 // Supprimer l'aperçu de l'image s'il existe
                 const preview = lookCameraContainer?.querySelector('.captured-image-preview');
                 if (preview) preview.remove();
                 // S'assurer que la vidéo est visible si le stream est actif
                 if (videoStream && videoElement.parentElement === lookCameraContainer) {
                     videoElement.style.display = 'block';
                 } else if (videoStream) {
                     // Si le stream est actif mais pas attaché ici, tenter de l'attacher
                     attachVideoToScreen('look_and_ask');
                 } else {
                     // Si pas de stream, réafficher l'icône
                      lookCameraContainer?.querySelector('i')?.style.removeProperty('display');
                 }
             }

             lookCaptureButton?.addEventListener('click', () => {
                 console.log('Look & Ask Capture button clicked.');
                 const imageDataUrl = captureImageFromVideo();
                 if (imageDataUrl) {
                     capturedImageDataForPrompt = imageDataUrl; // Stocker pour l'envoi
                     lookStatusText.textContent = "Image capturée. Parlez maintenant pour poser votre question.";
                     lookCaptureButton.disabled = true; // Désactiver après capture

                     // Afficher l'aperçu
                     const previewImg = document.createElement('img');
                     previewImg.src = imageDataUrl;
                     previewImg.className = 'captured-image-preview';
                     lookCameraContainer.appendChild(previewImg);
                     videoElement.style.display = 'none'; // Cacher la vidéo live derrière l'aperçu

                     // Optionnel: Ajouter aussi à la galerie principale ?
                     // capturedPhotos.push(imageDataUrl);
                 } else {
                      lookStatusText.textContent = "Échec de la capture. Réessayez.";
                 }
             });


            // --- Appel API Gemini Multimodal ---
            async function queryGeminiWithImage(prompt, base64ImageData) {
                console.log("Querying Gemini with Image and Text:", prompt);
                checkContextTimeout(); // Gérer le timeout du contexte

                // Enlever le préfixe 'data:image/png;base64,'
                const pureBase64 = base64ImageData.split(',')[1];

                // Construire l'historique + nouvelle requête multimodale
                // Ajouter la requête TEXTE à l'historique d'abord
                 addToHistory('user', prompt); // On ajoute seulement le texte pour le contexte simple

                const requestContents = [
                    { role: 'user', parts: [{ text: SYSTEM_INSTRUCTION }] },
                    ...conversationHistory.slice(0, -1), // Historique SANS la dernière requête utilisateur texte
                    // Ajouter la requête multimodale comme dernier élément 'user'
                    { role: 'user', parts: [
                        { text: prompt }, // Le prompt textuel
                        { inline_data: { mime_type: 'image/png', data: pureBase64 } } // L'image
                    ]}
                ];

                // Mettre à jour le statut sur l'écran réponse standard pendant l'appel
                 responseTextElement.innerHTML = "<p><i>Analyse de l'image et réflexion en cours...</i></p>";

                try {
                    const response = await fetch(GEMINI_API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ contents: requestContents, safetySettings: [ /* ... */ ] })
                    });
                    const data = await response.json();

                    if (!response.ok) { /* ... gestion erreur API ... */
                        console.error('Erreur API Gemini (Multimodal):', response.status, data);
                        const errorMessage = data?.error?.message || `Erreur HTTP ${response.status}`;
                        const fullErrorMsg = `Erreur IA (image) : ${errorMessage}`;
                        addToHistory('model', `Erreur: ${fullErrorMsg}`);
                        throw new Error(fullErrorMsg);
                    }

                    console.log("Réponse Gemini (Multimodal) brute:", data);
                    // ... (gestion réponse bloquée/vide/anormale comme dans queryGemini) ...
                     let responseText = "Désolé, je n'ai pas pu analyser l'image."; // Défaut
                     if (data.candidates && data.candidates.length > 0) {
                          const candidate = data.candidates[0];
                          if (candidate.finishReason && candidate.finishReason !== 'STOP' && candidate.finishReason !== 'MAX_TOKENS') {
                                const reason = candidate.finishReason.replace(/_/g, ' ').toLowerCase();
                                responseText = (candidate.content?.parts?.[0]?.text || "") + `\n\n_(Analyse interrompue: ${reason}.)_`;
                          } else {
                                responseText = candidate.content?.parts?.[0]?.text || "Je n'ai pas de commentaire sur cette image.";
                          }
                     } else if (data.promptFeedback?.blockReason) {
                          const reason = data.promptFeedback.blockReason.replace(/_/g, ' ').toLowerCase();
                          responseText = `Analyse bloquée pour raison de sécurité (${reason}).`;
                     }

                    // La réponse est ajoutée à l'historique par processApiResponse
                    return responseText;

                } catch (error) {
                    console.error('Erreur requête Gemini (Multimodal):', error);
                     if (!error.message.includes("Erreur IA")) {
                         addToHistory('model', `Erreur réseau/fetch (image): ${error.message}`);
                     }
                    throw error; // Relancer
                }
            }


            // --- Conversion Markdown (inchangée) ---
            function markdownToHtml(markdown) { /* ... code existant ... */
                 if (typeof markdown !== 'string') return '';
                let html = markdown;
                html = html.replace(/```([\s\S]*?)```/gs, (match, code) => `<pre><code>${code.trim().replace(/</g, '&lt;').replace(/>/g, '&gt;')}</code></pre>`);
                html = html.replace(/^### (.*$)/gm, '<h3>$1</h3>');
                html = html.replace(/^## (.*$)/gm, '<h2>$1</h2>');
                html = html.replace(/^# (.*$)/gm, '<h1>$1</h1>');
                html = html.replace(/^(?:-{3,}|_{3,}|\*{3,})$/gm, '<hr>');
                html = html.replace(/^(?:> (?:.*\n?))+/gm, (match) => `<blockquote>${markdownToHtmlSimpleInline(match.replace(/^> /gm, '').trim())}</blockquote>`);
                html = html.replace(/^([*+-]) (.*(?:\n(?!\1 | {2,}).*)*)/gm, (match, marker, itemContent) => `<ul><li>${markdownToHtmlSimpleInline(itemContent.trim())}</li></ul>`);
                html = html.replace(/^(\d+)\. (.*(?:\n(?!\d+\. | {2,}).*)*)/gm, (match, num, itemContent) => `<ol start="${num}"><li>${markdownToHtmlSimpleInline(itemContent.trim())}</li></ol>`);
                html = html.replace(/<\/ul>\s*<ul>/g, '');
                html = html.replace(/<\/ol>\s*<ol(?: start="\d+")?>/g, '');
                html = html.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, '<img src="$2" alt="$1">');
                html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
                html = markdownToHtmlSimpleInline(html);
                 html = html.split('\n').map(line => {
                     line = line.trim();
                     if (line.length === 0) return '';
                     if (!line.match(/^<\/?(h[1-6]|ul|ol|li|blockquote|hr|pre|img|table|thead|tbody|tr|th|td|strong|em|code|a|br)/i)) {
                         return `<p>${line}</p>`;
                     }
                     return line;
                 }).join('\n');
                 html = html.replace(/<p>\s*<\/p>/g, '');
                 html = html.replace(/<\/blockquote>\s*<blockquote>/g, '');
                 html = html.replace(/\n/g, '');
                return html;
             }
            function markdownToHtmlSimpleInline(text) { /* ... code existant ... */
                text = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                text = text.replace(/__(.*?)__/g, '<strong>$1</strong>');
                text = text.replace(/\*(.*?)\*/g, '<em>$1</em>');
                text = text.replace(/_(.*?)_/g, '<em>$1</em>');
                text = text.replace(/`([^`]+)`/g, '<code>$1</code>');
                return text;
            }

            // --- Affichage Markdown (inchangée) ---
            function displayMarkdownResponse(markdownText, element) { /* ... code existant ... */
                 if (element) {
                    element.innerHTML = markdownToHtml(markdownText);
                    element.style.opacity = 0;
                    element.scrollTop = 0;
                    setTimeout(() => { element.style.opacity = 1; }, 50);
                } else {
                    console.error("Response display element not found.");
                }
            }


            // --- Gestion Contrôles Scroll & Back (inchangée) ---
            scrollUpButton?.addEventListener('click', () => { /* ... */ });
            scrollDownButton?.addEventListener('click', () => { /* ... */ });
            document.querySelectorAll('.back-button').forEach(button => {
                button.addEventListener('click', (event) => { /* ... */ });
            });


            // --- Initialisation App ---
            async function initializeApp() {
                console.log("Initialisation de l'application Rabbit R1...");
                switchScreen('home'); // Afficher l'accueil

                // Charger la note existante au démarrage
                loadNote();

                const speechReady = await initializeSpeechRecognition();

                if (speechReady && pttButton) {
                    // Attacher PTT listeners (souris et tactile)
                    pttButton.addEventListener('mousedown', handlePttStart);
                    pttButton.addEventListener('mouseup', handlePttEnd);
                    pttButton.addEventListener('mouseleave', (e) => { if (isListening) handlePttEnd(e); });
                    pttButton.addEventListener('touchstart', handlePttStart, { passive: false });
                    pttButton.addEventListener('touchend', handlePttEnd);
                    pttButton.addEventListener('touchcancel', (e) => { if (isListening) handlePttEnd(e); });
                    console.log("Gestionnaires PTT attachés.");
                } else {
                     console.warn("PTT non initialisé (API non prête, permission refusée, ou bouton non trouvé).");
                     if(pttButton) pttButton.disabled = true; // S'assurer qu'il est désactivé
                }
                console.log("Application initialisée et prête.");
            }

            // Démarrer l'initialisation
            initializeApp();

            // Arrêter la caméra en quittant la page
            window.addEventListener('beforeunload', stopVideoStream);

        }); // Fin du DOMContentLoaded
    </script>
</body>
</html>
