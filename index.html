<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rabbit R1 Web App</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Press+Start+2P&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        /* Global Variables */
        :root {
            --rabbit-orange: #ff7e00;
            --off-white: #f8f8f8;
            --light-gray: #e0e0e0;
            --medium-gray: #cccccc;
            --dark-gray: #333333;
            --device-gray: #d0d0d0;
            --error-red: #d9534f;
            --success-green: #5cb85c;
            --glass-bg: rgba(255, 255, 255, 0.25);
            --glass-border: rgba(255, 255, 255, 0.4);
            --glass-blur: 8px;
        }

        /* Base Styles */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Inter', sans-serif; background-color: var(--off-white); color: var(--dark-gray);
            display: flex; justify-content: center; align-items: center; min-height: 100vh; padding: 20px;
            -webkit-tap-highlight-color: transparent;
        }

        /* Device Container */
        .device-container { width: 100%; max-width: 360px; margin: 0 auto; }
        .rabbit-device {
            background-color: var(--device-gray); border-radius: 24px; padding: 16px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1); display: flex; flex-direction: column; align-items: center; gap: 16px;
        }

        /* Main Display */
        .main-display {
            background-color: var(--off-white); border-radius: 16px; width: 100%;
            aspect-ratio: 1 / 1; overflow: hidden; position: relative;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.1);
        }

        /* Screens (General) */
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center;
            padding: 20px; opacity: 0; visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease, transform 0.3s ease;
            transform: translateX(20px); overflow-y: auto; background-color: var(--off-white);
        }
        .active-screen { opacity: 1; visibility: visible; transform: translateX(0); }

        /* Back Button (Common) */
        .back-button {
            margin-top: auto; padding: 8px 16px; background-color: var(--medium-gray);
            border: none; border-radius: 4px; color: var(--dark-gray); cursor: pointer;
            transition: background-color 0.2s; font-size: 14px; display: inline-flex;
            align-items: center; gap: 5px; z-index: 10;
        }
        .back-button:hover { background-color: var(--light-gray); }
        /* Specific positioning */
        .response-screen .back-button, .error-screen .back-button, .notes-screen .back-button,
        .gallery-screen .back-button, .look-at-this-screen .back-button {
             position: absolute; bottom: 15px; left: 50%; transform: translateX(-50%);
        }
         .calendar-screen .back-button, .alarms-screen .back-button, .timer-screen .back-button,
         .music-screen .back-button, .vision-screen .back-button {
            margin-top: 20px;
         }

        /* Common Screen Title */
        .screen h2 {
            font-size: 20px; font-weight: 600; margin-bottom: 15px;
            text-align: center; width: 100%; color: var(--dark-gray); flex-shrink: 0;
        }

        /* --- Specific Screen Styles --- */

        /* Home Screen */
        .home-screen { justify-content: center; text-align: center; }
        .greeting { font-size: 24px; font-weight: 600; margin-bottom: 10px; }
        .instruction { font-size: 16px; color: #666; margin-bottom: 15px; }
        .permission-status { font-size: 12px; color: #666; margin-top: 10px; min-height: 1.2em; font-weight: 500; }
        .permission-status.error { color: var(--error-red); font-weight: 600; }

        /* Listening Screen */
        .listening-screen { justify-content: center; }
        .listening-indicator { text-align: center; }
        .listening-text { font-size: 18px; margin-bottom: 20px; animation: pulse 1.5s infinite alternate; }
        .waveform { display: flex; justify-content: center; align-items: center; gap: 5px; height: 40px; }
        .waveform span { display: inline-block; width: 5px; height: 20px; background-color: var(--rabbit-orange); border-radius: 2px; }
        .waveform span:nth-child(1) { animation: wave 0.5s infinite alternate; }
        .waveform span:nth-child(2) { animation: wave 0.5s infinite alternate 0.1s; }
        .waveform span:nth-child(3) { animation: wave 0.5s infinite alternate 0.2s; }
        .waveform span:nth-child(4) { animation: wave 0.5s infinite alternate 0.3s; }
        @keyframes wave { 0% { height: 10px; opacity: 0.7; } 100% { height: 30px; opacity: 1; } }
        @keyframes pulse { 0% { opacity: 0.6; } 100% { opacity: 1; } }

        /* Response Screen */
        .response-screen { justify-content: flex-start; align-items: flex-start; padding-bottom: 60px; }
        .query-text { font-weight: 600; margin-bottom: 16px; align-self: flex-start; width: 100%; color: #555; border-bottom: 1px solid var(--light-gray); padding-bottom: 8px; word-wrap: break-word; }
        .response-text { width: 100%; font-size: 15px; line-height: 1.6; word-wrap: break-word; padding-bottom: 30px; }
        .response-text p i { color: #666; }
        .response-text p.error-message { color: var(--error-red); font-weight: 600; }
        /* Markdown Styles */
        .response-text p { margin-bottom: 1em; }
        .response-text h1, .response-text h2, .response-text h3 { margin-top: 1.5em; margin-bottom: 0.8em; line-height: 1.3; }
        .response-text h1 { font-size: 1.6em; border-bottom: 1px solid var(--light-gray); padding-bottom: 0.3em;}
        .response-text h2 { font-size: 1.4em; }
        .response-text h3 { font-size: 1.2em; }
        .response-text ul, .response-text ol { margin-left: 25px; margin-bottom: 1em; }
        .response-text li { margin-bottom: 0.5em; }
        .response-text code { background-color: #eee; padding: 0.2em 0.4em; border-radius: 3px; font-family: monospace; font-size: 0.9em; word-wrap: break-word; }
        .response-text pre { background-color: #eee; padding: 15px; border-radius: 5px; overflow-x: auto; margin-bottom: 1em; }
        .response-text pre code { background-color: transparent; padding: 0; font-size: 0.9em; word-wrap: normal; }
        .response-text blockquote { border-left: 4px solid var(--medium-gray); padding-left: 15px; margin: 1em 0; color: #555; font-style: italic; }
        .response-text table { border-collapse: collapse; width: 100%; margin: 1.5em 0; border: 1px solid var(--dark-gray); }
        .response-text th, .response-text td { border: 1px solid var(--dark-gray); padding: 10px; text-align: left; }
        .response-text th { background-color: var(--light-gray); font-weight: 600; }
        .response-text hr { border: none; border-top: 1px solid var(--light-gray); margin: 2em 0; }
        .response-text a { color: var(--rabbit-orange); text-decoration: none; }
        .response-text a:hover { text-decoration: underline; }
        .response-text img { max-width: 100%; height: auto; border-radius: 4px; margin: 0.5em 0; }

        /* Alarms Screen */
        .alarms-screen { justify-content: flex-start; }
        .alarms-list { list-style: none; width: 100%; padding: 0; }
        .alarms-list li { padding: 12px; border-bottom: 1px solid var(--light-gray); }

        /* Timer Screen */
        .timer-screen { justify-content: flex-start; }
        .timer-display { font-family: 'Press Start 2P', cursive; font-size: 32px; margin: 20px 0; color: var(--dark-gray); }
        .timer-controls { display: flex; gap: 10px; margin-bottom: 20px;}
        .timer-btn { padding: 8px 16px; background-color: var(--medium-gray); border: none; border-radius: 4px; color: var(--dark-gray); cursor: pointer; transition: background-color 0.2s; }
        .timer-btn:hover { background-color: var(--light-gray); }

        /* Music Screen */
        .music-screen { justify-content: flex-start; }
        .album-art { width: 120px; height: 120px; background-color: var(--medium-gray); border-radius: 8px; margin-bottom: 16px; display: flex; justify-content: center; align-items: center; font-size: 40px; color: #fff; background-image: linear-gradient(45deg, #aaa, #ccc); }
        .album-art::before { content: '\f001'; font-family: 'Font Awesome 6 Free'; font-weight: 900; }
        .track-info { text-align: center; margin-bottom: 16px; }
        .track-title { font-weight: 600; margin-bottom: 4px; }
        .artist-name { font-size: 14px; color: #666; }
        .music-controls { display: flex; gap: 16px; margin-bottom: 20px;}
        .music-btn { width: 40px; height: 40px; border-radius: 50%; background-color: var(--medium-gray); border: none; display: flex; justify-content: center; align-items: center; cursor: pointer; transition: background-color 0.2s; font-size: 16px; color: var(--dark-gray); }
        .music-btn:hover { background-color: var(--light-gray); }

        /* Camera Screens Styling */
        .vision-screen, .look-at-this-screen { justify-content: flex-start; padding-bottom: 60px; }
        .camera-container {
            width: 100%; flex-grow: 1; background-color: var(--dark-gray); border-radius: 8px;
            overflow: hidden; position: relative; display: flex; justify-content: center; align-items: center;
            margin-bottom: 15px;
        }
        .camera-container i.placeholder-icon { font-size: 48px; color: var(--medium-gray); z-index: 0; }
        .live-video { display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: 1; border-radius: 8px; }
        .captured-image-preview { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: 2; border-radius: 8px; }
        .glass-overlay {
            position: absolute; left: 50%; transform: translateX(-50%); background: var(--glass-bg);
            backdrop-filter: blur(var(--glass-blur)); -webkit-backdrop-filter: blur(var(--glass-blur));
            border: 1px solid var(--glass-border); border-radius: 12px; padding: 8px 15px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1); z-index: 3; color: var(--dark-gray); text-align: center;
        }
        .vision-capture-overlay { bottom: 15px; }
        .look-capture-overlay { bottom: 55px; }
        .look-status-overlay { bottom: 15px; font-size: 14px; min-width: 200px; }
        .capture-btn, .look-capture-btn {
            padding: 8px 16px; background-color: var(--rabbit-orange); border: none; border-radius: 8px; color: white; cursor: pointer;
            transition: background-color 0.2s; font-size: 16px; font-weight: 500; display: inline-flex; align-items: center; gap: 5px;
        }
        .capture-btn:hover, .look-capture-btn:hover { background-color: #e67200; }
        .look-capture-btn:disabled { background-color: var(--medium-gray); cursor: not-allowed; }

        /* Error Screen */
        .error-screen { justify-content: flex-start; text-align: center; padding-bottom: 60px; }
        .error-screen h2 { color: var(--error-red); }
        #error-message { margin-bottom: 20px; color: var(--error-red); font-weight: 500;}

        /* Calendar Screen */
        .calendar-screen { justify-content: flex-start; }
        .calendar-placeholder { width: 100%; max-width: 300px; height: 200px; background-color: #eee; border: 1px solid var(--light-gray); display: flex; justify-content: center; align-items: center; font-style: italic; color: #999; border-radius: 8px; }

        /* Notes Screen */
        .notes-screen { justify-content: flex-start; padding-bottom: 80px; }
        .notes-controls { display: flex; gap: 10px; margin-bottom: 10px; width: 100%; justify-content: center; flex-wrap: wrap; } /* Container for buttons */
        .notes-textarea { width: 100%; height: 100px; /* Reduced height */ margin-bottom: 10px; padding: 10px; border: 1px solid var(--light-gray); border-radius: 4px; font-family: inherit; font-size: 14px; resize: vertical; }
        .save-note-btn, .show-all-notes-btn { padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.2s; }
        .save-note-btn { background-color: var(--success-green); color: white; }
        .save-note-btn:hover { background-color: #4cae4c; }
        .show-all-notes-btn { background-color: var(--medium-gray); color: var(--dark-gray); }
        .show-all-notes-btn:hover { background-color: var(--light-gray); }
        #notes-feedback { font-size: 12px; color: var(--success-green); min-height: 1em; text-align: center; margin-bottom: 10px; }
        #notes-list-container { width: 100%; flex-grow: 1; /* Take remaining space */ overflow-y: auto; border: 1px solid var(--light-gray); border-radius: 4px; padding: 10px; background-color: #fff; /* White background for list */ }
        .note-item { background-color: #f9f9f9; border: 1px solid #eee; border-radius: 4px; padding: 8px 12px; margin-bottom: 8px; display: flex; justify-content: space-between; align-items: center; }
        .note-content { font-size: 14px; white-space: pre-wrap; /* Preserve line breaks */ word-break: break-word; flex-grow: 1; margin-right: 10px; }
        .delete-note-btn { background: none; border: none; color: var(--error-red); cursor: pointer; font-size: 14px; padding: 5px; flex-shrink: 0; }
        .delete-note-btn:hover { color: #a94442; }
        #notes-list-empty { font-style: italic; color: #999; text-align: center; padding: 20px; }

        /* Gallery Screen */
        .gallery-screen { justify-content: flex-start; padding-bottom: 60px; }
        .gallery-container { display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 10px; width: 100%; margin-top: 10px; }
        .gallery-item { position: relative; }
        .gallery-item img { display: block; width: 100%; height: 80px; object-fit: cover; border-radius: 4px; border: 1px solid var(--light-gray); }
        .gallery-item .download-link { position: absolute; bottom: 5px; right: 5px; background-color: rgba(0,0,0,0.6); color: white; border-radius: 50%; width: 20px; height: 20px; display: flex; justify-content: center; align-items: center; text-decoration: none; font-size: 10px; transition: background-color 0.2s; }
        .gallery-item .download-link:hover { background-color: rgba(0,0,0,0.8); }
        #gallery-empty-msg { font-style: italic; color: #999; text-align: center; width: 100%; }

        /* Look & Ask Screen */
        /* Styles already defined under Camera Screens */

        /* Controls (Bottom) */
        .controls { display: flex; flex-direction: column; align-items: center; gap: 16px; width: 100%; }
        .ptt-button { width: 60px; height: 60px; border-radius: 50%; background-color: var(--rabbit-orange); border: none; display: flex; justify-content: center; align-items: center; cursor: pointer; color: white; font-size: 24px; box-shadow: 0 4px 8px rgba(255, 126, 0, 0.3); transition: transform 0.1s ease, background-color 0.2s, box-shadow 0.2s; user-select: none; -webkit-user-select: none; touch-action: manipulation; }
        .ptt-button:active, .ptt-button.active { transform: scale(0.95); background-color: #e67200; box-shadow: 0 2px 4px rgba(255, 126, 0, 0.3); }
        .ptt-button.active { animation: ptt-pulse 1.5s infinite ease-in-out; }
        @keyframes ptt-pulse { 0% { box-shadow: 0 2px 4px rgba(255, 126, 0, 0.3); } 50% { box-shadow: 0 4px 12px rgba(255, 126, 0, 0.5); } 100% { box-shadow: 0 2px 4px rgba(255, 126, 0, 0.3); } }
        .scroll-controls { display: flex; gap: 20px; }
        .scroll-button { width: 40px; height: 40px; border-radius: 50%; background-color: var(--medium-gray); border: none; display: flex; justify-content: center; align-items: center; cursor: pointer; color: var(--dark-gray); transition: background-color 0.2s, transform 0.1s ease; user-select: none; -webkit-user-select: none; touch-action: manipulation; }
        .scroll-button:active { background-color: var(--light-gray); transform: scale(0.95); }
        .ptt-button:disabled { background-color: var(--medium-gray); cursor: not-allowed; box-shadow: none; transform: none; animation: none; opacity: 0.7; }
        .ptt-button:disabled:active { transform: none; }

        /* Responsive */
        @media (max-width: 400px) {
            body { padding: 10px; }
            .device-container { max-width: 100%; }
            .rabbit-device { border-radius: 16px; padding: 12px; }
            .timer-display { font-size: 28px; }
            .album-art { width: 100px; height: 100px; }
            .camera-container { margin-bottom: 10px; }
            .response-text { font-size: 14px; }
            .response-text th, .response-text td { padding: 8px; }
            .gallery-container { grid-template-columns: repeat(auto-fill, minmax(70px, 1fr)); }
            .gallery-item img { height: 70px; }
            .glass-overlay { padding: 6px 12px; }
            .capture-btn, .look-capture-btn { font-size: 14px; }
            .look-status-overlay { font-size: 12px; min-width: 180px; }
            .notes-textarea { height: 80px; } /* Shorter textarea on mobile */
            .note-item { padding: 6px 10px; }
            .note-content { font-size: 13px; }
        }
    </style>
</head>
<body>
    <audio id="silent-audio" loop style="display: none;">
        <source src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=" type="audio/wav"> </audio>

    <div class="device-container">
        <div class="rabbit-device">
            <div class="main-display" id="main-display">
                <div class="screen home-screen active-screen" data-screen-name="home">
                    <div class="greeting">Bonjour Matéo</div>
                    <div class="instruction">Maintenez pour parler</div>
                    <div class="permission-status" id="permission-status">Vérification des permissions...</div>
                </div>

                <div class="screen listening-screen" data-screen-name="listening">
                    <div class="listening-indicator">
                        <div class="listening-text">Écoute en cours...</div>
                        <div class="waveform"><span></span><span></span><span></span><span></span></div>
                    </div>
                </div>

                <div class="screen response-screen" data-screen-name="response">
                    <div class="query-text" id="query-text"></div>
                    <div class="response-text" id="response-text"></div>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                <div class="screen alarms-screen" data-screen-name="alarms">
                    <h2>Alarmes</h2>
                    <ul class="alarms-list">
                        <li>7:00 - Réveil</li><li>12:30 - Déjeuner</li><li>18:00 - Sport</li>
                    </ul>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                <div class="screen timer-screen" data-screen-name="timer">
                    <h2>Minuteur</h2>
                    <div class="timer-display">00:00</div>
                    <div class="timer-controls">
                        <button class="timer-btn" id="timer-start" aria-label="Démarrer le minuteur">Démarrer</button>
                        <button class="timer-btn" id="timer-reset" aria-label="Réinitialiser le minuteur">Réinitialiser</button>
                    </div>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                <div class="screen music-screen" data-screen-name="music">
                    <h2>Musique</h2>
                    <div class="album-art" id="music-album-art" role="img" aria-label="Pochette d'album"></div>
                    <div class="track-info">
                        <div class="track-title" id="music-track-title">Aucune musique</div>
                        <div class="artist-name" id="music-artist-name">Artiste inconnu</div>
                    </div>
                    <div class="music-controls">
                        <button class="music-btn" id="prev-track" aria-label="Piste précédente"><i class="fas fa-step-backward"></i></button>
                        <button class="music-btn" id="play-pause" aria-label="Lecture"><i class="fas fa-play"></i></button>
                        <button class="music-btn" id="next-track" aria-label="Piste suivante"><i class="fas fa-step-forward"></i></button>
                    </div>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                <div class="screen vision-screen" data-screen-name="vision">
                    <h2>Vision</h2>
                    <div class="camera-container" id="vision-camera-placeholder">
                        <i class="fas fa-camera placeholder-icon"></i>
                        <div class="glass-overlay vision-capture-overlay">
                             <button class="capture-btn" id="vision-capture-btn" aria-label="Capturer l'image"><i class="fas fa-camera"></i> Capturer</button>
                        </div>
                    </div>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                <div class="screen calendar-screen" data-screen-name="calendar">
                    <h2>Calendrier</h2>
                    <div class="calendar-placeholder">Placeholder Calendrier</div>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                <div class="screen notes-screen" data-screen-name="notes">
                    <h2>Notes</h2>
                    <textarea id="notes-textarea" class="notes-textarea" placeholder="Écrivez une nouvelle note ici..."></textarea>
                    <div class="notes-controls">
                        <button id="save-note-btn" class="save-note-btn"><i class="fas fa-save"></i> Enregistrer Nouvelle</button>
                        <button id="show-all-notes-btn" class="show-all-notes-btn"><i class="fas fa-list"></i> Afficher Tout</button>
                    </div>
                    <div id="notes-feedback"></div>
                    <div id="notes-list-container">
                        </div>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                <div class="screen gallery-screen" data-screen-name="gallery">
                    <h2>Galerie Photos</h2>
                    <div id="gallery-container" class="gallery-container"></div>
                    <p id="gallery-empty-msg" style="display: none;">Aucune photo capturée pour le moment.</p>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                 <div class="screen look-at-this-screen" data-screen-name="look_and_ask">
                    <h2>Regarder & Demander</h2>
                     <div class="camera-container" id="look-camera-container">
                        <i class="fas fa-camera placeholder-icon"></i>
                        <div class="glass-overlay look-capture-overlay">
                            <button class="look-capture-btn" id="look-capture-btn" aria-label="Capturer l'image pour l'IA"><i class="fas fa-camera"></i> Capturer</button>
                        </div>
                        <div class="glass-overlay look-status-overlay" id="look-status-text">Visez, puis capturez l'image.</div>
                    </div>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                <div class="screen error-screen" data-screen-name="error">
                    <h2>Erreur</h2>
                    <p id="error-message">Une erreur s'est produite.</p>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>
            </div>

            <div class="controls">
                <button class="ptt-button" id="ptt-button" aria-label="Maintenir pour parler" aria-pressed="false" disabled><i class="fas fa-microphone"></i></button>
                <div class="scroll-controls">
                    <button class="scroll-button" id="scroll-up" aria-label="Faire défiler vers le haut"><i class="fas fa-chevron-up"></i></button>
                    <button class="scroll-button" id="scroll-down" aria-label="Faire défiler vers le bas"><i class="fas fa-chevron-down"></i></button>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Elements ---
            const mainDisplay = document.getElementById('main-display');
            const pttButton = document.getElementById('ptt-button');
            const scrollUpButton = document.getElementById('scroll-up');
            const scrollDownButton = document.getElementById('scroll-down');
            const queryTextElement = document.getElementById('query-text');
            const responseTextElement = document.getElementById('response-text');
            const permissionStatusElement = document.getElementById('permission-status');
            const errorMessageElement = document.getElementById('error-message');
            const silentAudio = document.getElementById('silent-audio'); // For Media Session

            // Dynamically get screen elements
            const screens = {};
            document.querySelectorAll('.screen').forEach(screen => {
                const screenName = screen.dataset.screenName;
                if (screenName) screens[screenName] = screen;
            });

            // --- Screen Navigation Order ---
            const screenOrder = [ 'home', 'calendar', 'notes', 'gallery', 'alarms', 'timer', 'music', 'vision' ];
            let currentScreenIndex = 0;

            // --- State Variables ---
            let isListening = false;
            let recognitionActive = false;
            let speechPromiseCallbacks = null;
            let recognition = null;
            let speechApiAvailable = false;
            let permissionGranted = null; // null, true, false
            let conversationHistory = [];
            let lastInteractionTime = Date.now();
            const CONTEXT_TIMEOUT = 60 * 1000; // 1 minute

            // Timer Elements & State
            const timerStartButton = document.getElementById('timer-start');
            const timerResetButton = document.getElementById('timer-reset');
            const timerDisplay = document.querySelector('.timer-display');
            let timerInterval = null; let timerSeconds = 0; let isTimerRunning = false;

            // Music Elements & State & Media Session
            const playPauseButton = document.getElementById('play-pause');
            const prevTrackButton = document.getElementById('prev-track');
            const nextTrackButton = document.getElementById('next-track');
            const musicTrackTitle = document.getElementById('music-track-title');
            const musicArtistName = document.getElementById('music-artist-name');
            const musicAlbumArt = document.getElementById('music-album-art'); // Keep for potential future use
            let isMusicSessionPlaying = false; // Separate state for media session

            // Vision (Simple Capture) Elements
            const visionCaptureButton = document.getElementById('vision-capture-btn');
            const visionCameraPlaceholder = document.getElementById('vision-camera-placeholder');

            // Notes Elements
            const notesTextarea = document.getElementById('notes-textarea');
            const saveNoteButton = document.getElementById('save-note-btn');
            const showAllNotesButton = document.getElementById('show-all-notes-btn'); // New button
            const notesFeedback = document.getElementById('notes-feedback');
            const notesListContainer = document.getElementById('notes-list-container'); // New container

            // Gallery Elements
            const galleryContainer = document.getElementById('gallery-container');
            const galleryEmptyMsg = document.getElementById('gallery-empty-msg');
            let capturedPhotos = []; // In-memory storage

            // Look & Ask (Multimodal) Elements & State
            const lookCameraContainer = document.getElementById('look-camera-container');
            const lookCaptureButton = document.getElementById('look-capture-btn');
            const lookStatusText = document.getElementById('look-status-text');
            let capturedImageDataForPrompt = null; let isMultimodalPrompt = false;

            // Shared Media Elements
            let videoStream = null;
            const videoElement = document.createElement('video');
            videoElement.style.display = 'none'; videoElement.setAttribute('playsinline', ''); videoElement.classList.add('live-video');
            const canvasElement = document.createElement('canvas'); const context = canvasElement.getContext('2d');

            // --- Configuration ---
            const GEMINI_API_KEY = 'AIzaSyBW5xJAUSzhJP5n5p8znA39QFDR8JqtwPY'; // REPLACE WITH YOUR ACTUAL KEY
            const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${GEMINI_API_KEY}`;

            // --- System Instruction for Gemini (Pre-prompt) ---
            // (Keep the same detailed instruction as before)
             const SYSTEM_INSTRUCTION = `Tu es un assistant vocal intégré dans une interface web simulant un appareil Rabbit R1.
            Tu peux répondre aux questions de l'utilisateur et exécuter certaines actions. Tu peux afficher du texte formaté en Markdown, y compris des listes, du gras, de l'italique, et des tableaux simples. Pour les questions simples ne nécessitant pas d'action, réponds directement en texte.
            Pour exécuter une action, commence ta réponse EXACTEMENT par "% nom_fonction %" suivi de ta réponse textuelle normale (qui peut être vide si l'action est évidente). Ne mets rien avant le %.
            N'utilise qu'une seule commande de fonction par réponse, au tout début.
            Les fonctions disponibles sont :
            - % start_timer % : Démarre ou reprend le minuteur.
            - % reset_timer % : Réinitialise le minuteur.
            - % play_pause_music % : Met en lecture ou en pause la musique (via Media Session).
            - % prev_track % : Passe à la piste précédente (via Media Session).
            - % next_track % : Passe à la piste suivante (via Media Session).
            - % capture_image % : Prend une photo simple (depuis l'écran Vision) et l'ajoute à la galerie. Doit être sur l'écran Vision pour fonctionner.
            - % go_home % : Affiche l'écran d'accueil.
            - % show_alarms % : Affiche l'écran des alarmes.
            - % show_timer % : Affiche l'écran du minuteur.
            - % show_music % : Affiche l'écran de musique.
            - % show_vision % : Affiche l'écran de vision (pour capture simple).
            - % show_calendar % : Affiche l'écran du calendrier (placeholder).
            - % show_notes % : Affiche l'écran des notes et la liste des notes sauvegardées.
            - % save_current_note % : Sauvegarde le texte actuellement présent dans la zone de notes.
            - % show_gallery % : Affiche la galerie des photos capturées.
            - % look_and_ask % : Active le mode caméra spécial pour que l'utilisateur prenne une photo et pose une question dessus. Réponds avec un texte invitant l'utilisateur, par exemple "% look_and_ask % D'accord, montre-le moi. Capture l'image puis pose ta question."

            Exemple 1: User: "lance le minuteur" -> AI: "% start_timer % Minuteur démarré."
            Exemple 2: User: "quelle heure est-il ?" -> AI: "Il est [heure actuelle]." (pas de fonction)
            Exemple 3: User: "montre la galerie" -> AI: "% show_gallery % Voici vos photos."
            Exemple 4: User: "sauvegarde cette note" -> AI: "% save_current_note % Note sauvegardée."
            Exemple 5: User: "qu'est-ce que c'est ?" -> AI: "% look_and_ask % D'accord, montre-le moi. Capture l'image puis pose ta question."
            Adapte ta réponse textuelle après la commande pour confirmer l'action ou répondre à la question.`;


            // --- Core Functions ---

            /** Switches the active screen, handling camera stream and screen-specific updates. */
            async function switchScreen(screenName) {
                console.log(`Switching to screen: ${screenName}`);
                const previousScreen = document.querySelector('.screen.active-screen');
                const previousScreenName = previousScreen?.dataset.screenName;

                let foundScreen = false;
                Object.values(screens).forEach(screen => {
                    const isTarget = screen.dataset.screenName === screenName;
                    screen.classList.toggle('active-screen', isTarget);
                    if (isTarget) foundScreen = true;
                });

                if (!foundScreen) { console.error(`Screen "${screenName}" not found. Switching to home.`); screenName = 'home'; screens.home.classList.add('active-screen'); }

                const navigableIndex = screenOrder.indexOf(screenName);
                if (navigableIndex !== -1) currentScreenIndex = navigableIndex;

                // Screen-specific actions
                if (screenName === 'response') screens.response.scrollTop = 0;
                if (screenName === 'gallery') displayGallery();
                if (screenName === 'notes') displayAllNotes(); // Display list when entering notes

                // Camera Management
                const needsCamera = ['vision', 'look_and_ask'].includes(screenName);
                const cameraWasActive = ['vision', 'look_and_ask'].includes(previousScreenName);
                if (cameraWasActive && videoElement.parentElement) { videoElement.parentElement.querySelector('.placeholder-icon')?.style.removeProperty('display'); videoElement.remove(); }
                if (needsCamera) { await startVideoStream(screenName); }
                else if (cameraWasActive) { stopVideoStream(); }

                // Reset multimodal state if leaving look_and_ask
                 if (previousScreenName === 'look_and_ask' && screenName !== 'look_and_ask') { resetLookAskState(); }
            }

            /** Displays an error message. */
            function showErrorScreen(message) { /* ... (same as before) ... */
                 console.error("Displaying error:", message);
                if (errorMessageElement && screens.error) { errorMessageElement.textContent = message; switchScreen('error'); }
                else { console.error("Error screen elements not found. Fallback display."); switchScreen('response'); queryTextElement.textContent = "Erreur"; responseTextElement.innerHTML = `<p class="error-message">${message}</p>`; }
                lastInteractionTime = Date.now();
            }

            /** Updates the permission status message. */
            function updatePermissionStatus(message, isError = false) { /* ... (same as before) ... */
                 if (permissionStatusElement) { permissionStatusElement.textContent = message; permissionStatusElement.classList.toggle('error', isError); console.log(`Permission status updated: "${message}" (isError: ${isError})`); }
            }

            // --- Speech Recognition Initialization ---
            async function initializeSpeechRecognition() { /* ... (same as before) ... */
                 console.log("Initializing Speech Recognition..."); updatePermissionStatus("Initialisation...");
                const SpeechRecognitionAPI = window.SpeechRecognition || window.webkitSpeechRecognition;
                if (!SpeechRecognitionAPI) { updatePermissionStatus("Reconnaissance vocale non supportée.", true); return false; }
                if (window.location.protocol !== 'https:' && !['localhost', '127.0.0.1'].includes(window.location.hostname)) { updatePermissionStatus("Connexion non sécurisée (HTTPS requis).", true); return false; }
                if (!navigator.mediaDevices?.getUserMedia) { updatePermissionStatus("Accès aux périphériques média impossible.", true); return false; }
                try {
                    updatePermissionStatus("Demande des permissions...");
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
                    permissionGranted = true; updatePermissionStatus("Microphone et caméra prêts.");
                    stream.getTracks().forEach(track => track.stop());
                    if (navigator.permissions?.query) { /* ... permission monitoring ... */ }
                } catch (err) { /* ... error handling ... */ return false; }
                try {
                    recognition = new SpeechRecognitionAPI(); recognition.lang = 'fr-FR'; recognition.continuous = true; recognition.interimResults = false; speechApiAvailable = true;
                    if (pttButton) pttButton.disabled = false;
                    let currentTranscript = '';
                    recognition.onstart = () => { /* ... (same as before) ... */ };
                    recognition.onresult = (event) => { /* ... (same as before) ... */ };
                    recognition.onerror = (event) => { /* ... (same as before) ... */ };
                    recognition.onend = () => { /* ... (same as before) ... */ };
                } catch (error) { console.error("Error initializing SpeechRecognition instance:", error); updatePermissionStatus("Erreur init reconnaissance.", true); return false; }
                return true;
            }

            // --- Start Speech Recognition ---
            async function startSpeechRecognition() { /* ... (same as before) ... */
                 return new Promise(async (resolve, reject) => {
                    if (!speechApiAvailable || !recognition) return reject(new Error("Reco. non initialisée."));
                    if (recognitionActive) return reject(new Error("Écoute déjà en cours."));
                    if (permissionGranted === false) return reject(new Error("Accès microphone refusé."));
                    try { const stream = await navigator.mediaDevices.getUserMedia({ audio: true }); stream.getTracks().forEach(track => track.stop()); permissionGranted = true; if (pttButton) pttButton.disabled = false; }
                    catch (err) { permissionGranted = false; updatePermissionStatus("Accès microphone refusé.", true); if (pttButton) pttButton.disabled = true; return reject(new Error("Accès microphone refusé.")); }
                    console.log("Attempting to start listening..."); speechPromiseCallbacks = { resolve, reject };
                    try { recognition.start(); } catch (e) { console.error("Immediate error on recognition.start():", e); recognitionActive = false; speechPromiseCallbacks = null; reject(new Error(`Erreur démarrage reco: ${e.message || e.name}`)); }
                });
            }

            // --- PTT Button Handlers ---
            function handlePttStart(event) { /* ... (same as before) ... */
                  event.preventDefault(); console.log("PTT Start");
                if (!speechApiAvailable || permissionGranted === false) { console.warn("PTT ignored: API/Permission issue."); return; }
                if (isListening || recognitionActive) { console.warn("PTT ignored: Already listening."); return; }
                const currentScreen = document.querySelector('.screen.active-screen')?.dataset.screenName;
                isMultimodalPrompt = (currentScreen === 'look_and_ask' && !!capturedImageDataForPrompt);
                if (currentScreen === 'look_and_ask' && !capturedImageDataForPrompt) { console.warn("PTT on Look&Ask screen but no image captured yet."); lookStatusText.textContent = "Veuillez d'abord capturer une image."; return; }
                isListening = true; pttButton?.classList.add('active'); pttButton?.setAttribute('aria-pressed', 'true');
                startSpeechRecognition()
                    .then(result => { console.log("Recognition promise resolved."); processSpeechResult(result); })
                    .catch(error => { console.error("Recognition promise rejected:", error); if (!error.message.includes("reconnaissance") && !error.message.includes("microphone")) { if (isMultimodalPrompt) { lookStatusText.textContent = `Erreur: ${error.message}`; setTimeout(resetLookAskState, 3000); } else { showErrorScreen(error.message); } } isListening = false; pttButton?.classList.remove('active'); pttButton?.setAttribute('aria-pressed', 'false'); isMultimodalPrompt = false; });
            }
            function handlePttEnd(event) { /* ... (same as before) ... */
                 event.preventDefault(); console.log("PTT End"); if (!isListening) { console.warn("PTT End ignored: Not listening."); return; } isListening = false; pttButton?.classList.remove('active'); pttButton?.setAttribute('aria-pressed', 'false');
                if (recognitionActive && recognition) { console.log("Stopping recognition via recognition.stop()..."); try { recognition.stop(); } catch (e) { console.error("Error on recognition.stop():", e); if (speechPromiseCallbacks?.reject) speechPromiseCallbacks.reject(new Error("Échec arrêt reco.")); if (isMultimodalPrompt) { lookStatusText.textContent = "Erreur lors de l'arrêt."; setTimeout(resetLookAskState, 3000); } else { showErrorScreen("Erreur lors de l'arrêt de l'écoute."); } speechPromiseCallbacks = null; isMultimodalPrompt = false; } }
                else { console.warn("PTT End: Recognition not active."); if (speechPromiseCallbacks?.reject) speechPromiseCallbacks.reject(new Error("Écoute terminée prématurément.")); speechPromiseCallbacks = null; isMultimodalPrompt = false; }
            }

            /** Processes the final speech result, calls the appropriate Gemini function. */
            async function processSpeechResult(result) { /* ... (same as before) ... */
                 console.log("Processing final speech result:", result); lastInteractionTime = Date.now();
                const destinationScreen = isMultimodalPrompt ? 'look_and_ask' : 'response';
                if (!isMultimodalPrompt) switchScreen('response'); else lookStatusText.textContent = "Traitement...";
                if (result instanceof Error) { queryTextElement.textContent = "Erreur de reconnaissance"; responseTextElement.innerHTML = `<p class="error-message">${result.message}</p>`; if (isMultimodalPrompt) { lookStatusText.textContent = `Erreur: ${result.message}`; setTimeout(resetLookAskState, 3000); } }
                else if (typeof result === 'string') {
                    const query = result.trim(); queryTextElement.textContent = query || "[Aucun texte reconnu]";
                    if (!query) { const noUnderstandMsg = "<p>Je n'ai pas compris ou rien entendu. Veuillez réessayer.</p>"; responseTextElement.innerHTML = noUnderstandMsg; if (isMultimodalPrompt) { lookStatusText.textContent = "Rien entendu. Réessayez."; } }
                    else { if (GEMINI_API_KEY && GEMINI_API_KEY !== 'YOUR_API_KEY') { if (!isMultimodalPrompt) responseTextElement.innerHTML = "<p><i>Réflexion en cours...</i></p>"; try { let answer; if (isMultimodalPrompt && capturedImageDataForPrompt) { console.log("Calling Gemini with Image and Text"); answer = await queryGeminiWithImage(query, capturedImageDataForPrompt); switchScreen('response'); } else { console.log("Calling Gemini with Text only"); answer = await queryGemini(query); } processApiResponse(answer); } catch (geminiError) { console.error("Gemini API call error:", geminiError); const errorHtml = `<p class="error-message">Erreur IA : ${geminiError.message}</p>`; responseTextElement.innerHTML = errorHtml; if (isMultimodalPrompt) { lookStatusText.textContent = `Erreur IA: ${geminiError.message}`; setTimeout(resetLookAskState, 3000); } if (isMultimodalPrompt) switchScreen('response'); } finally { if (isMultimodalPrompt) resetLookAskState(); } }
                        else { const noApiKeyMsg = "<p><i>(Fonctionnalité IA non configurée)</i></p>"; responseTextElement.innerHTML = noApiKeyMsg; addToHistory('user', query); addToHistory('model', "(Fonctionnalité IA non configurée)"); if (isMultimodalPrompt) { lookStatusText.textContent = "Fonctionnalité IA non configurée."; setTimeout(resetLookAskState, 3000); switchScreen('response'); } } } }
                else { const unexpectedMsg = '<p class="error-message">Problème inattendu (traitement voix).</p>'; queryTextElement.textContent = "Erreur Inattendue"; responseTextElement.innerHTML = unexpectedMsg; if (isMultimodalPrompt) { lookStatusText.textContent = "Erreur inattendue."; setTimeout(resetLookAskState, 3000); switchScreen('response'); } }
                 isMultimodalPrompt = false;
            }

            // --- Context and Function Calling ---

            /** Adds a message to the conversation history. */
            function addToHistory(role, text) { /* ... (same as before) ... */
                 conversationHistory.push({ role, parts: [{ text }] }); console.log("Added to history:", { role, text: text.substring(0, 50) + '...' });
            }
            /** Checks context timeout and clears history if needed. */
            function checkContextTimeout() { /* ... (same as before) ... */
                 const now = Date.now(); if (now - lastInteractionTime > CONTEXT_TIMEOUT) { console.log("Context timeout. Clearing history."); conversationHistory = []; } lastInteractionTime = now;
            }
            /** Executes a local function based on the name provided by the AI. */
             function executeFunction(functionName) {
                console.log(`Executing function: ${functionName}`);
                try {
                    switch (functionName) {
                        // Timer
                        case 'start_timer': if (timerStartButton && !isTimerRunning) timerStartButton.click(); break;
                        case 'reset_timer': timerResetButton?.click(); break;
                        // Music (Media Session)
                        case 'play_pause_music': handleMediaPlayPause(); break;
                        case 'prev_track': handleMediaPrev(); break;
                        case 'next_track': handleMediaNext(); break;
                        // Vision/Gallery
                        case 'capture_image': if (document.querySelector('.screen.active-screen')?.dataset.screenName === 'vision') visionCaptureButton?.click(); else console.warn("Capture_image called outside Vision screen."); break;
                        case 'show_gallery': switchScreen('gallery'); break;
                        // Navigation
                        case 'go_home': switchScreen('home'); break;
                        case 'show_alarms': switchScreen('alarms'); break;
                        case 'show_timer': switchScreen('timer'); break;
                        case 'show_music': switchScreen('music'); break;
                        case 'show_vision': switchScreen('vision'); break;
                        case 'show_calendar': switchScreen('calendar'); break;
                        // Notes
                        case 'show_notes': switchScreen('notes'); break;
                        case 'save_current_note': saveNote(); break;
                        // Multimodal
                        case 'look_and_ask': switchScreen('look_and_ask'); break;

                        default: console.warn(`Function "${functionName}" not recognized.`);
                    }
                } catch (error) { console.error(`Error executing function "${functionName}":`, error); }
            }
            /** Processes the API response, handles function calls, and displays text. */
            function processApiResponse(apiResponseText) { /* ... (same as before) ... */
                const functionCallRegex = /^\s*%\s*([a-zA-Z0-9_]+)\s*%([\s\S]*)/; const match = apiResponseText.match(functionCallRegex); let displayText = apiResponseText;
                if (match) { const functionName = match[1].trim(); const remainingText = match[2].trim(); console.log(`Function call detected: ${functionName}`); executeFunction(functionName); displayText = remainingText || `(Action ${functionName} exécutée)`; }
                displayMarkdownResponse(displayText, responseTextElement); addToHistory('model', apiResponseText); // Add RAW response to history
            }

            // --- Utility Functions (Timer) ---
            function formatTime(seconds) { return `${Math.floor(seconds / 60).toString().padStart(2, '0')}:${(seconds % 60).toString().padStart(2, '0')}`; }
            timerStartButton?.addEventListener('click', () => { /* ... (same as before) ... */ });
            timerResetButton?.addEventListener('click', () => { /* ... (same as before) ... */ });

            // --- Media Session & Music Controls ---
            function setupMediaSession() {
                if (!('mediaSession' in navigator)) {
                    console.warn("Media Session API not supported.");
                    return;
                }
                console.log("Setting up Media Session API...");

                // Initial Metadata (Placeholder)
                updateMediaMetadata({
                    title: "Aucune musique",
                    artist: "Artiste inconnu",
                    album: "Rabbit R1",
                    artwork: [ { src: 'https://placehold.co/96x96/cccccc/333333?text=R1', sizes: '96x96', type: 'image/png' } ] // Placeholder artwork
                });

                navigator.mediaSession.setActionHandler('play', handleMediaPlayPause);
                navigator.mediaSession.setActionHandler('pause', handleMediaPlayPause);
                navigator.mediaSession.setActionHandler('previoustrack', handleMediaPrev);
                navigator.mediaSession.setActionHandler('nexttrack', handleMediaNext);
                // Add more handlers if needed (seekbackward, seekforward, stop)
            }

            function updateMediaMetadata(metadata) {
                 if ('mediaSession' in navigator) {
                    console.log("Updating media metadata:", metadata);
                    navigator.mediaSession.metadata = new MediaMetadata(metadata);
                 }
            }

            function updateMediaUI(isPlaying, title = "Aucune musique", artist = "Artiste inconnu") {
                 const icon = playPauseButton?.querySelector('i');
                 if (icon) {
                     icon.classList.toggle('fa-play', !isPlaying);
                     icon.classList.toggle('fa-pause', isPlaying);
                 }
                 if (playPauseButton) playPauseButton.setAttribute('aria-label', isPlaying ? 'Pause' : 'Lecture');
                 if (musicTrackTitle) musicTrackTitle.textContent = title;
                 if (musicArtistName) musicArtistName.textContent = artist;
            }

            function handleMediaPlayPause() {
                console.log(`Media Session: ${isMusicSessionPlaying ? 'Pause' : 'Play'} triggered`);
                isMusicSessionPlaying = !isMusicSessionPlaying;
                navigator.mediaSession.playbackState = isMusicSessionPlaying ? 'playing' : 'paused';
                updateMediaUI(isMusicSessionPlaying, "Morceau Actuel (Simulé)", "Rabbit Band"); // Update UI with placeholder

                // Play/pause silent audio to keep session active/notify OS
                if (isMusicSessionPlaying) {
                    silentAudio.play().catch(e => console.warn("Silent audio play failed:", e)); // Play silent audio
                } else {
                    silentAudio.pause();
                }
            }

            function handleMediaPrev() {
                console.log("Media Session: Previous Track triggered");
                // Add logic to change track (simulation)
                updateMediaMetadata({ title: "Piste Précédente", artist: "Rabbit Band", album: "Rabbit R1", artwork: [ /* ... */ ] });
                updateMediaUI(isMusicSessionPlaying, "Piste Précédente", "Rabbit Band");
            }

            function handleMediaNext() {
                console.log("Media Session: Next Track triggered");
                // Add logic to change track (simulation)
                updateMediaMetadata({ title: "Piste Suivante", artist: "Rabbit Band", album: "Rabbit R1", artwork: [ /* ... */ ] });
                updateMediaUI(isMusicSessionPlaying, "Piste Suivante", "Rabbit Band");
            }

            // Attach handlers to UI buttons
            playPauseButton?.addEventListener('click', handleMediaPlayPause);
            prevTrackButton?.addEventListener('click', handleMediaPrev);
            nextTrackButton?.addEventListener('click', handleMediaNext);

            // --- Camera Management ---
            async function startVideoStream(targetScreenName) { /* ... (same as before) ... */
                 if (videoStream) { console.log("Video stream potentially active, ensuring display."); attachVideoToScreen(targetScreenName); return true; }
                if (permissionGranted === false) { console.warn("Cannot start video: permission denied."); showErrorScreen("Accès caméra refusé."); return false; }
                try { console.log(`Attempting to start video stream for ${targetScreenName}...`); const constraints = { video: { facingMode: "environment" } }; videoStream = await navigator.mediaDevices.getUserMedia(constraints).catch(async (e) => { console.warn("Environment camera failed, trying default:", e); if (e.name === 'OverconstrainedError' || e.name === 'NotFoundError') { return navigator.mediaDevices.getUserMedia({ video: true }); } throw e; }); videoElement.srcObject = videoStream; videoElement.play(); await new Promise((resolve, reject) => { videoElement.onloadedmetadata = resolve; videoElement.onerror = reject; }); console.log("Video stream started successfully."); attachVideoToScreen(targetScreenName); return true; }
                catch (err) { console.error("Error starting video stream:", err); let userMessage = "Impossible de démarrer le flux vidéo."; if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') userMessage = "Accès caméra refusé."; else if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') userMessage = "Aucune caméra trouvée."; else if (err.name === 'NotReadableError' || err.name === 'OverconstrainedError' || err.name === 'TrackStartError') userMessage = "Caméra déjà utilisée ou problème matériel."; else userMessage = `Erreur caméra: ${err.message || err.name}`; showErrorScreen(userMessage); videoStream = null; return false; }
            }
            function attachVideoToScreen(screenName) { /* ... (same as before) ... */
                  const targetContainer = screenName === 'vision' ? visionCameraPlaceholder : (screenName === 'look_and_ask' ? lookCameraContainer : null);
                if (targetContainer) { videoElement.style.display = 'block'; targetContainer.appendChild(videoElement); targetContainer.querySelector('.placeholder-icon')?.style.setProperty('display', 'none', 'important'); }
                else { videoElement.style.display = 'none'; if (videoElement.parentElement) videoElement.remove(); }
            }
            function stopVideoStream() { /* ... (same as before) ... */
                 if (videoStream) { console.log("Stopping video stream."); videoStream.getTracks().forEach(track => track.stop()); videoStream = null; videoElement.srcObject = null; if (videoElement.parentElement) videoElement.remove(); videoElement.style.display = 'none'; visionCameraPlaceholder?.querySelector('.placeholder-icon')?.style.removeProperty('display'); lookCameraContainer?.querySelector('.placeholder-icon')?.style.removeProperty('display'); }
            }
            function captureImageFromVideo() { /* ... (same as before) ... */
                  if (!videoStream || !videoElement.videoWidth || !videoElement.videoHeight) { console.error("Cannot capture: video stream not ready."); showErrorScreen("Impossible de capturer (flux vidéo non prêt)."); return null; }
                 canvasElement.width = videoElement.videoWidth; canvasElement.height = videoElement.videoHeight;
                 try { context.drawImage(videoElement, 0, 0, canvasElement.width, canvasElement.height); const imageDataUrl = canvasElement.toDataURL('image/png'); console.log('Image captured:', imageDataUrl.substring(0, 50) + '...'); return imageDataUrl; }
                 catch (e) { console.error("Error capturing or converting image:", e); showErrorScreen("Erreur lors de la capture."); return null; }
            }

            // --- Vision Screen Capture Handler ---
            visionCaptureButton?.addEventListener('click', () => { /* ... (same as before) ... */
                 console.log('Vision Capture button clicked.'); const imageDataUrl = captureImageFromVideo(); if (imageDataUrl) { capturedPhotos.push(imageDataUrl); console.log(`Photo added to gallery. Total: ${capturedPhotos.length}`); switchScreen('response'); queryTextElement.textContent = "Vision"; responseTextElement.innerHTML = "<p>Photo capturée et ajoutée à la galerie.</p>"; }
            });

            // --- Gallery Display ---
            function displayGallery() { /* ... (same as before) ... */
                 if (!galleryContainer || !galleryEmptyMsg) return; galleryContainer.innerHTML = '';
                if (capturedPhotos.length === 0) { galleryEmptyMsg.style.display = 'block'; }
                else { galleryEmptyMsg.style.display = 'none'; capturedPhotos.forEach((dataUrl, index) => { const item = document.createElement('div'); item.className = 'gallery-item'; const img = document.createElement('img'); img.src = dataUrl; img.alt = `Photo capturée ${index + 1}`; const downloadLink = document.createElement('a'); downloadLink.href = dataUrl; downloadLink.download = `rabbit_capture_${index + 1}.png`; downloadLink.className = 'download-link'; downloadLink.innerHTML = '<i class="fas fa-download"></i>'; downloadLink.setAttribute('aria-label', 'Télécharger l\'image'); downloadLink.title = 'Télécharger'; item.appendChild(img); item.appendChild(downloadLink); galleryContainer.appendChild(item); }); }
            }

             // --- Notes Management ---
             const NOTES_STORAGE_KEY = 'rabbit_notes_list';

             /** Loads notes from localStorage */
             function loadNotes() {
                 try {
                     const storedNotes = localStorage.getItem(NOTES_STORAGE_KEY);
                     return storedNotes ? JSON.parse(storedNotes) : [];
                 } catch (e) {
                     console.error("Error loading notes from localStorage:", e);
                     return []; // Return empty array on error
                 }
             }

             /** Saves the notes array to localStorage */
             function saveNotes(notesArray) {
                 try {
                     localStorage.setItem(NOTES_STORAGE_KEY, JSON.stringify(notesArray));
                     console.log("Notes array saved.");
                 } catch (e) {
                     console.error("Error saving notes to localStorage:", e);
                     if(notesFeedback) notesFeedback.textContent = "Erreur sauvegarde notes.";
                 }
             }

             /** Saves the current content of the textarea as a new note */
             function saveNote() {
                 if (notesTextarea) {
                     const noteContent = notesTextarea.value.trim();
                     if (!noteContent) {
                         if(notesFeedback) notesFeedback.textContent = "La note est vide.";
                         setTimeout(() => { notesFeedback.textContent = ""; }, 2000);
                         return;
                     }
                     const notes = loadNotes();
                     const newNote = {
                         id: Date.now(), // Simple timestamp ID
                         content: noteContent
                     };
                     notes.push(newNote); // Add to the end
                     saveNotes(notes);
                     notesTextarea.value = ''; // Clear textarea
                     if(notesFeedback) { notesFeedback.textContent = "Note enregistrée !"; setTimeout(() => { notesFeedback.textContent = ""; }, 2000); }
                     displayAllNotes(); // Refresh the list
                 }
             }

             /** Deletes a note by its ID */
             function deleteNote(noteId) {
                 let notes = loadNotes();
                 const initialLength = notes.length;
                 notes = notes.filter(note => note.id !== noteId);
                 if (notes.length < initialLength) {
                     saveNotes(notes);
                     console.log(`Note with ID ${noteId} deleted.`);
                     displayAllNotes(); // Refresh the list
                 } else {
                     console.warn(`Note with ID ${noteId} not found for deletion.`);
                 }
             }

             /** Displays all saved notes in the list container */
             function displayAllNotes() {
                 if (!notesListContainer) return;
                 const notes = loadNotes();
                 notesListContainer.innerHTML = ''; // Clear previous list

                 if (notes.length === 0) {
                     notesListContainer.innerHTML = '<p id="notes-list-empty">Aucune note enregistrée.</p>';
                 } else {
                     // Display newest first
                     notes.slice().reverse().forEach(note => {
                         const noteDiv = document.createElement('div');
                         noteDiv.className = 'note-item';

                         const contentSpan = document.createElement('span');
                         contentSpan.className = 'note-content';
                         contentSpan.textContent = note.content;

                         const deleteButton = document.createElement('button');
                         deleteButton.className = 'delete-note-btn';
                         deleteButton.innerHTML = '<i class="fas fa-trash-alt"></i>';
                         deleteButton.setAttribute('aria-label', 'Supprimer la note');
                         deleteButton.title = 'Supprimer';
                         deleteButton.onclick = () => deleteNote(note.id); // Attach delete handler

                         noteDiv.appendChild(contentSpan);
                         noteDiv.appendChild(deleteButton);
                         notesListContainer.appendChild(noteDiv);
                     });
                 }
             }

             // Attach event listeners for notes
             saveNoteButton?.addEventListener('click', saveNote);
             showAllNotesButton?.addEventListener('click', displayAllNotes);


             // --- Look & Ask (Multimodal) Management ---
             function resetLookAskState() { /* ... (same as before) ... */
                  console.log("Resetting Look & Ask state."); capturedImageDataForPrompt = null; isMultimodalPrompt = false; lookStatusText.textContent = "Visez, puis capturez l'image."; lookCaptureButton.disabled = false; const preview = lookCameraContainer?.querySelector('.captured-image-preview'); if (preview) preview.remove(); if (videoStream && videoElement.parentElement === lookCameraContainer) videoElement.style.display = 'block'; else if (!videoStream) lookCameraContainer?.querySelector('.placeholder-icon')?.style.removeProperty('display');
             }
             lookCaptureButton?.addEventListener('click', () => { /* ... (same as before) ... */
                  console.log('Look & Ask Capture button clicked.'); const imageDataUrl = captureImageFromVideo(); if (imageDataUrl) { capturedImageDataForPrompt = imageDataUrl; lookStatusText.textContent = "Image capturée. Parlez maintenant pour poser votre question."; lookCaptureButton.disabled = true; const previewImg = document.createElement('img'); previewImg.src = imageDataUrl; previewImg.className = 'captured-image-preview'; lookCameraContainer.appendChild(previewImg); videoElement.style.display = 'none'; } else { lookStatusText.textContent = "Échec de la capture. Réessayez."; }
             });

            // --- Gemini API Calls ---
            async function queryGemini(prompt) { /* ... (same as before) ... */
                 console.log("Querying Gemini (Text):", prompt); checkContextTimeout(); addToHistory('user', prompt);
                if (!GEMINI_API_KEY || GEMINI_API_KEY === 'YOUR_API_KEY') { const errorMsg = "Clé API non configurée."; addToHistory('model', errorMsg); throw new Error(errorMsg); }
                const requestContents = [ { role: 'user', parts: [{ text: SYSTEM_INSTRUCTION }] }, ...conversationHistory ];
                try { const response = await fetch(GEMINI_API_URL, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ contents: requestContents, safetySettings: [ /* ... */ ] }) }); const data = await response.json(); if (!response.ok) { console.error('Gemini API Error:', response.status, data); const errorMessage = data?.error?.message || `Erreur HTTP ${response.status}`; const fullErrorMsg = `Erreur API IA : ${errorMessage}`; addToHistory('model', `Erreur: ${fullErrorMsg}`); throw new Error(fullErrorMsg); } console.log("Gemini API Response (Raw):", data); let responseText = "Désolé, je n'ai pas pu générer de réponse."; if (data.candidates?.length > 0) { const candidate = data.candidates[0]; if (candidate.finishReason && candidate.finishReason !== 'STOP' && candidate.finishReason !== 'MAX_TOKENS') { const reason = candidate.finishReason.replace(/_/g, ' ').toLowerCase(); responseText = (candidate.content?.parts?.[0]?.text || "") + `\n\n_(Réponse interrompue: ${reason}.)_`; } else { responseText = candidate.content?.parts?.[0]?.text || "Format de réponse inattendu."; } } else if (data.promptFeedback?.blockReason) { const reason = data.promptFeedback.blockReason.replace(/_/g, ' ').toLowerCase(); responseText = `Réponse bloquée (${reason}).`; } return responseText; }
                catch (error) { console.error('Error fetching Gemini (Text):', error); if (!error.message.includes("Erreur API IA")) addToHistory('model', `Erreur réseau/fetch: ${error.message}`); throw error; }
            }
            async function queryGeminiWithImage(prompt, base64ImageData) { /* ... (same as before) ... */
                 console.log("Querying Gemini (Multimodal):", prompt); checkContextTimeout(); addToHistory('user', prompt);
                if (!GEMINI_API_KEY || GEMINI_API_KEY === 'YOUR_API_KEY') { const errorMsg = "Clé API non configurée."; addToHistory('model', errorMsg); throw new Error(errorMsg); }
                const pureBase64 = base64ImageData.split(',')[1]; const requestContents = [ { role: 'user', parts: [{ text: SYSTEM_INSTRUCTION }] }, ...conversationHistory.slice(0, -1), { role: 'user', parts: [ { text: prompt }, { inline_data: { mime_type: 'image/png', data: pureBase64 } } ]} ]; responseTextElement.innerHTML = "<p><i>Analyse de l'image et réflexion en cours...</i></p>";
                try { const response = await fetch(GEMINI_API_URL, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ contents: requestContents, safetySettings: [ /* ... */ ] }) }); const data = await response.json(); if (!response.ok) { console.error('Gemini API Error (Multimodal):', response.status, data); const errorMessage = data?.error?.message || `Erreur HTTP ${response.status}`; const fullErrorMsg = `Erreur IA (image) : ${errorMessage}`; addToHistory('model', `Erreur: ${fullErrorMsg}`); throw new Error(fullErrorMsg); } console.log("Gemini API Response (Multimodal Raw):", data); let responseText = "Désolé, je n'ai pas pu analyser l'image."; if (data.candidates?.length > 0) { const candidate = data.candidates[0]; if (candidate.finishReason && candidate.finishReason !== 'STOP' && candidate.finishReason !== 'MAX_TOKENS') { const reason = candidate.finishReason.replace(/_/g, ' ').toLowerCase(); responseText = (candidate.content?.parts?.[0]?.text || "") + `\n\n_(Analyse interrompue: ${reason}.)_`; } else { responseText = candidate.content?.parts?.[0]?.text || "Je n'ai pas de commentaire sur cette image."; } } else if (data.promptFeedback?.blockReason) { const reason = data.promptFeedback.blockReason.replace(/_/g, ' ').toLowerCase(); responseText = `Analyse bloquée (${reason}).`; } return responseText; }
                catch (error) { console.error('Error fetching Gemini (Multimodal):', error); if (!error.message.includes("Erreur IA")) addToHistory('model', `Erreur réseau/fetch (image): ${error.message}`); throw error; }
            }

            // --- Markdown Display ---
            function markdownToHtml(markdown) { /* ... (same as before) ... */ return markdown; } // Simplified for brevity, keep full version
            function markdownToHtmlSimpleInline(text) { /* ... (same as before) ... */ return text; } // Simplified for brevity, keep full version
            function displayMarkdownResponse(markdownText, element) { /* ... (same as before) ... */
                 if (element) { element.innerHTML = markdownToHtml(markdownText); element.style.opacity = 0; element.scrollTop = 0; setTimeout(() => { element.style.opacity = 1; }, 50); } else { console.error("Response display element not found."); }
            }

            // --- Scroll & Back Button Handlers ---
            scrollUpButton?.addEventListener('click', () => { /* ... (same as before) ... */ });
            scrollDownButton?.addEventListener('click', () => { /* ... (same as before) ... */ });
            document.querySelectorAll('.back-button').forEach(button => { /* ... (same as before) ... */ });

            // --- App Initialization ---
            async function initializeApp() {
                 console.log("Initializing Rabbit R1 Web App...");
                switchScreen('home'); // Start at home screen
                displayAllNotes(); // Load and display notes on startup
                setupMediaSession(); // Initialize Media Session API

                const speechReady = await initializeSpeechRecognition();

                if (speechReady && pttButton) {
                    // Attach PTT listeners
                    pttButton.addEventListener('mousedown', handlePttStart); pttButton.addEventListener('mouseup', handlePttEnd);
                    pttButton.addEventListener('mouseleave', (e) => { if (isListening) handlePttEnd(e); });
                    pttButton.addEventListener('touchstart', handlePttStart, { passive: false }); pttButton.addEventListener('touchend', handlePttEnd);
                    pttButton.addEventListener('touchcancel', (e) => { if (isListening) handlePttEnd(e); });
                    console.log("PTT Handlers attached.");
                } else { console.warn("PTT initialization failed."); if(pttButton) pttButton.disabled = true; }
                console.log("Application initialized.");
            }

            // Start the application
            initializeApp();

            // Cleanup: Stop video stream when leaving the page
            window.addEventListener('beforeunload', stopVideoStream);

        }); // End DOMContentLoaded
    </script>
</body>
</html>
