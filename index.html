
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Rabbit R1 Web App - Cool Edition</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Press+Start+2P&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/css-spinner/1.1.1/css-spinner.min.css">

    <style>
        /* --- Global Variables --- */
        :root {
            --rabbit-orange: #ff7e00;
            --rabbit-orange-dark: #e67200;
            --off-white: #f9f9f9; /* Slightly brighter */
            --light-gray: #e8e8e8;
            --medium-gray: #cccccc;
            --dark-gray: #333333;
            --device-gray: #d8d8d8; /* Slightly lighter device body */
            --error-red: #e74c3c; /* Brighter red */
            --success-green: #2ecc71; /* Brighter green */
            --glass-bg: rgba(50, 50, 50, 0.45); /* Darker glass for better contrast on video */
            --glass-border: rgba(255, 255, 255, 0.3);
            --glass-blur: 12px; /* More blur */
            --transition-speed: 0.4s; /* Consistent transition speed */
            --transition-timing: cubic-bezier(0.25, 0.8, 0.25, 1); /* Smoother ease-out */
        }

        /* --- Base Styles --- */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html { height: -webkit-fill-available; /* iOS viewport height fix */ }
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%); /* Subtle gradient background */
            color: var(--dark-gray);
            display: flex; justify-content: center; align-items: center;
            min-height: 100vh;
            /* iOS viewport height fix */
            min-height: -webkit-fill-available;
            padding: 20px;
            -webkit-tap-highlight-color: transparent;
            overflow: hidden; /* Prevent body scroll */
        }

        /* --- Device Container --- */
        .device-container {
            width: 100%;
            max-width: 370px; /* Slightly wider */
            margin: 0 auto;
            perspective: 1000px; /* For 3D effects if needed */
        }
        .rabbit-device {
            background-color: var(--device-gray);
            border-radius: 30px; /* More rounded */
            padding: 18px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.15), 0 5px 15px rgba(0, 0, 0, 0.1); /* Deeper shadow */
            display: flex; flex-direction: column; align-items: center; gap: 18px;
            border: 1px solid rgba(255, 255, 255, 0.5); /* Subtle inner border */
            position: relative; /* For absolute positioning of audio player if needed */
        }

        /* --- Main Display --- */
        .main-display {
            background-color: var(--off-white);
            border-radius: 20px; /* More rounded inner display */
            width: 100%;
            aspect-ratio: 1 / 1;
            overflow: hidden;
            position: relative;
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        /* --- Screens (General) --- */
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center;
            padding: 25px; /* Default padding */
            opacity: 0; visibility: hidden;
            transition: opacity var(--transition-speed) var(--transition-timing),
                        transform var(--transition-speed) var(--transition-timing),
                        visibility var(--transition-speed) var(--transition-timing);
            transform: translateY(30px) scale(0.98); /* Start slightly scaled down and below */
            overflow-y: auto; /* Enable scrolling within screen */
            background-color: var(--off-white);
            scrollbar-width: thin; /* Firefox */
            scrollbar-color: var(--medium-gray) var(--light-gray); /* Firefox */
        }
        /* Scrollbar styling for Webkit browsers */
        .screen::-webkit-scrollbar { width: 6px; }
        .screen::-webkit-scrollbar-track { background: var(--light-gray); border-radius: 3px; }
        .screen::-webkit-scrollbar-thumb { background-color: var(--medium-gray); border-radius: 3px; }

        .active-screen {
            opacity: 1; visibility: visible;
            transform: translateY(0) scale(1); /* Animate to final position */
        }
        /* Specific transition for listening screen (fade only) */
        .listening-screen { transform: none; transition: opacity 0.2s ease; }
        .listening-screen.active-screen { transform: none; }

        /* --- Common Screen Title --- */
        .screen h2 {
            font-size: 22px; font-weight: 600; margin-bottom: 20px;
            text-align: center; width: 100%; color: var(--dark-gray);
            flex-shrink: 0;
            animation: fadeInDown 0.5s var(--transition-timing) backwards;
            animation-delay: 0.1s; /* Slight delay for title */
        }

        /* --- Back Button (Common) --- */
        .back-button {
            padding: 10px 20px; /* Larger padding */
            background: linear-gradient(145deg, var(--medium-gray), var(--light-gray)); /* Subtle gradient */
            border: none; border-radius: 8px; /* More rounded */
            color: var(--dark-gray); cursor: pointer;
            transition: all 0.2s ease; /* Smooth transition for hover/active */
            font-size: 14px; display: inline-flex;
            align-items: center; gap: 8px;
            z-index: 10; /* Ensure above most content */
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            font-weight: 500;
        }
        .back-button:hover {
            background: linear-gradient(145deg, var(--light-gray), var(--medium-gray));
            box-shadow: 0 4px 8px rgba(0,0,0,0.08);
            transform: translateY(-1px);
        }
        .back-button:active {
            transform: translateY(0px);
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }
        /* Default positioning for back button (absolute for specific screens) */
        .response-screen .back-button, .error-screen .back-button, .notes-screen .back-button,
        .gallery-screen .back-button {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            animation: fadeInUp 0.5s var(--transition-timing) backwards;
            animation-delay: 0.3s; /* Delay for back button */
        }
         /* Standard margin for others */
        .calendar-screen .back-button, .alarms-screen .back-button, .timer-screen .back-button,
        .music-screen .back-button {
            margin-top: auto; /* Push to bottom */
            margin-bottom: 5px; /* Small space from bottom */
            animation: fadeInUp 0.5s var(--transition-timing) backwards;
            animation-delay: 0.3s;
        }
        /* Specific back button position for camera screens (absolute) */
        .vision-screen .back-button, .look-at-this-screen .back-button {
            position: absolute; bottom: 20px; left: 50%;
            transform: translateX(-50%);
            animation: fadeInUp 0.5s var(--transition-timing) backwards;
            animation-delay: 0.6s; /* Delay more */
            /* Style adjustment for better visibility on video */
            background: var(--glass-bg);
            color: var(--off-white);
            border: 1px solid var(--glass-border);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }
        .vision-screen .back-button:hover, .look-at-this-screen .back-button:hover {
            background: rgba(80, 80, 80, 0.6);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
            transform: translateX(-50%) translateY(-1px); /* Adjust transform */
        }
        .vision-screen .back-button:active, .look-at-this-screen .back-button:active {
            transform: translateX(-50%) translateY(0px); /* Adjust transform */
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);
        }

        /* --- Specific Screen Styles --- */

        /* Home Screen */
        .home-screen {
            justify-content: center; text-align: center;
            position: relative; /* For status bar positioning */
            padding-top: 45px; /* Make space for status bar */
        }
        .status-bar {
            position: absolute;
            top: 10px;
            left: 15px;
            right: 15px;
            display: flex;
            justify-content: space-between; /* Distribute items */
            align-items: center;
            font-size: 11px; /* Smaller font */
            color: #555; /* Muted color */
            padding: 4px 8px;
            background-color: rgba(255, 255, 255, 0.6); /* Slight white background */
            border-radius: 10px;
            z-index: 5;
            animation: fadeIn 0.8s ease backwards;
            animation-delay: 0.4s;
        }
        .status-bar span { white-space: nowrap; } /* Prevent wrapping */
        #home-battery { display: flex; align-items: center; gap: 4px; } /* Align battery icon and text */
        #home-battery .fa-plug { font-size: 0.8em; color: var(--success-green); } /* Charging icon style */

        .greeting { font-size: 28px; font-weight: 700; margin-bottom: 10px; animation: fadeInScale 0.6s var(--transition-timing) backwards; animation-delay: 0.1s; }
        .instruction { font-size: 17px; color: #555; margin-bottom: 20px; animation: fadeInScale 0.6s var(--transition-timing) backwards; animation-delay: 0.2s; }
        .permission-status { font-size: 13px; color: #666; margin-top: 15px; min-height: 1.2em; font-weight: 500; animation: fadeInScale 0.6s var(--transition-timing) backwards; animation-delay: 0.3s; }
        .permission-status.error { color: var(--error-red); font-weight: 600; }

        /* Listening Screen */
        .listening-screen { justify-content: center; background-color: rgba(0,0,0,0.05); /* Slight overlay */ }
        .listening-indicator { text-align: center; }
        .listening-text { font-size: 20px; margin-bottom: 25px; animation: pulse 1.5s infinite alternate ease-in-out; }
        .waveform { display: flex; justify-content: center; align-items: flex-end; gap: 6px; height: 50px; }
        .waveform span {
            display: inline-block; width: 6px;
            background-color: var(--rabbit-orange);
            border-radius: 3px;
            animation: wave 1s infinite ease-in-out alternate;
        }
        /* Staggered animation delays for waveform */
        .waveform span:nth-child(1) { height: 10px; animation-delay: 0s; }
        .waveform span:nth-child(2) { height: 20px; animation-delay: 0.1s; }
        .waveform span:nth-child(3) { height: 30px; animation-delay: 0.2s; }
        .waveform span:nth-child(4) { height: 25px; animation-delay: 0.3s; }
        .waveform span:nth-child(5) { height: 15px; animation-delay: 0.4s; } /* Added a 5th bar */

        @keyframes wave {
            0% { height: 5px; opacity: 0.5; transform: scaleY(0.5); }
            100% { height: 45px; opacity: 1; transform: scaleY(1); }
        }
        @keyframes pulse {
            0% { opacity: 0.7; transform: scale(1); }
            100% { opacity: 1; transform: scale(1.03); }
        }

        /* Response Screen */
        .response-screen { justify-content: flex-start; align-items: flex-start; padding-bottom: 75px; /* More space for back button */ }
        .query-text { font-weight: 600; margin-bottom: 16px; align-self: flex-start; width: 100%; color: #555; border-bottom: 1px solid var(--light-gray); padding-bottom: 10px; word-wrap: break-word; animation: fadeInDown 0.4s var(--transition-timing) backwards; animation-delay: 0.1s; }
        .response-text { width: 100%; font-size: 15px; line-height: 1.7; /* Increased line height */ word-wrap: break-word; padding-bottom: 30px; animation: fadeInUp 0.5s var(--transition-timing) backwards; animation-delay: 0.2s; }
        .response-text p i { color: #777; } /* Slightly darker italic */
        .response-text p.error-message { color: var(--error-red); font-weight: 600; background-color: rgba(231, 76, 60, 0.1); padding: 8px; border-radius: 4px; }
        .response-text .loading-indicator { display: flex; justify-content: center; align-items: center; min-height: 50px; color: #888; font-style: italic; gap: 10px;}

        /* Markdown Styles (Refined) */
        .response-text p { margin-bottom: 1.2em; }
        .response-text h1, .response-text h2, .response-text h3 { margin-top: 1.8em; margin-bottom: 1em; line-height: 1.4; color: var(--dark-gray); }
        .response-text h1 { font-size: 1.7em; border-bottom: 2px solid var(--rabbit-orange); padding-bottom: 0.4em; }
        .response-text h2 { font-size: 1.5em; }
        .response-text h3 { font-size: 1.3em; }
        .response-text ul, .response-text ol { margin-left: 30px; margin-bottom: 1.2em; padding-left: 0;} /* Reset padding */
        .response-text li { margin-bottom: 0.6em; }
        .response-text code { background-color: #eee; padding: 0.3em 0.5em; border-radius: 4px; font-family: 'Courier New', Courier, monospace; font-size: 0.95em; word-wrap: break-word; border: 1px solid #ddd; }
        .response-text pre { background-color: #f0f0f0; padding: 18px; border-radius: 8px; overflow-x: auto; margin-bottom: 1.2em; border: 1px solid #ddd; box-shadow: inset 0 1px 3px rgba(0,0,0,0.05); }
        .response-text pre code { background-color: transparent; padding: 0; font-size: 0.95em; word-wrap: normal; border: none; }
        .response-text blockquote { border-left: 5px solid var(--rabbit-orange); padding-left: 18px; margin: 1.5em 0; color: #555; font-style: italic; background-color: #fdf8f2; }
        .response-text table { border-collapse: collapse; width: 100%; margin: 1.8em 0; border: 1px solid var(--medium-gray); box-shadow: 0 1px 3px rgba(0,0,0,0.05); border-radius: 4px; overflow: hidden; }
        .response-text th, .response-text td { border: 1px solid var(--medium-gray); padding: 12px; text-align: left; }
        .response-text th { background-color: var(--light-gray); font-weight: 600; }
        .response-text tr:nth-child(even) { background-color: #f8f8f8; }
        .response-text hr { border: none; border-top: 2px dashed var(--light-gray); margin: 2.5em 0; }
        .response-text a { color: var(--rabbit-orange); text-decoration: none; font-weight: 500; transition: color 0.2s; }
        .response-text a:hover { color: var(--rabbit-orange-dark); text-decoration: underline; }
        .response-text img { max-width: 100%; height: auto; border-radius: 8px; margin: 1em 0; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }

        /* Alarms Screen */
        .alarms-screen { justify-content: flex-start; }
        .alarms-list { list-style: none; width: 100%; padding: 0; animation: fadeInUpList 0.6s var(--transition-timing) backwards; animation-delay: 0.1s; }
        .alarms-list li {
            padding: 15px; border-bottom: 1px solid var(--light-gray);
            transition: background-color 0.2s;
            border-radius: 4px; margin-bottom: 5px;
        }
        .alarms-list li:hover { background-color: rgba(0,0,0,0.03); }

        /* Timer Screen */
        .timer-screen { justify-content: center; /* Center content vertically */ }
        .timer-display { font-family: 'Press Start 2P', cursive; font-size: 36px; margin: 25px 0; color: var(--dark-gray); animation: pulse 1.5s infinite alternate ease-in-out; animation-play-state: paused; }
        .timer-display.running { animation-play-state: running; }
        .timer-controls { display: flex; gap: 15px; margin-bottom: 25px; animation: fadeInUp 0.5s var(--transition-timing) backwards; animation-delay: 0.2s; }
        .timer-btn { padding: 10px 20px; background: linear-gradient(145deg, var(--medium-gray), var(--light-gray)); border: none; border-radius: 8px; color: var(--dark-gray); cursor: pointer; transition: all 0.2s ease; font-weight: 500; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .timer-btn:hover { background: linear-gradient(145deg, var(--light-gray), var(--medium-gray)); box-shadow: 0 4px 8px rgba(0,0,0,0.08); transform: translateY(-1px); }
        .timer-btn:active { transform: translateY(0px); box-shadow: inset 0 1px 3px rgba(0,0,0,0.1); }

        /* Music Screen */
        .music-screen { justify-content: center; /* Center content */ }
        .album-art { width: 140px; height: 140px; background-color: var(--medium-gray); border-radius: 12px; margin-bottom: 20px; display: flex; justify-content: center; align-items: center; font-size: 50px; color: #fff; background-image: linear-gradient(45deg, #a0a0a0, #c0c0c0); box-shadow: 0 5px 15px rgba(0,0,0,0.1); animation: fadeInScale 0.6s var(--transition-timing) backwards; animation-delay: 0.1s; }
        .album-art i { opacity: 0.8; } /* Make icon slightly transparent */
        /* Remove ::before if using <i> */
        /*.album-art::before { content: '\f001'; font-family: 'Font Awesome 6 Free'; font-weight: 900; }*/
        .track-info { text-align: center; margin-bottom: 20px; animation: fadeInUp 0.5s var(--transition-timing) backwards; animation-delay: 0.2s; min-height: 45px; /* Prevent layout shift */ }
        .track-title { font-weight: 600; font-size: 18px; margin-bottom: 5px; }
        .artist-name { font-size: 15px; color: #666; }
        .music-controls { display: flex; gap: 20px; margin-bottom: 25px; animation: fadeInUp 0.5s var(--transition-timing) backwards; animation-delay: 0.3s; }
        .music-btn { width: 45px; height: 45px; border-radius: 50%; background: linear-gradient(145deg, var(--medium-gray), var(--light-gray)); border: none; display: flex; justify-content: center; align-items: center; cursor: pointer; transition: all 0.2s ease; font-size: 18px; color: var(--dark-gray); box-shadow: 0 2px 4px rgba(0,0,0,0.05); position: relative; overflow: hidden; /* For icon transition */ }
        .music-btn:hover { background: linear-gradient(145deg, var(--light-gray), var(--medium-gray)); box-shadow: 0 4px 8px rgba(0,0,0,0.08); transform: scale(1.05); }
        .music-btn:active { transform: scale(0.98); box-shadow: inset 0 1px 3px rgba(0,0,0,0.1); }

        /* Play/Pause Icon Transition */
        #play-pause .fa-play, #play-pause .fa-pause {
            position: absolute; /* Position icons on top of each other */
            transition: transform 0.2s ease, opacity 0.2s ease;
            transform: scale(1); opacity: 1;
        }
        #play-pause.playing .fa-play { transform: scale(0); opacity: 0; }
        #play-pause.playing .fa-pause { transform: scale(1); opacity: 1; }
        #play-pause:not(.playing) .fa-play { transform: scale(1); opacity: 1; }
        #play-pause:not(.playing) .fa-pause { transform: scale(0); opacity: 0; }

        /* --- Camera Screens Styling --- */
        .vision-screen, .look-at-this-screen {
            justify-content: flex-start; /* Align items to top */
            padding: 0; /* Remove padding to allow full screen */
            overflow: hidden; /* Hide scrollbars for full screen camera */
        }
        /* Style title specifically for camera screens */
        .vision-screen h2, .look-at-this-screen h2 {
            position: absolute; /* Position over the camera view */
            top: 15px; left: 50%; transform: translateX(-50%);
            z-index: 5; /* Ensure title is above video but below PTT */
            background: rgba(0, 0, 0, 0.4); /* Semi-transparent background */
            color: white;
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 16px; /* Smaller title */
            margin-bottom: 0; /* Remove default margin */
            animation: fadeInDown 0.5s var(--transition-timing) backwards;
            animation-delay: 0.2s;
            pointer-events: none; /* Allow clicks through title */
        }

        /* Camera Container (Make it fill the screen) */
        .camera-container {
            width: 100%; height: 100%; /* Fill the parent screen */
            flex-grow: 1; /* Ensure it takes space if screen is flex */
            background-color: #000; /* Black background */
            border-radius: 0; /* Remove border-radius, inherits from main-display */
            overflow: hidden;
            position: relative; /* Keep for absolute positioning inside */
            display: flex; justify-content: center; align-items: center;
            margin-bottom: 0; /* Remove margin */
            box-shadow: none; /* Remove shadow */
            animation: none; /* Remove entrance animation */
        }
        .camera-container i.placeholder-icon {
            font-size: 60px; color: #444; z-index: 0;
            transition: opacity 0.3s ease;
        }
        .camera-container.video-active i.placeholder-icon {
            opacity: 0;
        }

        /* Live Video Element (Make it fill the container) */
        .live-video {
            display: block;
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            object-fit: cover; /* Cover the container */
            z-index: 1; /* Below overlays */
            border-radius: 0; /* Match container */
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        .live-video.active {
            opacity: 1;
        }

        /* Captured Image Preview (Make it fill the container) */
        .captured-image-preview {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            object-fit: cover; z-index: 2; /* Above video */
            border-radius: 0; /* Match container */
            animation: fadeIn 0.3s ease;
        }

        /* Glassmorphism Overlay Style (Adjusted) */
        .glass-overlay {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            background: var(--glass-bg);
            backdrop-filter: blur(var(--glass-blur));
            -webkit-backdrop-filter: blur(var(--glass-blur));
            border: 1px solid var(--glass-border);
            border-radius: 16px; /* More rounded */
            padding: 10px 18px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
            z-index: 3; /* Above video/preview, below back button potentially */
            color: var(--off-white); /* White text on darker glass */
            text-align: center;
            transition: transform 0.3s var(--transition-timing), opacity 0.3s ease;
        }
        .glass-overlay:hover {
            transform: translateX(-50%) scale(1.03);
        }

        /* Specific Overlays (Adjusted Positions) */
        .vision-capture-overlay { bottom: 75px; animation: fadeInUp 0.5s var(--transition-timing) backwards; animation-delay: 0.4s; }
        .look-capture-overlay { bottom: 75px; animation: fadeInUp 0.5s var(--transition-timing) backwards; animation-delay: 0.4s; }
        .look-status-overlay { bottom: 130px; /* Position above capture button */ font-size: 14px; min-width: 220px; animation: fadeInUp 0.5s var(--transition-timing) backwards; animation-delay: 0.5s; padding: 8px 15px;}

        .capture-btn, .look-capture-btn {
            padding: 10px 20px; background: var(--rabbit-orange); border: none;
            border-radius: 10px; color: white; cursor: pointer;
            transition: all 0.2s ease; font-size: 16px; font-weight: 600; /* Bolder */
            display: inline-flex; align-items: center; gap: 8px;
            box-shadow: 0 3px 6px rgba(255, 126, 0, 0.2);
        }
        .capture-btn:hover, .look-capture-btn:hover { background-color: var(--rabbit-orange-dark); box-shadow: 0 5px 10px rgba(255, 126, 0, 0.3); transform: translateY(-1px); }
        .capture-btn:active, .look-capture-btn:active { transform: translateY(0px) scale(0.98); box-shadow: inset 0 1px 3px rgba(0,0,0,0.1); }
        .look-capture-btn:disabled { background-color: var(--medium-gray); cursor: not-allowed; box-shadow: none; transform: none; opacity: 0.7; }
        .look-capture-btn:disabled:hover { background-color: var(--medium-gray); transform: none; }

        /* Error Screen */
        .error-screen { justify-content: center; text-align: center; padding-bottom: 75px; }
        .error-screen h2 { color: var(--error-red); animation: shake 0.5s ease; }
        #error-message { margin-bottom: 25px; color: var(--error-red); font-weight: 500; font-size: 16px; background-color: rgba(231, 76, 60, 0.1); padding: 15px; border-radius: 8px; animation: fadeInUp 0.4s var(--transition-timing) backwards; animation-delay: 0.1s; }

        /* Calendar Screen */
        .calendar-screen { justify-content: center; }
        .calendar-placeholder { width: 100%; max-width: 300px; height: 220px; background-color: #eee; border: 1px solid var(--light-gray); display: flex; flex-direction: column; justify-content: center; align-items: center; font-style: italic; color: #999; border-radius: 12px; box-shadow: 0 2px 5px rgba(0,0,0,0.05); animation: fadeInScale 0.6s var(--transition-timing) backwards; animation-delay: 0.1s; }
        .calendar-placeholder::before { content: '\f073'; font-family: 'Font Awesome 6 Free'; font-weight: 900; font-size: 40px; margin-bottom: 10px; color: var(--medium-gray); }

        /* Notes Screen */
        .notes-screen { justify-content: flex-start; padding-bottom: 95px; /* Extra space for save button + feedback + back */ }
        .notes-textarea { width: 100%; flex-grow: 1; margin-bottom: 15px; padding: 15px; border: 1px solid var(--light-gray); border-radius: 8px; font-family: inherit; font-size: 15px; resize: vertical; box-shadow: inset 0 1px 3px rgba(0,0,0,0.05); transition: border-color 0.2s, box-shadow 0.2s; animation: fadeInUp 0.5s var(--transition-timing) backwards; animation-delay: 0.1s; }
        .notes-textarea:focus { border-color: var(--rabbit-orange); box-shadow: 0 0 0 3px rgba(255, 126, 0, 0.2), inset 0 1px 3px rgba(0,0,0,0.05); outline: none; }
        .save-note-btn { padding: 10px 20px; background-color: var(--success-green); color: white; border: none; border-radius: 8px; cursor: pointer; transition: all 0.2s; margin-bottom: 10px; /* Space before feedback */ font-weight: 600; display: inline-flex; align-items: center; gap: 8px; box-shadow: 0 3px 6px rgba(46, 204, 113, 0.2); animation: fadeInUp 0.5s var(--transition-timing) backwards; animation-delay: 0.2s; }
        .save-note-btn:hover { background-color: #27ae60; box-shadow: 0 5px 10px rgba(46, 204, 113, 0.3); transform: translateY(-1px); }
        .save-note-btn:active { transform: translateY(0px) scale(0.98); box-shadow: inset 0 1px 3px rgba(0,0,0,0.1); }
        #notes-feedback { font-size: 13px; color: var(--success-green); min-height: 1.2em; text-align: center; margin-bottom: 15px; font-weight: 500; transition: opacity 0.3s; opacity: 0; }
        #notes-feedback.visible { opacity: 1; }

        /* Gallery Screen */
        .gallery-screen { justify-content: flex-start; padding-bottom: 75px; }
        .gallery-container { display: grid; grid-template-columns: repeat(auto-fill, minmax(90px, 1fr)); gap: 12px; width: 100%; margin-top: 15px; animation: fadeInUpList 0.6s var(--transition-timing) backwards; animation-delay: 0.1s; }
        .gallery-item { position: relative; overflow: hidden; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); transition: transform 0.2s ease; }
        .gallery-item:hover { transform: scale(1.03); z-index: 5; }
        .gallery-item img { display: block; width: 100%; height: 90px; object-fit: cover; border-radius: 8px; border: 1px solid var(--light-gray); }
        .gallery-item .download-link { position: absolute; bottom: 6px; right: 6px; background-color: rgba(0,0,0,0.7); color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; justify-content: center; align-items: center; text-decoration: none; font-size: 11px; transition: background-color 0.2s, transform 0.2s; opacity: 0; transform: scale(0.8); }
        .gallery-item:hover .download-link { opacity: 1; transform: scale(1); }
        .gallery-item .download-link:hover { background-color: var(--rabbit-orange); transform: scale(1.1); }
        #gallery-empty-msg { font-style: italic; color: #999; text-align: center; width: 100%; margin-top: 30px; animation: fadeIn 0.5s ease; }

        /* --- Controls (Bottom) --- */
        .controls { display: flex; flex-direction: column; align-items: center; gap: 18px; width: 100%; padding-top: 5px; /* Add slight space above PTT */ }
        .ptt-button {
            width: 65px; height: 65px; border-radius: 50%;
            background: linear-gradient(145deg, var(--rabbit-orange), #ff9a33); /* Gradient PTT */
            border: none; display: flex; justify-content: center; align-items: center;
            cursor: pointer; color: white; font-size: 28px;
            box-shadow: 0 5px 15px rgba(255, 126, 0, 0.35), inset 0 -2px 3px rgba(0,0,0,0.1); /* Enhanced shadow */
            transition: transform 0.15s ease, background 0.2s, box-shadow 0.2s;
            user-select: none; -webkit-user-select: none; touch-action: manipulation;
            position: relative; /* For pseudo-elements */
            overflow: hidden;
            z-index: 20; /* Ensure PTT is above overlays */
        }
        .ptt-button::before { /* Subtle shine effect */
            content: ''; position: absolute; top: 0; left: -75%; width: 50%; height: 100%;
            background: linear-gradient(to right, rgba(255,255,255,0) 0%, rgba(255,255,255,0.3) 50%, rgba(255,255,255,0) 100%);
            transform: skewX(-25deg); transition: left 0.5s ease;
        }
        .ptt-button:not(:disabled):hover::before { left: 125%; }

        .ptt-button:active, .ptt-button.active {
            transform: scale(0.94);
            background: linear-gradient(145deg, var(--rabbit-orange-dark), var(--rabbit-orange));
            box-shadow: 0 3px 8px rgba(255, 126, 0, 0.3), inset 0 2px 4px rgba(0,0,0,0.15);
        }
        .ptt-button.active { animation: ptt-pulse 1.2s infinite ease-in-out; } /* Faster pulse */
        @keyframes ptt-pulse {
            0% { box-shadow: 0 3px 8px rgba(255, 126, 0, 0.3), inset 0 2px 4px rgba(0,0,0,0.15); }
            50% { box-shadow: 0 6px 18px rgba(255, 126, 0, 0.45), inset 0 2px 4px rgba(0,0,0,0.15); }
            100% { box-shadow: 0 3px 8px rgba(255, 126, 0, 0.3), inset 0 2px 4px rgba(0,0,0,0.15); }
        }
        .ptt-button:disabled { background: var(--medium-gray); cursor: not-allowed; box-shadow: none; transform: none; animation: none; opacity: 0.6; }
        .ptt-button:disabled:active { transform: none; }
        .ptt-button:disabled::before { display: none; }

        .scroll-controls { display: flex; gap: 25px; }
        .scroll-button {
            width: 42px; height: 42px; border-radius: 50%;
            background: linear-gradient(145deg, var(--medium-gray), var(--light-gray));
            border: none; display: flex; justify-content: center; align-items: center;
            cursor: pointer; color: var(--dark-gray);
            transition: all 0.2s ease;
            user-select: none; -webkit-user-select: none; touch-action: manipulation;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .scroll-button:hover {
            background: linear-gradient(145deg, var(--light-gray), var(--medium-gray));
            box-shadow: 0 4px 8px rgba(0,0,0,0.08);
            transform: translateY(-1px);
        }
        .scroll-button:active { transform: translateY(0px) scale(0.96); box-shadow: inset 0 1px 3px rgba(0,0,0,0.1); }

        /* --- Animation Keyframes --- */
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes fadeInScale {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }
        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes fadeInDown {
            from { opacity: 0; transform: translateY(-15px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes fadeInUpList { /* Staggered list items */
            from { opacity: 0; transform: translateY(15px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .alarms-list li, .gallery-item { /* Apply base for staggering */
            opacity: 0; animation: fadeInUpList 0.5s var(--transition-timing) forwards;
        }
        /* Example staggering (can be done with JS for more items) */
        .alarms-list li:nth-child(1), .gallery-item:nth-child(1) { animation-delay: 0.1s; }
        .alarms-list li:nth-child(2), .gallery-item:nth-child(2) { animation-delay: 0.15s; }
        .alarms-list li:nth-child(3), .gallery-item:nth-child(3) { animation-delay: 0.2s; }
        .alarms-list li:nth-child(4), .gallery-item:nth-child(4) { animation-delay: 0.25s; }
        /* etc. */

        @keyframes shake {
            10%, 90% { transform: translateX(-1px); }
            20%, 80% { transform: translateX(2px); }
            30%, 50%, 70% { transform: translateX(-3px); }
            40%, 60% { transform: translateX(3px); }
        }

        /* --- Responsive Adjustments --- */
        @media (max-width: 400px) {
            body { padding: 10px; }
            .device-container { max-width: 100%; }
            .rabbit-device { border-radius: 24px; padding: 15px; gap: 15px; }
            .main-display { border-radius: 16px; }
            .screen { padding: 20px; } /* Restore default padding */
            .home-screen { padding-top: 40px; } /* Adjust home padding */
            .status-bar { top: 8px; left: 10px; right: 10px; font-size: 10px; padding: 3px 6px; }
            .vision-screen, .look-at-this-screen { padding: 0; } /* Keep no padding for camera */
            .screen h2 { font-size: 20px; margin-bottom: 15px; }
            .vision-screen h2, .look-at-this-screen h2 { font-size: 14px; padding: 5px 10px; top: 10px; } /* Adjust title on camera */
            .greeting { font-size: 24px; }
            .instruction { font-size: 16px; }
            .timer-display { font-size: 30px; }
            .album-art { width: 120px; height: 120px; font-size: 45px; }
            .track-title { font-size: 16px; }
            .artist-name { font-size: 14px; }
            /* camera-container already full screen */
            .response-text { font-size: 14px; line-height: 1.6; }
            .response-text th, .response-text td { padding: 10px; }
            .gallery-container { grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 10px; }
            .gallery-item img { height: 80px; }
            .glass-overlay { padding: 8px 15px; border-radius: 12px; }
            .capture-btn, .look-capture-btn { font-size: 15px; padding: 9px 18px; }
            .vision-capture-overlay { bottom: 65px; } /* Adjust overlay positions for smaller screens */
            .look-capture-overlay { bottom: 65px; }
            .look-status-overlay { bottom: 115px; font-size: 13px; min-width: 180px; }
            .ptt-button { width: 60px; height: 60px; font-size: 26px; }
            .scroll-button { width: 40px; height: 40px; }
            .scroll-controls { gap: 20px; }
            .back-button { padding: 9px 18px; }
            .response-screen .back-button, .error-screen .back-button, .notes-screen .back-button,
            .gallery-screen .back-button { bottom: 15px; }
            .vision-screen .back-button, .look-at-this-screen .back-button { bottom: 15px; } /* Adjust camera back button */
        }

    </style>
</head>
<body>
    <div class="device-container">
        <div class="rabbit-device">
            <!-- Audio Player Element -->
            <audio id="audio-player" style="display: none;"></audio>

            <div class="main-display" id="main-display">

                <div class="screen home-screen active-screen" data-screen-name="home">
                    <div class="status-bar">
                        <span id="home-time">--:--:--</span>
                        <span id="home-date">--/--/----</span>
                        <span id="home-battery"><i class="fas fa-battery-half"></i> --%</span>
                    </div>
                    <div class="greeting">Bonjour...</div> <!-- Sera mis à jour par JS -->
                    <div class="instruction">Maintenez pour parler</div>
                    <div class="permission-status" id="permission-status">Vérification...</div>
                </div>

                <div class="screen listening-screen" data-screen-name="listening">
                    <div class="listening-indicator">
                        <div class="listening-text">Écoute en cours...</div>
                        <div class="waveform">
                            <span></span><span></span><span></span><span></span><span></span>
                        </div>
                    </div>
                </div>

                <div class="screen response-screen" data-screen-name="response">
                    <div class="query-text" id="query-text"></div>
                    <div class="response-text" id="response-text"></div>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                <div class="screen alarms-screen" data-screen-name="alarms">
                    <h2>Alarmes</h2>
                    <ul class="alarms-list">
                        <li>7:00 - Réveil</li>
                        <li>12:30 - Déjeuner</li>
                        <li>18:00 - Sport</li>
                    </ul>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                <div class="screen timer-screen" data-screen-name="timer">
                    <h2>Minuteur</h2>
                    <div class="timer-display" id="timer-display">00:00</div>
                    <div class="timer-controls">
                        <button class="timer-btn" id="timer-start" aria-label="Démarrer le minuteur">Démarrer</button>
                        <button class="timer-btn" id="timer-reset" aria-label="Réinitialiser le minuteur">Réinitialiser</button>
                    </div>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                <div class="screen music-screen" data-screen-name="music">
                    <h2>Musique</h2>
                    <div class="album-art" role="img" aria-label="Pochette d'album">
                         <i class="fas fa-music"></i> <!-- Default Icon -->
                    </div>
                    <div class="track-info">
                        <div class="track-title" id="track-title">Aucune musique</div>
                        <div class="artist-name" id="artist-name">Appuyez sur Play</div>
                    </div>
                    <div class="music-controls">
                        <button class="music-btn" id="prev-track" aria-label="Piste précédente"><i class="fas fa-step-backward"></i></button>
                        <button class="music-btn" id="play-pause" aria-label="Lecture">
                            <!-- Icons are absolutely positioned and toggled via CSS -->
                            <i class="fas fa-play"></i>
                            <i class="fas fa-pause"></i>
                        </button>
                        <button class="music-btn" id="next-track" aria-label="Piste suivante"><i class="fas fa-step-forward"></i></button>
                    </div>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                <div class="screen vision-screen" data-screen-name="vision">
                    <h2>Vision</h2>
                    <div class="camera-container" id="vision-camera-container">
                        <i class="fas fa-camera placeholder-icon"></i>
                        <div class="glass-overlay vision-capture-overlay">
                             <button class="capture-btn" id="vision-capture-btn" aria-label="Capturer l'image">
                                 <i class="fas fa-camera"></i> Capturer
                             </button>
                        </div>
                    </div>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                <div class="screen calendar-screen" data-screen-name="calendar">
                    <h2>Calendrier</h2>
                    <div class="calendar-placeholder">Placeholder Calendrier</div>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                <div class="screen notes-screen" data-screen-name="notes">
                    <h2>Notes</h2>
                    <textarea id="notes-textarea" class="notes-textarea" placeholder="Écrivez vos notes ici..."></textarea>
                    <button id="save-note-btn" class="save-note-btn"><i class="fas fa-save"></i> Enregistrer</button>
                    <div id="notes-feedback"></div>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                <div class="screen gallery-screen" data-screen-name="gallery">
                    <h2>Galerie Photos</h2>
                    <div id="gallery-container" class="gallery-container">
                        <!-- Images ajoutées par JS -->
                    </div>
                    <p id="gallery-empty-msg" style="display: none;">Aucune photo capturée.</p>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                 <div class="screen look-at-this-screen" data-screen-name="look_and_ask">
                     <h2>Regarder & Demander</h2>
                     <div class="camera-container" id="look-camera-container">
                         <i class="fas fa-camera placeholder-icon"></i>
                         <div class="glass-overlay look-status-overlay" id="look-status-text">
                             Visez, puis capturez l'image.
                         </div>
                         <div class="glass-overlay look-capture-overlay">
                             <button class="look-capture-btn" id="look-capture-btn" aria-label="Capturer l'image pour l'IA">
                                 <i class="fas fa-camera"></i> Capturer
                             </button>
                         </div>
                     </div>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                 </div>

                <div class="screen error-screen" data-screen-name="error">
                    <h2><i class="fas fa-exclamation-triangle"></i> Erreur</h2>
                    <p id="error-message">Une erreur s'est produite.</p>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

            </div>

            <div class="controls">
                <button class="ptt-button" id="ptt-button" aria-label="Maintenir pour parler" aria-pressed="false" disabled>
                    <i class="fas fa-microphone"></i>
                </button>
                <div class="scroll-controls">
                    <button class="scroll-button" id="scroll-up" aria-label="Faire défiler vers le haut">
                        <i class="fas fa-chevron-up"></i>
                    </button>
                    <button class="scroll-button" id="scroll-down" aria-label="Faire défiler vers le bas">
                        <i class="fas fa-chevron-down"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Elements ---
            const mainDisplay = document.getElementById('main-display');
            const pttButton = document.getElementById('ptt-button');
            const scrollUpButton = document.getElementById('scroll-up');
            const scrollDownButton = document.getElementById('scroll-down');
            const queryTextElement = document.getElementById('query-text');
            const responseTextElement = document.getElementById('response-text');
            const permissionStatusElement = document.getElementById('permission-status');
            const errorMessageElement = document.getElementById('error-message');
            const greetingElement = document.querySelector('.home-screen .greeting');
            const homeTimeElement = document.getElementById('home-time');
            const homeDateElement = document.getElementById('home-date');
            const homeBatteryElement = document.getElementById('home-battery');

            // Screen elements map
            const screens = {};
            document.querySelectorAll('.screen').forEach(screen => {
                const screenName = screen.dataset.screenName;
                if (screenName) screens[screenName] = screen;
            });

            // --- Screen Navigation Order ---
            const screenOrder = [
                'home', 'calendar', 'notes', 'gallery', 'alarms',
                'timer', 'music', 'vision', 'look_and_ask'
            ];
            let currentScreenIndex = 0;

            // --- State Variables ---
            let userName = 'Utilisateur'; // Default name
            let isListening = false;
            let recognitionActive = false;
            let speechPromiseCallbacks = null;
            let recognition = null;
            let speechApiAvailable = false;
            let permissionGranted = null; // null, true, false
            let conversationHistory = [];
            let lastInteractionTime = Date.now();
            const CONTEXT_TIMEOUT = 5 * 60 * 1000; // 5 minutes context

            // Timer Elements & State
            const timerStartButton = document.getElementById('timer-start');
            const timerResetButton = document.getElementById('timer-reset');
            const timerDisplayElement = document.getElementById('timer-display');
            let timerInterval = null;
            let timerSeconds = 0;
            let isTimerRunning = false;

            // Music Elements & State
            const audioPlayer = document.getElementById('audio-player');
            const playPauseButton = document.getElementById('play-pause');
            const prevTrackButton = document.getElementById('prev-track');
            const nextTrackButton = document.getElementById('next-track');
            const trackTitleElement = document.getElementById('track-title');
            const artistNameElement = document.getElementById('artist-name');
            let currentTrackIndex = 0;
            let isMusicPlaying = false;
            // !!! REMPLACEZ CES URLS PAR LES VÔTRES !!!
            const playlist = [
                 { title: "Titre Chanson 1", artist: "Artiste 1", src: "URL_VERS_VOTRE_MUSIQUE_1.mp3" },
                 { title: "Titre Chanson 2", artist: "Artiste 2", src: "URL_VERS_VOTRE_MUSIQUE_2.mp3" },
                 // Ajoutez d'autres chansons ici
            ];

            // Vision (Simple Capture) Elements
            const visionCaptureButton = document.getElementById('vision-capture-btn');
            const visionCameraContainer = document.getElementById('vision-camera-container');

            // Notes Elements
            const notesTextarea = document.getElementById('notes-textarea');
            const saveNoteButton = document.getElementById('save-note-btn');
            const notesFeedback = document.getElementById('notes-feedback');

            // Gallery Elements
            const galleryContainer = document.getElementById('gallery-container');
            const galleryEmptyMsg = document.getElementById('gallery-empty-msg');
            let capturedPhotos = []; // In-memory storage for demo

            // Look & Ask (Multimodal) Elements & State
            const lookCameraContainer = document.getElementById('look-camera-container');
            const lookCaptureButton = document.getElementById('look-capture-btn');
            const lookStatusText = document.getElementById('look-status-text');
            let capturedImageDataForPrompt = null; // Base64 image data
            let isMultimodalPrompt = false; // Flag for PTT handler

            // Shared Media Elements
            let videoStream = null;
            const videoElement = document.createElement('video');
            videoElement.setAttribute('playsinline', ''); // Important for iOS
            videoElement.classList.add('live-video');
            const canvasElement = document.createElement('canvas');

            // --- Configuration ---
            // WARNING: Storing API keys client-side is insecure. Use a backend proxy in production.
             const GEMINI_API_KEY = 'AIzaSyBW5xJAUSzhJP5n5p8znA39QFDR8JqtwPY'; // REPLACE WITH YOUR ACTUAL KEY
            const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`;
            const GEMINI_SAFETY_SETTINGS = [
                { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
            ];

            // --- System Instruction for Gemini (Updated) ---
            // Note: userName, date, time are added dynamically to the prompt now
            const SYSTEM_INSTRUCTION = `Tu es un assistant vocal intégré dans une interface web simulant un appareil Rabbit R1. Ton nom est Rabbit. Tu réponds à l'utilisateur actuel (dont le nom est fourni dans le contexte).
            La date et l'heure actuelles sont fournies dans le contexte.
            Tu peux répondre aux questions et exécuter certaines actions. Tu peux afficher du texte formaté en Markdown (listes, gras, italique, titres, blocs de code, tableaux simples). Pour les questions simples ne nécessitant pas d'action, réponds directement en texte. Sois concis et direct.
            Pour exécuter une action, commence ta réponse EXACTEMENT par "% nom_fonction %" suivi de ta réponse textuelle normale. Ne mets rien avant le %. N'utilise qu'une seule commande de fonction par réponse.
            Les fonctions disponibles sont :
            - % start_timer % : Démarre ou reprend le minuteur.
            - % reset_timer % : Réinitialise le minuteur.
            - % play_music % : Lance la lecture de la musique (si en pause ou arrêtée).
            - % pause_music % : Met la musique en pause (si en lecture).
            - % play_pause_music % : Met en lecture ou en pause la musique (bascule).
            - % prev_track % : Passe à la piste précédente.
            - % next_track % : Passe à la piste suivante.
            - % capture_image % : Prend une photo simple (depuis l'écran Vision) et l'ajoute à la galerie. Doit être sur l'écran Vision. Confirme.
            - % go_home % : Affiche l'écran d'accueil.
            - % show_alarms % : Affiche l'écran des alarmes.
            - % show_timer % : Affiche l'écran du minuteur.
            - % show_music % : Affiche l'écran de musique.
            - % show_vision % : Affiche l'écran de vision (pour capture simple).
            - % show_calendar % : Affiche l'écran du calendrier (placeholder).
            - % show_notes % : Affiche l'écran des notes et charge la dernière note sauvegardée.
            - % save_current_note % : Sauvegarde le texte dans la zone de notes. Confirme.
            - % show_gallery % : Affiche la galerie des photos capturées.
            - % look_and_ask % : Active le mode caméra spécial pour analyser une image. Réponds avec un texte invitant l'utilisateur.
            Adapte ta réponse textuelle après la commande pour confirmer l'action ou répondre à la question.`;

            // --- Core Functions ---

             /** Switches the active screen with animations. */
             async function switchScreen(screenName) {
                 console.log(`Switching to screen: ${screenName}`);
                 const currentActiveScreen = document.querySelector('.screen.active-screen');
                 const targetScreen = screens[screenName];

                 if (!targetScreen) {
                     console.error(`Screen "${screenName}" not found. Switching to home.`);
                     screenName = 'home';
                     targetScreen = screens.home;
                 }

                 if (currentActiveScreen === targetScreen) return;

                 const previousScreenName = currentActiveScreen?.dataset.screenName;

                 // Deactivate current screen
                 if (currentActiveScreen) {
                     currentActiveScreen.classList.remove('active-screen');
                 }

                 // Activate target screen
                 targetScreen.classList.add('active-screen');

                 // Update current index for scroll navigation
                 const navigableIndex = screenOrder.indexOf(screenName);
                 if (navigableIndex !== -1) currentScreenIndex = navigableIndex;

                 // Handle screen-specific actions AFTER transition starts
                 if (screenName === 'response') screens.response.scrollTop = 0;
                 if (screenName === 'gallery') displayGallery(); // Refresh gallery view
                 if (screenName === 'notes') loadNote(); // Load note when entering

                 // --- Camera Management ---
                 const needsCamera = ['vision', 'look_and_ask'].includes(screenName);
                 const cameraWasActive = ['vision', 'look_and_ask'].includes(previousScreenName);

                 // Detach video from previous container immediately if it exists
                 if (cameraWasActive && videoElement.parentElement) {
                     const oldContainer = videoElement.parentElement;
                     videoElement.classList.remove('active'); // Start fade out
                     videoElement.remove(); // Detach
                     oldContainer.classList.remove('video-active');
                     oldContainer.querySelector('.placeholder-icon')?.style.removeProperty('display');
                 }

                 if (needsCamera) {
                     await startVideoStream(screenName);
                 } else if (cameraWasActive) {
                     stopVideoStream(); // Stop stream fully if leaving a camera screen
                 }

                 // Reset multimodal state if leaving look_and_ask screen
                  if (previousScreenName === 'look_and_ask' && screenName !== 'look_and_ask') {
                      resetLookAskState();
                  }
             }

             /** Displays an error message on the dedicated error screen or fallback. */
             function showErrorScreen(message) {
                 console.error("Displaying error:", message);
                 if (errorMessageElement && screens.error) {
                     errorMessageElement.textContent = message;
                     switchScreen('error');
                 } else {
                     console.error("Error screen elements not found. Fallback display.");
                     switchScreen('response'); // Fallback to response screen
                     queryTextElement.textContent = "Erreur";
                     responseTextElement.innerHTML = `<p class="error-message">${message}</p>`;
                 }
                 lastInteractionTime = Date.now();
             }

             /** Updates the permission status message on the home screen. */
             function updatePermissionStatus(message, isError = false) {
                 if (permissionStatusElement) {
                     permissionStatusElement.textContent = message;
                     permissionStatusElement.classList.toggle('error', isError);
                     console.log(`Permission status updated: "${message}" (isError: ${isError})`);
                 }
             }

             /** Gets user name from storage or prompt */
             function getUserName() {
                let storedName = null;
                try {
                   storedName = localStorage.getItem('rabbitUserName');
                } catch (e) {
                    console.warn("localStorage access denied or failed:", e);
                }

                if (storedName) {
                    userName = storedName;
                    console.log("User name loaded from localStorage:", userName);
                } else {
                    const nameFromPrompt = prompt("Quel est votre nom ?", "Utilisateur");
                    // Simple validation: use default if prompt is cancelled or empty
                    userName = nameFromPrompt && nameFromPrompt.trim() ? nameFromPrompt.trim() : 'Utilisateur';
                    try {
                        localStorage.setItem('rabbitUserName', userName);
                        console.log("User name saved to localStorage:", userName);
                    } catch (e) {
                        console.warn("localStorage access denied or failed:", e);
                    }
                }
                if (greetingElement) {
                    greetingElement.textContent = `Bonjour ${userName}`;
                } else {
                     console.warn("Greeting element not found.");
                }
             }

            // --- Date/Time & Battery Update ---
            function updateDateTime() {
                const now = new Date();
                if (homeTimeElement) {
                    homeTimeElement.textContent = now.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });
                }
                if (homeDateElement) {
                    homeDateElement.textContent = now.toLocaleDateString('fr-FR', { day: '2-digit', month: '2-digit', year: 'numeric' });
                }
            }

            function updateBatteryStatus() {
                if ('getBattery' in navigator) {
                    navigator.getBattery().then(battery => {
                        const level = Math.floor(battery.level * 100);
                        const charging = battery.charging;

                        if (homeBatteryElement) {
                            let iconClass = 'fa-battery-empty';
                            if (level > 95) iconClass = 'fa-battery-full';
                            else if (level > 70) iconClass = 'fa-battery-three-quarters';
                            else if (level > 40) iconClass = 'fa-battery-half';
                            else if (level > 15) iconClass = 'fa-battery-quarter';

                            // Update icon and text
                            homeBatteryElement.innerHTML = `<i class="fas ${iconClass}"></i> ${level}% ${charging ? '<i class="fas fa-plug"></i>' : ''}`;
                        }

                        // Listen for changes
                        battery.addEventListener('levelchange', updateBatteryStatus);
                        battery.addEventListener('chargingchange', updateBatteryStatus);

                    }).catch(err => {
                        console.warn("Battery API error:", err);
                        if (homeBatteryElement) homeBatteryElement.textContent = 'N/A';
                    });
                } else {
                    console.warn("Battery Status API not supported.");
                    if (homeBatteryElement) homeBatteryElement.innerHTML = `<i class="fas fa-battery-slash"></i> N/A`; // Show unsupported icon
                }
            }

            // --- Speech Recognition ---
            async function initializeSpeechRecognition() {
                 console.log("Initializing Speech Recognition...");
                 updatePermissionStatus("Initialisation...");

                 const SpeechRecognitionAPI = window.SpeechRecognition || window.webkitSpeechRecognition;
                 if (!SpeechRecognitionAPI) { updatePermissionStatus("Reconnaissance vocale non supportée.", true); return false; }
                 if (window.location.protocol !== 'https:' && !['localhost', '127.0.0.1'].includes(window.location.hostname)) { updatePermissionStatus("Connexion non sécurisée (HTTPS requis).", true); return false; }
                 if (!navigator.mediaDevices?.getUserMedia) { updatePermissionStatus("Accès aux périphériques média impossible.", true); return false; }

                 // Request Permissions
                 try {
                     updatePermissionStatus("Demande des permissions...");
                     const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true }); // Request both
                     permissionGranted = true;
                     updatePermissionStatus("Microphone et caméra prêts.");
                     stream.getTracks().forEach(track => track.stop()); // Stop the temporary stream

                     if (navigator.permissions?.query) {
                           const handlePermissionChange = (status, type) => {
                               console.log(`${type} permission state changed: ${status.state}`);
                               const isMic = type === 'microphone';
                               const currentlyGranted = status.state === 'granted';
                               if (isMic) permissionGranted = currentlyGranted;

                               updatePermissionStatus(currentlyGranted ? "Microphone et caméra prêts." : `Accès ${type} refusé.`, !currentlyGranted);
                               if (isMic) pttButton.disabled = !currentlyGranted;
                               if (!currentlyGranted) {
                                   if (isMic && recognitionActive) recognition?.abort();
                                   stopVideoStream();
                               }
                           };
                           try {
                               const micStatus = await navigator.permissions.query({ name: 'microphone' });
                               micStatus.onchange = () => handlePermissionChange(micStatus, 'microphone');
                               const camStatus = await navigator.permissions.query({ name: 'camera' });
                               camStatus.onchange = () => handlePermissionChange(camStatus, 'camera');
                           } catch (e) { console.warn("Permission query API not fully supported or failed:", e); }
                     }

                 } catch (err) {
                     permissionGranted = false;
                     let userMessage = "Impossible d'accéder aux périphériques.";
                     if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') userMessage = "Accès microphone/caméra refusé.";
                     else if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') userMessage = "Aucun microphone/caméra trouvé.";
                     else if (err.name === 'NotReadableError') userMessage = "Périphérique déjà utilisé ou problème matériel.";
                     else userMessage = `Erreur accès périphériques: ${err.name}`;
                     updatePermissionStatus(userMessage, true);
                     return false;
                 }

                 // Initialize SpeechRecognition Instance
                 try {
                     recognition = new SpeechRecognitionAPI();
                     recognition.lang = 'fr-FR';
                     recognition.continuous = true;
                     recognition.interimResults = false;
                     speechApiAvailable = true;
                     if (pttButton) pttButton.disabled = false;

                     let currentTranscript = '';
                     recognition.onstart = () => {
                         console.log("SpeechRecognition: onstart");
                         recognitionActive = true; currentTranscript = '';
                         pttButton?.classList.add('active');
                         const currentScreen = document.querySelector('.screen.active-screen')?.dataset.screenName;
                         if (currentScreen === 'look_and_ask') { lookStatusText.textContent = "Écoute en cours..."; }
                         else { switchScreen('listening'); }
                     };
                     recognition.onresult = (event) => {
                         let segment = '';
                         for (let i = event.resultIndex; i < event.results.length; ++i) {
                             if (event.results[i].isFinal) segment += event.results[i][0].transcript + ' ';
                         }
                         if (segment) currentTranscript += segment;
                         console.log("Transcript final accumulé:", currentTranscript.trim());
                     };
                     recognition.onerror = (event) => {
                         console.error(`SpeechRecognition: onerror - ${event.error}`, event.message);
                         recognitionActive = false; pttButton?.classList.remove('active');
                         let userMessage = `Erreur reconnaissance: ${event.error}`;
                         if (event.error === 'not-allowed') { permissionGranted = false; updatePermissionStatus("Accès microphone refusé.", true); pttButton.disabled = true; userMessage = "Accès microphone refusé."; }
                         else if (event.error === 'no-speech') userMessage = "Je n'ai rien entendu.";
                         else if (event.error === 'audio-capture') userMessage = "Problème capture audio.";
                         else if (event.error === 'network') userMessage = "Erreur réseau reconnaissance.";

                         if (speechPromiseCallbacks?.reject && event.error !== 'aborted') { speechPromiseCallbacks.reject(new Error(userMessage)); }
                         else if (event.error !== 'aborted') {
                             const currentScreen = document.querySelector('.screen.active-screen')?.dataset.screenName;
                             if (currentScreen === 'look_and_ask') { lookStatusText.textContent = userMessage; setTimeout(resetLookAskState, 3000); }
                             else { showErrorScreen(userMessage); }
                         }
                         speechPromiseCallbacks = null; isListening = false;
                     };
                     recognition.onend = () => {
                         console.log("SpeechRecognition: onend");
                         recognitionActive = false; pttButton?.classList.remove('active');
                         if (speechPromiseCallbacks?.resolve) speechPromiseCallbacks.resolve(currentTranscript.trim());
                         speechPromiseCallbacks = null;
                         const currentScreen = document.querySelector('.screen.active-screen')?.dataset.screenName;
                         if (currentScreen === 'look_and_ask' && lookStatusText.textContent === "Écoute en cours...") {
                             lookStatusText.textContent = "Traitement...";
                         }
                     };
                 } catch (error) { console.error("Error initializing SpeechRecognition instance:", error); updatePermissionStatus("Erreur init reconnaissance.", true); return false; }
                 return true; // Success
             }

            /** Starts the speech recognition process, returning a promise. */
            async function startSpeechRecognition() {
                return new Promise(async (resolve, reject) => {
                    if (!speechApiAvailable || !recognition) return reject(new Error("Reco. non initialisée."));
                    if (recognitionActive) return reject(new Error("Écoute déjà en cours."));
                    if (permissionGranted === false) return reject(new Error("Accès microphone refusé."));

                    // Quick permission re-check
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                        stream.getTracks().forEach(track => track.stop());
                        permissionGranted = true; if (pttButton) pttButton.disabled = false;
                    } catch (err) {
                        permissionGranted = false; updatePermissionStatus("Accès microphone refusé.", true); if (pttButton) pttButton.disabled = true;
                        return reject(new Error("Accès microphone refusé."));
                    }

                    console.log("Attempting to start listening...");
                    speechPromiseCallbacks = { resolve, reject };
                    try {
                        recognition.start();
                    } catch (e) {
                        console.error("Immediate error on recognition.start():", e);
                        recognitionActive = false; speechPromiseCallbacks = null;
                        reject(new Error(`Erreur démarrage reco: ${e.message || e.name}`));
                    }
                });
            }

            // --- PTT Button Handlers ---
            function handlePttStart(event) {
                event.preventDefault();
                console.log("PTT Start");
                if (!speechApiAvailable || permissionGranted === false) { console.warn("PTT ignored: API/Permission issue."); return; }
                if (isListening || recognitionActive) { console.warn("PTT ignored: Already listening."); return; }

                // Check for multimodal context
                const currentScreen = document.querySelector('.screen.active-screen')?.dataset.screenName;
                isMultimodalPrompt = (currentScreen === 'look_and_ask' && !!capturedImageDataForPrompt);
                if (currentScreen === 'look_and_ask' && !capturedImageDataForPrompt) {
                    console.warn("PTT on Look&Ask screen but no image captured yet.");
                    lookStatusText.textContent = "Veuillez d'abord capturer une image.";
                    lookCaptureButton.style.animation = 'shake 0.5s ease';
                    setTimeout(() => { lookCaptureButton.style.animation = ''; }, 500);
                    return; // Don't start listening without image
                }

                isListening = true;
                pttButton?.setAttribute('aria-pressed', 'true');

                startSpeechRecognition()
                    .then(result => {
                        console.log("Recognition promise resolved.");
                        processSpeechResult(result); // Process the final transcript
                    })
                    .catch(error => {
                        console.error("Recognition promise rejected:", error);
                         if (!error.message.includes("reconnaissance") && !error.message.includes("microphone") && !error.message.includes("entendu")) {
                             if (isMultimodalPrompt) { lookStatusText.textContent = `Erreur: ${error.message}`; setTimeout(resetLookAskState, 3000); }
                             else { showErrorScreen(error.message); }
                         }
                        isListening = false; pttButton?.classList.remove('active'); pttButton?.setAttribute('aria-pressed', 'false');
                        isMultimodalPrompt = false; // Reset flag on error
                    });
            }

            function handlePttEnd(event) {
                event.preventDefault();
                console.log("PTT End");
                if (!isListening) { console.warn("PTT End ignored: Not listening."); return; }
                isListening = false;
                pttButton?.setAttribute('aria-pressed', 'false');

                if (recognitionActive && recognition) {
                    console.log("Stopping recognition via recognition.stop()...");
                    try {
                        recognition.stop(); // Triggers onend
                    } catch (e) {
                        console.error("Error on recognition.stop():", e);
                        if (speechPromiseCallbacks?.reject) speechPromiseCallbacks.reject(new Error("Échec arrêt reco."));
                        speechPromiseCallbacks = null;
                        if (isMultimodalPrompt) { lookStatusText.textContent = "Erreur lors de l'arrêt."; setTimeout(resetLookAskState, 3000); }
                        else { showErrorScreen("Erreur lors de l'arrêt de l'écoute."); }
                        isMultimodalPrompt = false;
                    }
                } else {
                    console.warn("PTT End: Recognition not active or already stopped.");
                    if (speechPromiseCallbacks?.reject) speechPromiseCallbacks.reject(new Error("Écoute terminée prématurément."));
                    speechPromiseCallbacks = null;
                    isMultimodalPrompt = false;
                }
            }

            /** Processes the final speech result, calls Gemini, and handles the response. */
            async function processSpeechResult(result) {
                console.log("Processing final speech result:", result);
                lastInteractionTime = Date.now(); // Update context timer

                const wasMultimodal = isMultimodalPrompt;
                const imageForPrompt = capturedImageDataForPrompt;

                // Reset multimodal state early, API call handles its own logic
                if (wasMultimodal) {
                    lookStatusText.textContent = "Traitement...";
                } else {
                    switchScreen('response'); // Switch to response screen for normal queries
                }

                if (result instanceof Error) {
                    queryTextElement.textContent = "Erreur de reconnaissance";
                    responseTextElement.innerHTML = `<p class="error-message">${result.message}</p>`;
                    if (wasMultimodal) { lookStatusText.textContent = `Erreur: ${result.message}`; setTimeout(resetLookAskState, 3000); switchScreen('response'); } // Show error on response screen
                } else if (typeof result === 'string') {
                    const query = result.trim();
                    queryTextElement.textContent = query || "[Aucun texte reconnu]"; // Show query

                    if (!query) {
                        const noUnderstandMsg = "<p>Je n'ai pas compris ou rien entendu. Veuillez réessayer.</p>";
                        responseTextElement.innerHTML = noUnderstandMsg;
                        if (wasMultimodal) {
                            lookStatusText.textContent = "Rien entendu. Réessayez.";
                            lookCaptureButton.disabled = true; // Keep disabled
                        }
                    } else {
                        // Show loading indicator
                        if (!wasMultimodal) {
                            responseTextElement.innerHTML = `<div class="loading-indicator"><div class="spinner medium"></div><i>Réflexion en cours...</i></div>`;
                        } else {
                             // Status already shows "Traitement..."
                        }

                        // Call API (normal or multimodal)
                        if (GEMINI_API_KEY && GEMINI_API_KEY !== 'YOUR_API_KEY') {
                            try {
                                let answer;
                                const currentDateTime = new Date().toLocaleString('fr-FR');
                                const contextPrefix = `[Contexte: Utilisateur=${userName}, Date/Heure=${currentDateTime}]`;
                                const fullQuery = `${contextPrefix} ${query}`; // Add context to the query

                                if (wasMultimodal && imageForPrompt) {
                                    console.log("Calling Gemini with Image and Text (with context)");
                                    answer = await queryGeminiWithImage(fullQuery, imageForPrompt);
                                    // Switch to response screen AFTER getting the multimodal response
                                    switchScreen('response');
                                } else {
                                    console.log("Calling Gemini with Text only (with context)");
                                    answer = await queryGemini(fullQuery, query); // Pass original query for history
                                }
                                processApiResponse(answer); // Process function calls/text and display
                            } catch (geminiError) {
                                console.error("Gemini API call error:", geminiError);
                                const errorHtml = `<p class="error-message">Erreur IA : ${geminiError.message}</p>`;
                                responseTextElement.innerHTML = errorHtml; // Display error on response screen
                                if (wasMultimodal) {
                                    lookStatusText.textContent = `Erreur IA: ${geminiError.message}`;
                                    setTimeout(resetLookAskState, 3500);
                                    switchScreen('response');
                                }
                            } finally {
                                // Clean up multimodal state fully AFTER API call attempt
                                if (wasMultimodal) {
                                    setTimeout(resetLookAskState, 100);
                                }
                            }
                        } else {
                            // No API Key
                            const noApiKeyMsg = "<p><i>(Fonctionnalité IA non configurée - Veuillez ajouter votre clé API dans le code JS)</i></p>";
                            responseTextElement.innerHTML = noApiKeyMsg;
                            addToHistory('user', query); // Add user's original query to history
                            addToHistory('model', "(Fonctionnalité IA non configurée)");
                            if (wasMultimodal) {
                                lookStatusText.textContent = "Fonctionnalité IA non configurée.";
                                setTimeout(resetLookAskState, 3000);
                                switchScreen('response');
                            }
                        }
                    }
                } else {
                    // Unexpected result type
                    const unexpectedMsg = '<p class="error-message">Problème inattendu (traitement voix).</p>';
                    queryTextElement.textContent = "Erreur Inattendue"; responseTextElement.innerHTML = unexpectedMsg;
                    if (wasMultimodal) { lookStatusText.textContent = "Erreur inattendue."; setTimeout(resetLookAskState, 3000); switchScreen('response'); }
                }
                // Ensure flags are reset
                 isMultimodalPrompt = false;
            }

            // --- Context and Function Calling ---

            /** Adds a message to the conversation history. */
            function addToHistory(role, text) {
                 // Keep history concise, maybe limit length
                 if (conversationHistory.length > 10) {
                     conversationHistory = conversationHistory.slice(-10); // Keep last 10 turns (user+model)
                 }
                 conversationHistory.push({ role, parts: [{ text }] });
                 console.log("Added to history:", { role, text: text.substring(0, 60) + '...' });
            }
            /** Checks context timeout and clears history if needed. */
            function checkContextTimeout() {
                 const now = Date.now();
                 if (now - lastInteractionTime > CONTEXT_TIMEOUT) {
                     console.log("Context timeout. Clearing conversation history.");
                     conversationHistory = [];
                 }
            }
            /** Executes a local function based on the name provided by the AI. */
            function executeFunction(functionName) {
                 console.log(`Executing function: ${functionName}`);
                 try {
                     switch (functionName) {
                         case 'start_timer': if (timerStartButton && !isTimerRunning) timerStartButton.click(); break;
                         case 'reset_timer': timerResetButton?.click(); break;
                         case 'play_music': if (!isMusicPlaying) playMusic(); break; // Only play if not playing
                         case 'pause_music': if (isMusicPlaying) pauseMusic(); break; // Only pause if playing
                         case 'play_pause_music': togglePlayPause(); break; // Use toggle function
                         case 'prev_track': prevTrack(); break; // Use dedicated function
                         case 'next_track': nextTrack(); break; // Use dedicated function
                         case 'capture_image':
                             if (document.querySelector('.screen.active-screen')?.dataset.screenName === 'vision') {
                                 visionCaptureButton?.click();
                             } else {
                                 console.warn("Capture_image called outside Vision screen.");
                                 // Optional: Switch first?
                                 // switchScreen('vision');
                                 // setTimeout(() => visionCaptureButton?.click(), 500);
                             }
                             break;
                         case 'go_home': switchScreen('home'); break;
                         case 'show_alarms': switchScreen('alarms'); break;
                         case 'show_timer': switchScreen('timer'); break;
                         case 'show_music': switchScreen('music'); break;
                         case 'show_vision': switchScreen('vision'); break;
                         case 'show_calendar': switchScreen('calendar'); break;
                         case 'show_notes': switchScreen('notes'); break;
                         case 'save_current_note': saveNote(); break;
                         case 'show_gallery': switchScreen('gallery'); break;
                         case 'look_and_ask': switchScreen('look_and_ask'); break;

                         default: console.warn(`Function "${functionName}" not recognized.`);
                     }
                 } catch (error) { console.error(`Error executing function "${functionName}":`, error); }
            }
            /** Processes the API response, handles function calls, and displays text. */
            function processApiResponse(apiResponseText) {
                const functionCallRegex = /^\s*%\s*([a-zA-Z0-9_]+)\s*%([\s\S]*)/;
                const match = apiResponseText.match(functionCallRegex);
                let displayText = apiResponseText;

                if (match) {
                    const functionName = match[1].trim();
                    const remainingText = match[2].trim();
                    console.log(`Function call detected: ${functionName}`);
                    executeFunction(functionName);
                    // Use remaining text if available, otherwise provide a generic confirmation
                    displayText = remainingText || `(Action ${functionName} exécutée)`;
                }

                // Display the textual part of the response
                displayMarkdownResponse(displayText, responseTextElement);

                // Add the RAW model response to history for context
                addToHistory('model', apiResponseText);
                lastInteractionTime = Date.now(); // Update context timer after response
            }

             // --- Utility Functions (Timer) ---
             function formatTime(seconds) { return `${Math.floor(seconds / 60).toString().padStart(2, '0')}:${(seconds % 60).toString().padStart(2, '0')}`; }
             timerStartButton?.addEventListener('click', () => {
                 if (!timerDisplayElement) return;
                 if (isTimerRunning) {
                     clearInterval(timerInterval);
                     timerStartButton.textContent = 'Reprendre';
                     timerDisplayElement.classList.remove('running');
                 } else {
                     timerStartButton.textContent = 'Pause';
                     timerDisplayElement.classList.add('running');
                     if (timerSeconds === 0) { // Only increment if starting from 0 or paused at 0
                        timerSeconds++;
                        timerDisplayElement.textContent = formatTime(timerSeconds);
                     } else if (timerSeconds > 0) { // Resume normally if paused > 0
                         // Display current time immediately before interval starts
                         timerDisplayElement.textContent = formatTime(timerSeconds);
                     }

                     timerInterval = setInterval(() => {
                         timerSeconds++;
                         timerDisplayElement.textContent = formatTime(timerSeconds);
                     }, 1000);
                 }
                 isTimerRunning = !isTimerRunning;
                 timerStartButton.setAttribute('aria-label', isTimerRunning ? 'Mettre le minuteur en pause' : 'Reprendre le minuteur');
             });
             timerResetButton?.addEventListener('click', () => {
                 if (!timerDisplayElement || !timerStartButton) return;
                 clearInterval(timerInterval); timerSeconds = 0; isTimerRunning = false;
                 timerDisplayElement.textContent = formatTime(timerSeconds);
                 timerStartButton.textContent = 'Démarrer';
                 timerStartButton.setAttribute('aria-label', 'Démarrer le minuteur');
                 timerDisplayElement.classList.remove('running');
             });

             // --- Music Player Logic ---
             function loadTrack(index) {
                if (!audioPlayer || !playlist || playlist.length === 0) return;
                currentTrackIndex = (index + playlist.length) % playlist.length; // Wrap around
                const track = playlist[currentTrackIndex];
                audioPlayer.src = track.src;
                if (trackTitleElement) trackTitleElement.textContent = track.title;
                if (artistNameElement) artistNameElement.textContent = track.artist;
                console.log(`Loading track ${currentTrackIndex}: ${track.title}`);
                // Reset button state visually
                playPauseButton?.classList.remove('playing');
                playPauseButton?.setAttribute('aria-label', 'Lecture');
                isMusicPlaying = false;
             }

             function playMusic() {
                if (!audioPlayer || !playPauseButton) return;
                audioPlayer.play().then(() => {
                    isMusicPlaying = true;
                    playPauseButton.classList.add('playing');
                    playPauseButton.setAttribute('aria-label', 'Pause');
                    console.log("Music playing");
                }).catch(error => {
                    console.error("Error playing audio:", error);
                    // Handle potential errors (e.g., user interaction needed on mobile)
                    showErrorScreen("Lecture audio impossible. Interaction utilisateur requise ?");
                    isMusicPlaying = false; // Reset state
                    playPauseButton.classList.remove('playing');
                    playPauseButton.setAttribute('aria-label', 'Lecture');
                });
            }

            function pauseMusic() {
                if (!audioPlayer || !playPauseButton) return;
                audioPlayer.pause();
                isMusicPlaying = false;
                playPauseButton.classList.remove('playing');
                playPauseButton.setAttribute('aria-label', 'Lecture');
                console.log("Music paused");
            }

            function togglePlayPause() {
                if (isMusicPlaying) {
                    pauseMusic();
                } else {
                    playMusic();
                }
            }

            function nextTrack() {
                if (!playlist || playlist.length === 0) return;
                console.log("Next track requested");
                loadTrack(currentTrackIndex + 1);
                // If it was playing, start the next track automatically
                if (isMusicPlaying || audioPlayer.autoplay) { // Check if it should autoplay
                     // Small delay sometimes helps ensure src is loaded before play
                     setTimeout(playMusic, 50);
                }
            }

            function prevTrack() {
                if (!playlist || playlist.length === 0) return;
                 console.log("Previous track requested");
                loadTrack(currentTrackIndex - 1);
                if (isMusicPlaying || audioPlayer.autoplay) {
                     setTimeout(playMusic, 50);
                }
            }

            // Event listeners for music controls
            playPauseButton?.addEventListener('click', togglePlayPause);
            nextTrackButton?.addEventListener('click', nextTrack);
            prevTrackButton?.addEventListener('click', prevTrack);
            audioPlayer?.addEventListener('ended', () => {
                console.log("Track ended, playing next.");
                nextTrack(); // Automatically play next track when current one finishes
            });
            // Set initial track display (without playing)
            if (playlist.length > 0) {
                 loadTrack(0); // Load the first track initially
            }

            // --- Camera Management ---
            async function startVideoStream(targetScreenName) {
                 const targetContainer = targetScreenName === 'vision' ? visionCameraContainer : (targetScreenName === 'look_and_ask' ? lookCameraContainer : null);
                 if (!targetContainer) { console.error(`No valid target container found for screen: ${targetScreenName}`); return false; }

                 if (videoStream && videoElement.parentElement === targetContainer) {
                     console.log("Video stream already active for this screen.");
                     targetContainer.classList.add('video-active');
                     videoElement.classList.add('active');
                     return true;
                 }
                 if (videoStream && videoElement.parentElement !== targetContainer) {
                     console.log("Attaching existing video stream to new screen.");
                     targetContainer.appendChild(videoElement);
                     targetContainer.classList.add('video-active');
                     videoElement.play().catch(e => console.error("Error re-playing video:", e));
                     setTimeout(() => videoElement.classList.add('active'), 10);
                     return true;
                 }

                 if (!videoStream) {
                     if (permissionGranted === false) { console.warn("Cannot start video: permission denied."); showErrorScreen("Accès caméra refusé."); return false; }
                     try {
                         console.log(`Attempting to start NEW video stream for ${targetScreenName}...`);
                         const constraints = { video: { facingMode: "environment" } };
                         videoStream = await navigator.mediaDevices.getUserMedia(constraints)
                             .catch(async (e) => {
                                 console.warn("Environment camera failed, trying default:", e);
                                 if (e.name === 'OverconstrainedError' || e.name === 'NotFoundError' || e.name === 'NotReadableError') {
                                     return navigator.mediaDevices.getUserMedia({ video: true });
                                 }
                                 throw e;
                             });
                         videoElement.srcObject = videoStream;
                         await videoElement.play();
                         console.log("Video stream started successfully.");
                         targetContainer.appendChild(videoElement);
                         targetContainer.classList.add('video-active');
                         setTimeout(() => videoElement.classList.add('active'), 10);
                         return true;
                     } catch (err) {
                         console.error("Error starting video stream:", err);
                         let userMessage = "Impossible de démarrer le flux vidéo.";
                          if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') userMessage = "Accès caméra refusé.";
                          else if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') userMessage = "Aucune caméra trouvée.";
                          else if (err.name === 'NotReadableError' || err.name === 'OverconstrainedError' || err.name === 'TrackStartError' || err.name === 'AbortError') userMessage = "Caméra déjà utilisée ou problème matériel.";
                          else userMessage = `Erreur caméra: ${err.message || err.name}`;
                         showErrorScreen(userMessage); videoStream = null; return false;
                     }
                 }
                 return false; // Should be unreachable
             }

            function stopVideoStream() {
                 if (videoStream) {
                     console.log("Stopping video stream.");
                     videoStream.getTracks().forEach(track => track.stop());
                     videoStream = null;
                     videoElement.srcObject = null;
                     videoElement.classList.remove('active');
                     if (videoElement.parentElement) {
                         videoElement.parentElement.classList.remove('video-active');
                         videoElement.remove();
                     }
                     visionCameraContainer?.querySelector('.placeholder-icon')?.style.removeProperty('display');
                     lookCameraContainer?.querySelector('.placeholder-icon')?.style.removeProperty('display');
                 }
            }

            function captureImageFromVideo() {
                 if (!videoStream || !videoElement.videoWidth || !videoElement.videoHeight || videoElement.paused || videoElement.ended) {
                     console.error("Cannot capture: video stream not ready or inactive.");
                     showErrorScreen("Impossible de capturer (flux vidéo non prêt).");
                     return null;
                 }
                 canvasElement.width = videoElement.videoWidth;
                 canvasElement.height = videoElement.videoHeight;
                 try {
                     const context = canvasElement.getContext('2d');
                     context.drawImage(videoElement, 0, 0, canvasElement.width, canvasElement.height);
                     const imageDataUrl = canvasElement.toDataURL('image/jpeg', 0.9);
                     console.log('Image captured (JPEG):', imageDataUrl.substring(0, 60) + '...');
                     return imageDataUrl;
                 } catch (e) {
                     console.error("Error capturing or converting image:", e);
                     if (e.name === 'SecurityError') { showErrorScreen("Erreur de sécurité lors de la capture."); }
                     else { showErrorScreen("Erreur lors de la capture de l'image."); }
                     return null;
                 }
            }

            // --- Vision Screen Capture Handler ---
            visionCaptureButton?.addEventListener('click', () => {
                 console.log('Vision Capture button clicked.');
                 const imageDataUrl = captureImageFromVideo();
                 if (imageDataUrl) {
                     capturedPhotos.push(imageDataUrl);
                     console.log(`Photo added to gallery. Total: ${capturedPhotos.length}`);
                     mainDisplay.style.transition = 'opacity 0.1s ease-out';
                     mainDisplay.style.opacity = '0.8';
                     setTimeout(() => { mainDisplay.style.opacity = '1'; }, 100);
                     switchScreen('response');
                     queryTextElement.textContent = "Vision";
                     responseTextElement.innerHTML = "<p>Photo capturée et ajoutée à la galerie.</p>";
                 }
            });

            // --- Gallery Display ---
            function displayGallery() {
                 if (!galleryContainer || !galleryEmptyMsg) return;
                 galleryContainer.innerHTML = ''; // Clear previous items
                 if (capturedPhotos.length === 0) {
                     galleryEmptyMsg.style.display = 'block';
                 } else {
                     galleryEmptyMsg.style.display = 'none';
                     capturedPhotos.forEach((dataUrl, index) => {
                         const item = document.createElement('div'); item.className = 'gallery-item';
                         const img = document.createElement('img'); img.src = dataUrl; img.alt = `Photo capturée ${index + 1}`;
                         img.onerror = () => { img.alt = "Erreur chargement image"; };
                         const downloadLink = document.createElement('a'); downloadLink.href = dataUrl; downloadLink.download = `rabbit_capture_${index + 1}.jpg`;
                         downloadLink.className = 'download-link'; downloadLink.innerHTML = '<i class="fas fa-download"></i>';
                         downloadLink.setAttribute('aria-label', 'Télécharger l\'image'); downloadLink.title = 'Télécharger';
                         item.appendChild(img); item.appendChild(downloadLink);
                         galleryContainer.appendChild(item);
                         item.style.animationDelay = `${index * 0.05}s`;
                     });
                 }
            }

            // --- Notes Management ---
            function saveNote() {
                 if (notesTextarea) {
                     const noteContent = notesTextarea.value;
                     try {
                         localStorage.setItem('rabbit_note', noteContent);
                         console.log("Note saved to localStorage.");
                         if(notesFeedback) {
                             notesFeedback.textContent = "Note enregistrée !";
                             notesFeedback.classList.add('visible');
                             setTimeout(() => { notesFeedback.classList.remove('visible'); }, 2000);
                         }
                     } catch (e) {
                         console.error("Error saving note:", e);
                         if(notesFeedback) {
                             notesFeedback.textContent = "Erreur sauvegarde.";
                             notesFeedback.style.color = 'var(--error-red)';
                             notesFeedback.classList.add('visible');
                             setTimeout(() => {
                                 notesFeedback.classList.remove('visible');
                                 notesFeedback.style.color = 'var(--success-green)';
                             }, 3000);
                         }
                     }
                 }
            }
            function loadNote() {
                 if (notesTextarea) {
                     try {
                         const savedNote = localStorage.getItem('rabbit_note');
                         if (savedNote !== null) { notesTextarea.value = savedNote; console.log("Note loaded."); }
                         else { notesTextarea.value = ''; }
                     } catch (e) { console.error("Error loading note:", e); notesTextarea.value = ''; }
                 }
            }
            saveNoteButton?.addEventListener('click', saveNote);

            // --- Look & Ask (Multimodal) Management ---
            function resetLookAskState() {
                 console.log("Resetting Look & Ask state.");
                 capturedImageDataForPrompt = null; isMultimodalPrompt = false;
                 lookStatusText.textContent = "Visez, puis capturez l'image.";
                 lookCaptureButton.disabled = false;

                 const preview = lookCameraContainer?.querySelector('.captured-image-preview');
                 if (preview) preview.remove();

                 if (videoStream && videoElement.parentElement === lookCameraContainer) {
                     videoElement.style.display = 'block';
                     videoElement.classList.add('active');
                 } else if (!videoStream) {
                     lookCameraContainer?.classList.remove('video-active');
                     lookCameraContainer?.querySelector('.placeholder-icon')?.style.removeProperty('display');
                 }
            }
            lookCaptureButton?.addEventListener('click', () => {
                 console.log('Look & Ask Capture button clicked.');
                 const imageDataUrl = captureImageFromVideo();
                 if (imageDataUrl) {
                     capturedImageDataForPrompt = imageDataUrl;
                     lookStatusText.textContent = "Image capturée. Parlez maintenant.";
                     lookCaptureButton.disabled = true;

                     const existingPreview = lookCameraContainer?.querySelector('.captured-image-preview');
                     if(existingPreview) existingPreview.remove();

                     const previewImg = document.createElement('img');
                     previewImg.src = imageDataUrl;
                     previewImg.className = 'captured-image-preview';
                     lookCameraContainer.appendChild(previewImg);

                     videoElement.style.display = 'none';
                     videoElement.classList.remove('active');

                 } else {
                     lookStatusText.textContent = "Échec de la capture. Réessayez.";
                 }
            });

             // --- Gemini API Calls ---
             async function queryGemini(fullPrompt, originalPromptForHistory) {
                 console.log("Querying Gemini (Text):", originalPromptForHistory); // Log original prompt
                 checkContextTimeout();
                 // Add original user prompt to history, full prompt sent to API
                 addToHistory('user', originalPromptForHistory);

                 if (!GEMINI_API_KEY || GEMINI_API_KEY === 'YOUR_API_KEY') { const errorMsg = "Clé API non configurée."; addToHistory('model', errorMsg); throw new Error(errorMsg); }

                 // Construct payload including system instruction, history, and the NEW full prompt
                 const requestContents = [
                     { role: 'user', parts: [{ text: SYSTEM_INSTRUCTION }] },
                     // Pass history excluding the latest user prompt (which is now part of the new fullPrompt)
                     ...conversationHistory.slice(0, -1),
                     // Add the new full prompt as the latest user turn
                     { role: 'user', parts: [{ text: fullPrompt }] }
                 ];

                 try {
                     const response = await fetch(GEMINI_API_URL, {
                         method: 'POST',
                         headers: { 'Content-Type': 'application/json' },
                         body: JSON.stringify({
                             contents: requestContents,
                             safetySettings: GEMINI_SAFETY_SETTINGS
                         })
                     });
                     const data = await response.json();

                     if (!response.ok) {
                         console.error('Gemini API Error:', response.status, data);
                         const errorMessage = data?.error?.message || `Erreur HTTP ${response.status}`;
                         const fullErrorMsg = `Erreur API IA : ${errorMessage}`;
                         addToHistory('model', `Erreur: ${fullErrorMsg}`);
                         throw new Error(fullErrorMsg);
                     }

                     console.log("Gemini API Response (Raw):", data);

                     let responseText = "Désolé, je n'ai pas pu générer de réponse.";
                     if (data.candidates?.length > 0) {
                         const candidate = data.candidates[0];
                         if (candidate.finishReason && candidate.finishReason !== 'STOP' && candidate.finishReason !== 'MAX_TOKENS') {
                             const reason = candidate.finishReason.replace(/_/g, ' ').toLowerCase();
                             responseText = (candidate.content?.parts?.[0]?.text || "") + `\n\n_(Réponse interrompue: ${reason}.)_`;
                             console.warn(`Gemini response finish reason: ${candidate.finishReason}`);
                         } else {
                             responseText = candidate.content?.parts?.[0]?.text || "Format de réponse inattendu.";
                         }
                     } else if (data.promptFeedback?.blockReason) {
                         const reason = data.promptFeedback.blockReason.replace(/_/g, ' ').toLowerCase();
                         responseText = `Réponse bloquée (${reason}).`;
                         console.warn(`Gemini response blocked: ${data.promptFeedback.blockReason}`);
                     }
                     return responseText;

                 } catch (error) {
                     console.error('Error fetching Gemini (Text):', error);
                     if (!error.message.includes("Erreur API IA")) {
                         addToHistory('model', `Erreur réseau/fetch: ${error.message}`);
                     }
                     throw error;
                 }
             }

             async function queryGeminiWithImage(fullPrompt, base64ImageData) {
                 console.log("Querying Gemini (Multimodal):", fullPrompt.split('] ')[1]); // Log original query part
                 checkContextTimeout();
                 // Add original user prompt part to history
                 const originalPromptForHistory = fullPrompt.split('] ')[1] || "[Question sur image]";
                 addToHistory('user', originalPromptForHistory);


                 if (!GEMINI_API_KEY || GEMINI_API_KEY === 'YOUR_API_KEY') { const errorMsg = "Clé API non configurée."; addToHistory('model', errorMsg); throw new Error(errorMsg); }

                 const pureBase64 = base64ImageData.includes(',') ? base64ImageData.split(',')[1] : base64ImageData;

                 // Construct payload: system instruction, history, new multimodal user prompt (with full context)
                 const requestContents = [
                     { role: 'user', parts: [{ text: SYSTEM_INSTRUCTION }] },
                     ...conversationHistory.slice(0, -1), // History up to the last user prompt
                     {
                         role: 'user',
                         parts: [
                             { text: fullPrompt }, // The user's spoken question WITH context
                             { inline_data: { mime_type: 'image/jpeg', data: pureBase64 } }
                         ]
                     }
                 ];

                 // Update UI to show analysis is happening (on the response screen)
                  switchScreen('response');
                  queryTextElement.textContent = originalPromptForHistory; // Show only original query
                  responseTextElement.innerHTML = `<div class="loading-indicator"><div class="spinner medium"></div><i>Analyse de l'image...</i></div>`;

                 try {
                     const response = await fetch(GEMINI_API_URL, {
                         method: 'POST',
                         headers: { 'Content-Type': 'application/json' },
                         body: JSON.stringify({
                             contents: requestContents,
                             safetySettings: GEMINI_SAFETY_SETTINGS
                          })
                     });
                     const data = await response.json();

                     if (!response.ok) {
                         console.error('Gemini API Error (Multimodal):', response.status, data);
                         const errorMessage = data?.error?.message || `Erreur HTTP ${response.status}`;
                         const fullErrorMsg = `Erreur IA (image) : ${errorMessage}`;
                         addToHistory('model', `Erreur: ${fullErrorMsg}`);
                         throw new Error(fullErrorMsg);
                     }

                     console.log("Gemini API Response (Multimodal Raw):", data);

                     let responseText = "Désolé, je n'ai pas pu analyser l'image.";
                     if (data.candidates?.length > 0) {
                          const candidate = data.candidates[0];
                          if (candidate.finishReason && candidate.finishReason !== 'STOP' && candidate.finishReason !== 'MAX_TOKENS') {
                              const reason = candidate.finishReason.replace(/_/g, ' ').toLowerCase();
                              responseText = (candidate.content?.parts?.[0]?.text || "") + `\n\n_(Analyse interrompue: ${reason}.)_`;
                              console.warn(`Gemini multimodal response finish reason: ${candidate.finishReason}`);
                          } else {
                              responseText = candidate.content?.parts?.[0]?.text || "Je n'ai pas de commentaire sur cette image.";
                          }
                     } else if (data.promptFeedback?.blockReason) {
                          const reason = data.promptFeedback.blockReason.replace(/_/g, ' ').toLowerCase();
                          responseText = `Analyse bloquée (${reason}).`;
                          console.warn(`Gemini multimodal response blocked: ${data.promptFeedback.blockReason}`);
                     }
                     return responseText;

                 } catch (error) {
                     console.error('Error fetching Gemini (Multimodal):', error);
                      if (!error.message.includes("Erreur IA")) {
                          addToHistory('model', `Erreur réseau/fetch (image): ${error.message}`);
                      }
                     throw error;
                 }
             }

            // --- Markdown Display ---
            function markdownToHtml(markdown) {
                 if (typeof markdown !== 'string') return '';
                 let html = markdown;
                 // Basic block elements
                 html = html.replace(/```(?:[a-z]+\n)?([\s\S]*?)```/gs, (match, code) => `<pre><code>${code.trim().replace(/</g, '&lt;').replace(/>/g, '&gt;')}</code></pre>`);
                 html = html.replace(/^### (.*$)/gm, '<h3>$1</h3>');
                 html = html.replace(/^## (.*$)/gm, '<h2>$1</h2>');
                 html = html.replace(/^# (.*$)/gm, '<h1>$1</h1>');
                 html = html.replace(/^(?:-{3,}|_{3,}|\*{3,})$/gm, '<hr>');
                 html = html.replace(/^(?:> (?:.*\n?))+/gm, (match) => `<blockquote>${markdownToHtmlSimpleInline(match.replace(/^> /gm, '').trim())}</blockquote>`);
                 // Improved Lists (handles multi-line items better, still basic)
                 html = html.replace(/^([*+-]) (.*(?:\n {2,}.*|\n(?!\n))*)/gm, (match, marker, itemContent) => `<ul><li>${markdownToHtmlSimpleInline(itemContent.trim().replace(/\n {2,}/g, '\n'))}</li></ul>`);
                 html = html.replace(/^(\d+)\. (.*(?:\n {2,}.*|\n(?!\n))*)/gm, (match, num, itemContent) => `<ol start="${num}"><li>${markdownToHtmlSimpleInline(itemContent.trim().replace(/\n {2,}/g, '\n'))}</li></ol>`);
                 html = html.replace(/<\/ul>\s*<ul>/g, '');
                 html = html.replace(/<\/ol>\s*<ol(?: start="\d+")?>/g, '');
                 // Inline elements
                 html = html.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, '<img src="$2" alt="$1" style="max-width: 100%; height: auto; border-radius: 4px; margin: 0.5em 0;">');
                 html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
                 html = markdownToHtmlSimpleInline(html); // Bold, italic, code
                 // Paragraphs
                 html = html.split('\n').map(line => {
                     line = line.trim();
                     if (line.length === 0) return '';
                     if (!line.match(/^<\/?(h[1-6]|ul|ol|li|blockquote|hr|pre|img|table|thead|tbody|tr|th|td)/i)) {
                         return `<p>${line}</p>`;
                     }
                     return line;
                 }).join('');
                 // Cleanup
                 html = html.replace(/<p>\s*<\/p>/g, '');
                 html = html.replace(/<\/blockquote>\s*<blockquote>/g, '');
                 return html;
            }
            function markdownToHtmlSimpleInline(text) {
                 text = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/__(.*?)__/g, '<strong>$1</strong>');
                 text = text.replace(/\*(.*?)\*/g, '<em>$1</em>').replace(/_(.*?)_/g, '<em>$1</em>');
                 text = text.replace(/`([^`]+)`/g, '<code>$1</code>');
                 return text;
            }
            function displayMarkdownResponse(markdownText, element) {
                if (element) {
                    const htmlContent = markdownToHtml(markdownText);
                    element.style.transition = 'opacity 0.2s ease-out';
                    element.style.opacity = 0;
                    setTimeout(() => {
                        element.innerHTML = htmlContent;
                        element.scrollTop = 0;
                        element.style.transition = 'opacity 0.3s ease-in';
                        element.style.opacity = 1;
                    }, 200);
                } else { console.error("Response display element not found."); }
            }

            // --- Scroll & Back Button Handlers ---
            scrollUpButton?.addEventListener('click', () => {
                 const currentScreenName = document.querySelector('.screen.active-screen')?.dataset.screenName;
                 if (currentScreenName === 'listening') return;
                 currentScreenIndex = (currentScreenIndex - 1 + screenOrder.length) % screenOrder.length;
                 switchScreen(screenOrder[currentScreenIndex]);
            });
            scrollDownButton?.addEventListener('click', () => {
                 const currentScreenName = document.querySelector('.screen.active-screen')?.dataset.screenName;
                 if (currentScreenName === 'listening') return;
                 currentScreenIndex = (currentScreenIndex + 1) % screenOrder.length;
                 switchScreen(screenOrder[currentScreenIndex]);
            });
            document.querySelectorAll('.back-button').forEach(button => {
                 button.addEventListener('click', (event) => {
                     const target = event.currentTarget.dataset.targetScreen || 'home';
                     switchScreen(target);
                 });
            });

            // --- App Initialization ---
            async function initializeApp() {
                console.log("Initializing Rabbit R1 Web App (Cool Edition)...");

                // 1. Get User Name (before anything else that might need it)
                getUserName();

                // 2. Initial Setup
                switchScreen('home'); // Start on home screen
                loadNote(); // Load initial note state
                if (playlist.length > 0) loadTrack(0); // Load initial track display

                // 3. Setup Status Bar Updates
                updateDateTime(); // Initial call
                updateBatteryStatus(); // Initial call
                setInterval(updateDateTime, 1000); // Update time every second

                // 4. Initialize Speech Recognition and PTT
                const speechReady = await initializeSpeechRecognition();
                if (speechReady && pttButton) {
                    pttButton.addEventListener('pointerdown', handlePttStart);
                    pttButton.addEventListener('pointerup', handlePttEnd);
                    pttButton.addEventListener('pointerleave', (e) => { if (isListening) handlePttEnd(e); });
                    pttButton.addEventListener('contextmenu', (e) => e.preventDefault());
                    console.log("PTT Handlers attached.");
                } else {
                     console.warn("PTT initialization failed or permissions denied.");
                     if(pttButton) pttButton.disabled = true;
                }

                console.log("Application initialized.");
            }

            // Start the application
            initializeApp();

            // Cleanup: Stop video stream when leaving the page/closing tab
            window.addEventListener('beforeunload', stopVideoStream);

        }); // End DOMContentLoaded
    </script>
</body>
</html>
