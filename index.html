<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rabbit R1 Web App</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Press+Start+2P&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        /* Global Variables */
        :root {
            --rabbit-orange: #ff7e00;
            --off-white: #f8f8f8;
            --light-gray: #e0e0e0;
            --medium-gray: #cccccc;
            --dark-gray: #333333;
            --device-gray: #d0d0d0;
            --error-red: #d9534f;
            --success-green: #5cb85c;
        }

        /* Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--off-white);
            color: var(--dark-gray);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            -webkit-tap-highlight-color: transparent;
        }

        /* Device Container */
        .device-container {
            width: 100%;
            max-width: 360px;
            margin: 0 auto;
        }

        .rabbit-device {
            background-color: var(--device-gray);
            border-radius: 24px;
            padding: 16px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 16px;
        }

        /* Main Display */
        .main-display {
            background-color: var(--off-white);
            border-radius: 16px;
            width: 100%;
            aspect-ratio: 1 / 1;
            overflow: hidden;
            position: relative;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.1);
        }

        /* Screens (General) */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease, transform 0.3s ease;
            transform: translateX(20px);
            overflow-y: auto;
            background-color: var(--off-white);
        }

        .active-screen {
            opacity: 1;
            visibility: visible;
            transform: translateX(0);
        }

        /* Back Button (Common) */
        .back-button {
            margin-top: auto;
            padding: 8px 16px;
            background-color: var(--medium-gray);
            border: none;
            border-radius: 4px;
            color: var(--dark-gray);
            cursor: pointer;
            transition: background-color 0.2s;
            font-size: 14px;
            display: inline-flex;
            align-items: center;
            gap: 5px;
            z-index: 10; /* Ensure it's clickable over other content */
        }
        .back-button:hover {
            background-color: var(--light-gray);
        }
        /* Specific positioning for screens with absolute positioned button */
        .response-screen .back-button,
        .error-screen .back-button,
        .notes-screen .back-button,
        .gallery-screen .back-button,
        .look-at-this-screen .back-button {
             position: absolute;
             bottom: 15px;
             left: 50%;
             transform: translateX(-50%);
        }
        /* Standard margin for others */
         .calendar-screen .back-button,
         .alarms-screen .back-button,
         .timer-screen .back-button,
         .music-screen .back-button,
         .vision-screen .back-button {
            margin-top: 20px;
         }

        /* Common Screen Title */
        .screen h2 {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 20px;
            text-align: center;
            width: 100%;
            color: var(--dark-gray);
        }

        /* --- Specific Screen Styles --- */

        /* Home Screen */
        .home-screen { justify-content: center; text-align: center; }
        .greeting { font-size: 24px; font-weight: 600; margin-bottom: 10px; }
        .instruction { font-size: 16px; color: #666; margin-bottom: 15px; }
        .permission-status { font-size: 12px; color: #666; margin-top: 10px; min-height: 1.2em; font-weight: 500; }
        .permission-status.error { color: var(--error-red); font-weight: 600; }

        /* Listening Screen */
        .listening-screen { justify-content: center; }
        .listening-indicator { text-align: center; }
        .listening-text { font-size: 18px; margin-bottom: 20px; animation: pulse 1.5s infinite alternate; }
        .waveform { display: flex; justify-content: center; align-items: center; gap: 5px; height: 40px; }
        .waveform span { display: inline-block; width: 5px; height: 20px; background-color: var(--rabbit-orange); border-radius: 2px; }
        .waveform span:nth-child(1) { animation: wave 0.5s infinite alternate; }
        .waveform span:nth-child(2) { animation: wave 0.5s infinite alternate 0.1s; }
        .waveform span:nth-child(3) { animation: wave 0.5s infinite alternate 0.2s; }
        .waveform span:nth-child(4) { animation: wave 0.5s infinite alternate 0.3s; }
        @keyframes wave { 0% { height: 10px; opacity: 0.7; } 100% { height: 30px; opacity: 1; } }
        @keyframes pulse { 0% { opacity: 0.6; } 100% { opacity: 1; } }

        /* Response Screen */
        .response-screen { justify-content: flex-start; align-items: flex-start; padding-bottom: 60px; }
        .query-text { font-weight: 600; margin-bottom: 16px; align-self: flex-start; width: 100%; color: #555; border-bottom: 1px solid var(--light-gray); padding-bottom: 8px; word-wrap: break-word; }
        .response-text { width: 100%; font-size: 15px; line-height: 1.6; word-wrap: break-word; padding-bottom: 30px; }
        .response-text p i { color: #666; }
        .response-text p.error-message { color: var(--error-red); font-weight: 600; }
        /* Markdown Styles */
        .response-text p { margin-bottom: 1em; }
        .response-text h1, .response-text h2, .response-text h3 { margin-top: 1.5em; margin-bottom: 0.8em; line-height: 1.3; }
        .response-text h1 { font-size: 1.6em; border-bottom: 1px solid var(--light-gray); padding-bottom: 0.3em;}
        .response-text h2 { font-size: 1.4em; }
        .response-text h3 { font-size: 1.2em; }
        .response-text ul, .response-text ol { margin-left: 25px; margin-bottom: 1em; }
        .response-text li { margin-bottom: 0.5em; }
        .response-text code { background-color: #eee; padding: 0.2em 0.4em; border-radius: 3px; font-family: monospace; font-size: 0.9em; word-wrap: break-word; }
        .response-text pre { background-color: #eee; padding: 15px; border-radius: 5px; overflow-x: auto; margin-bottom: 1em; }
        .response-text pre code { background-color: transparent; padding: 0; font-size: 0.9em; word-wrap: normal; }
        .response-text blockquote { border-left: 4px solid var(--medium-gray); padding-left: 15px; margin: 1em 0; color: #555; font-style: italic; }
        .response-text table { border-collapse: collapse; width: 100%; margin: 1.5em 0; border: 1px solid var(--dark-gray); }
        .response-text th, .response-text td { border: 1px solid var(--dark-gray); padding: 10px; text-align: left; }
        .response-text th { background-color: var(--light-gray); font-weight: 600; }
        .response-text hr { border: none; border-top: 1px solid var(--light-gray); margin: 2em 0; }
        .response-text a { color: var(--rabbit-orange); text-decoration: none; }
        .response-text a:hover { text-decoration: underline; }
        .response-text img { max-width: 100%; height: auto; border-radius: 4px; margin: 0.5em 0; }

        /* Alarms Screen */
        .alarms-screen { justify-content: flex-start; }
        .alarms-list { list-style: none; width: 100%; padding: 0; }
        .alarms-list li { padding: 12px; border-bottom: 1px solid var(--light-gray); }

        /* Timer Screen */
        .timer-screen { justify-content: flex-start; }
        .timer-display { font-family: 'Press Start 2P', cursive; font-size: 32px; margin: 20px 0; color: var(--dark-gray); }
        .timer-controls { display: flex; gap: 10px; margin-bottom: 20px;}
        .timer-btn { padding: 8px 16px; background-color: var(--medium-gray); border: none; border-radius: 4px; color: var(--dark-gray); cursor: pointer; transition: background-color 0.2s; }
        .timer-btn:hover { background-color: var(--light-gray); }

        /* Music Screen */
        .music-screen { justify-content: flex-start; }
        .album-art { width: 120px; height: 120px; background-color: var(--medium-gray); border-radius: 8px; margin-bottom: 16px; display: flex; justify-content: center; align-items: center; font-size: 40px; color: #fff; background-image: linear-gradient(45deg, #aaa, #ccc); }
        .album-art::before { content: '\f001'; font-family: 'Font Awesome 6 Free'; font-weight: 900; }
        .track-info { text-align: center; margin-bottom: 16px; }
        .track-title { font-weight: 600; margin-bottom: 4px; }
        .artist-name { font-size: 14px; color: #666; }
        .music-controls { display: flex; gap: 16px; margin-bottom: 20px;}
        .music-btn { width: 40px; height: 40px; border-radius: 50%; background-color: var(--medium-gray); border: none; display: flex; justify-content: center; align-items: center; cursor: pointer; transition: background-color 0.2s; font-size: 16px; color: var(--dark-gray); }
        .music-btn:hover { background-color: var(--light-gray); }

        /* Vision Screen (Simple Capture) */
        .vision-screen { justify-content: flex-start; }
        .camera-placeholder { width: 200px; height: 150px; background-color: var(--medium-gray); border-radius: 8px; display: flex; justify-content: center; align-items: center; margin-bottom: 20px; border: 2px dashed var(--dark-gray); overflow: hidden; position: relative; }
        .camera-placeholder i { font-size: 48px; color: var(--dark-gray); z-index: 0; }
        .capture-btn { padding: 10px 20px; background-color: var(--rabbit-orange); border: none; border-radius: 8px; color: white; cursor: pointer; transition: background-color 0.2s; font-size: 16px; font-weight: 500; }
        .capture-btn:hover { background-color: #e67200; }
        .live-video { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: 1;}

        /* Error Screen */
        .error-screen { justify-content: flex-start; text-align: center; padding-bottom: 60px; }
        .error-screen h2 { color: var(--error-red); }
        #error-message { margin-bottom: 20px; color: var(--error-red); font-weight: 500;}

        /* Calendar Screen */
        .calendar-screen { justify-content: flex-start; }
        .calendar-placeholder { width: 100%; max-width: 300px; height: 200px; background-color: #eee; border: 1px solid var(--light-gray); display: flex; justify-content: center; align-items: center; font-style: italic; color: #999; border-radius: 8px; }

        /* Notes Screen */
        .notes-screen { justify-content: flex-start; padding-bottom: 80px; } /* More space for feedback */
        .notes-textarea { width: 100%; height: 150px; margin-bottom: 15px; padding: 10px; border: 1px solid var(--light-gray); border-radius: 4px; font-family: inherit; font-size: 14px; resize: vertical; }
        .save-note-btn { padding: 8px 16px; background-color: var(--success-green); color: white; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.2s; }
        .save-note-btn:hover { background-color: #4cae4c; }
        #notes-feedback { font-size: 12px; color: var(--success-green); margin-top: 10px; min-height: 1em; text-align: center; }

        /* Gallery Screen */
        .gallery-screen { justify-content: flex-start; padding-bottom: 60px; }
        .gallery-container { display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 10px; width: 100%; margin-top: 10px; }
        .gallery-item { position: relative; }
        .gallery-item img { display: block; width: 100%; height: 80px; object-fit: cover; border-radius: 4px; border: 1px solid var(--light-gray); }
        .gallery-item .download-link { position: absolute; bottom: 5px; right: 5px; background-color: rgba(0,0,0,0.6); color: white; border-radius: 50%; width: 20px; height: 20px; display: flex; justify-content: center; align-items: center; text-decoration: none; font-size: 10px; transition: background-color 0.2s; }
        .gallery-item .download-link:hover { background-color: rgba(0,0,0,0.8); }
        #gallery-empty-msg { font-style: italic; color: #999; text-align: center; width: 100%; }

        /* Look & Ask Screen */
        .look-at-this-screen { justify-content: flex-start; padding-bottom: 60px; }
        .look-camera-container { width: 100%; max-width: 240px; height: 180px; background-color: var(--medium-gray); border-radius: 8px; margin-bottom: 15px; border: 2px dashed var(--dark-gray); overflow: hidden; position: relative; display: flex; justify-content: center; align-items: center; }
        .look-camera-container i { font-size: 48px; color: var(--dark-gray); z-index: 0; }
        .look-camera-container .live-video { z-index: 1; }
        .look-camera-container .captured-image-preview { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: 2; border-radius: 8px; }
        .look-capture-btn { padding: 10px 20px; background-color: var(--rabbit-orange); border: none; border-radius: 8px; color: white; cursor: pointer; transition: background-color 0.2s; font-size: 16px; font-weight: 500; margin-bottom: 15px; }
        .look-capture-btn:hover { background-color: #e67200; }
        .look-capture-btn:disabled { background-color: var(--medium-gray); cursor: not-allowed; }
        .look-status-text { font-size: 14px; color: #666; text-align: center; min-height: 1.5em; }

        /* Controls (Bottom) */
        .controls { display: flex; flex-direction: column; align-items: center; gap: 16px; width: 100%; }
        .ptt-button { width: 60px; height: 60px; border-radius: 50%; background-color: var(--rabbit-orange); border: none; display: flex; justify-content: center; align-items: center; cursor: pointer; color: white; font-size: 24px; box-shadow: 0 4px 8px rgba(255, 126, 0, 0.3); transition: transform 0.1s ease, background-color 0.2s, box-shadow 0.2s; user-select: none; -webkit-user-select: none; touch-action: manipulation; }
        .ptt-button:active, .ptt-button.active { transform: scale(0.95); background-color: #e67200; box-shadow: 0 2px 4px rgba(255, 126, 0, 0.3); }
        .ptt-button.active { animation: ptt-pulse 1.5s infinite ease-in-out; }
        @keyframes ptt-pulse { 0% { box-shadow: 0 2px 4px rgba(255, 126, 0, 0.3); } 50% { box-shadow: 0 4px 12px rgba(255, 126, 0, 0.5); } 100% { box-shadow: 0 2px 4px rgba(255, 126, 0, 0.3); } }
        .scroll-controls { display: flex; gap: 20px; }
        .scroll-button { width: 40px; height: 40px; border-radius: 50%; background-color: var(--medium-gray); border: none; display: flex; justify-content: center; align-items: center; cursor: pointer; color: var(--dark-gray); transition: background-color 0.2s, transform 0.1s ease; user-select: none; -webkit-user-select: none; touch-action: manipulation; }
        .scroll-button:active { background-color: var(--light-gray); transform: scale(0.95); }
        .ptt-button:disabled { background-color: var(--medium-gray); cursor: not-allowed; box-shadow: none; transform: none; animation: none; opacity: 0.7; }
        .ptt-button:disabled:active { transform: none; }

        /* Responsive */
        @media (max-width: 400px) {
            body { padding: 10px; }
            .device-container { max-width: 100%; }
            .rabbit-device { border-radius: 16px; padding: 12px; }
            .timer-display { font-size: 28px; }
            .album-art { width: 100px; height: 100px; }
            .camera-placeholder { width: 180px; height: 135px; }
            .look-camera-container { width: 100%; height: 180px; max-width: none; }
            .response-text { font-size: 14px; }
            .response-text th, .response-text td { padding: 8px; }
            .gallery-container { grid-template-columns: repeat(auto-fill, minmax(70px, 1fr)); }
            .gallery-item img { height: 70px; }
        }
    </style>
</head>
<body>
    <div class="device-container">
        <div class="rabbit-device">
            <div class="main-display" id="main-display">
                <div class="screen home-screen active-screen" data-screen-name="home">
                    <div class="greeting">Bonjour Matéo</div>
                    <div class="instruction">Maintenez pour parler</div>
                    <div class="permission-status" id="permission-status">Vérification des permissions...</div>
                </div>

                <div class="screen listening-screen" data-screen-name="listening">
                    <div class="listening-indicator">
                        <div class="listening-text">Écoute en cours...</div>
                        <div class="waveform">
                            <span></span><span></span><span></span><span></span>
                        </div>
                    </div>
                </div>

                <div class="screen response-screen" data-screen-name="response">
                    <div class="query-text" id="query-text"></div>
                    <div class="response-text" id="response-text"></div>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                <div class="screen alarms-screen" data-screen-name="alarms">
                    <h2>Alarmes</h2>
                    <ul class="alarms-list">
                        <li>7:00 - Réveil</li>
                        <li>12:30 - Déjeuner</li>
                        <li>18:00 - Sport</li>
                    </ul>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                <div class="screen timer-screen" data-screen-name="timer">
                    <h2>Minuteur</h2>
                    <div class="timer-display">00:00</div>
                    <div class="timer-controls">
                        <button class="timer-btn" id="timer-start" aria-label="Démarrer le minuteur">Démarrer</button>
                        <button class="timer-btn" id="timer-reset" aria-label="Réinitialiser le minuteur">Réinitialiser</button>
                    </div>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                <div class="screen music-screen" data-screen-name="music">
                    <h2>Musique</h2>
                    <div class="album-art" role="img" aria-label="Pochette d'album"></div>
                    <div class="track-info">
                        <div class="track-title">Titre de la chanson</div>
                        <div class="artist-name">Nom de l'artiste</div>
                    </div>
                    <div class="music-controls">
                        <button class="music-btn" id="prev-track" aria-label="Piste précédente"><i class="fas fa-step-backward"></i></button>
                        <button class="music-btn" id="play-pause" aria-label="Lecture/Pause"><i class="fas fa-play"></i></button>
                        <button class="music-btn" id="next-track" aria-label="Piste suivante"><i class="fas fa-step-forward"></i></button>
                    </div>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                <div class="screen vision-screen" data-screen-name="vision">
                    <h2>Vision</h2>
                    <div class="camera-placeholder" id="vision-camera-placeholder" aria-hidden="true">
                        <i class="fas fa-camera"></i>
                         </div>
                    <button class="capture-btn" id="vision-capture-btn" aria-label="Capturer l'image">Capturer</button>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                <div class="screen calendar-screen" data-screen-name="calendar">
                    <h2>Calendrier</h2>
                    <div class="calendar-placeholder">Placeholder Calendrier</div>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                <div class="screen notes-screen" data-screen-name="notes">
                    <h2>Notes</h2>
                    <textarea id="notes-textarea" class="notes-textarea" placeholder="Écrivez vos notes ici..."></textarea>
                    <button id="save-note-btn" class="save-note-btn"><i class="fas fa-save"></i> Enregistrer</button>
                    <div id="notes-feedback"></div>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                <div class="screen gallery-screen" data-screen-name="gallery">
                    <h2>Galerie Photos</h2>
                    <div id="gallery-container" class="gallery-container">
                        </div>
                    <p id="gallery-empty-msg" style="display: none;">Aucune photo capturée pour le moment.</p>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                 <div class="screen look-at-this-screen" data-screen-name="look_and_ask">
                    <h2>Regarder & Demander</h2>
                    <div class="look-camera-container" id="look-camera-container">
                        <i class="fas fa-camera"></i>
                        </div>
                    <button class="look-capture-btn" id="look-capture-btn" aria-label="Capturer l'image pour l'IA">Capturer l'image</button>
                    <div class="look-status-text" id="look-status-text">Visez, puis capturez l'image.</div>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                <div class="screen error-screen" data-screen-name="error">
                    <h2>Erreur</h2>
                    <p id="error-message">Une erreur s'est produite.</p>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

            </div>

            <div class="controls">
                <button class="ptt-button" id="ptt-button" aria-label="Maintenir pour parler" aria-pressed="false" disabled>
                    <i class="fas fa-microphone"></i>
                </button>
                <div class="scroll-controls">
                    <button class="scroll-button" id="scroll-up" aria-label="Faire défiler vers le haut">
                        <i class="fas fa-chevron-up"></i>
                    </button>
                    <button class="scroll-button" id="scroll-down" aria-label="Faire défiler vers le bas">
                        <i class="fas fa-chevron-down"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Elements ---
            const mainDisplay = document.getElementById('main-display');
            const pttButton = document.getElementById('ptt-button');
            const scrollUpButton = document.getElementById('scroll-up');
            const scrollDownButton = document.getElementById('scroll-down');
            const queryTextElement = document.getElementById('query-text');
            const responseTextElement = document.getElementById('response-text');
            const permissionStatusElement = document.getElementById('permission-status');
            const errorMessageElement = document.getElementById('error-message');

            // Dynamically get screen elements
            const screens = {};
            document.querySelectorAll('.screen').forEach(screen => {
                const screenName = screen.dataset.screenName;
                if (screenName) screens[screenName] = screen;
            });

            // --- Screen Navigation Order ---
            const screenOrder = [
                'home', 'calendar', 'notes', 'gallery', 'alarms',
                'timer', 'music', 'vision'
                // 'look_and_ask' is not part of standard scroll navigation
            ];
            let currentScreenIndex = 0;

            // --- State Variables ---
            let isListening = false;
            let recognitionActive = false;
            let speechPromiseCallbacks = null;
            let recognition = null;
            let speechApiAvailable = false;
            let permissionGranted = null; // null, true, false
            let conversationHistory = [];
            let lastInteractionTime = Date.now();
            const CONTEXT_TIMEOUT = 60 * 1000; // 1 minute

            // Timer Elements & State
            const timerStartButton = document.getElementById('timer-start');
            const timerResetButton = document.getElementById('timer-reset');
            const timerDisplay = document.querySelector('.timer-display');
            let timerInterval = null;
            let timerSeconds = 0;
            let isTimerRunning = false;

            // Music Elements & State
            const playPauseButton = document.getElementById('play-pause');
            const prevTrackButton = document.getElementById('prev-track');
            const nextTrackButton = document.getElementById('next-track');
            let isMusicPlaying = false;

            // Vision (Simple Capture) Elements
            const visionCaptureButton = document.getElementById('vision-capture-btn');
            const visionCameraPlaceholder = document.getElementById('vision-camera-placeholder');

            // Notes Elements
            const notesTextarea = document.getElementById('notes-textarea');
            const saveNoteButton = document.getElementById('save-note-btn');
            const notesFeedback = document.getElementById('notes-feedback');

            // Gallery Elements
            const galleryContainer = document.getElementById('gallery-container');
            const galleryEmptyMsg = document.getElementById('gallery-empty-msg');
            let capturedPhotos = []; // In-memory storage for demo

            // Look & Ask (Multimodal) Elements & State
            const lookCameraContainer = document.getElementById('look-camera-container');
            const lookCaptureButton = document.getElementById('look-capture-btn');
            const lookStatusText = document.getElementById('look-status-text');
            let capturedImageDataForPrompt = null; // Base64 image data
            let isMultimodalPrompt = false; // Flag for PTT handler

            // Shared Media Elements
            let videoStream = null;
            const videoElement = document.createElement('video');
            videoElement.style.display = 'none';
            videoElement.setAttribute('playsinline', ''); // Important for iOS
            document.body.appendChild(videoElement); // Add once to body

            const canvasElement = document.createElement('canvas'); // For capturing frames
            const context = canvasElement.getContext('2d');

            // --- Configuration ---
            // WARNING: Storing API keys client-side is insecure. Use a backend proxy in production.
            const GEMINI_API_KEY = 'AIzaSyBW5xJAUSzhJP5n5p8znA39QFDR8JqtwPY'; // REPLACE WITH YOUR ACTUAL KEY
            const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${GEMINI_API_KEY}`; // Using Flash model

            // --- System Instruction for Gemini (Pre-prompt) ---
            const SYSTEM_INSTRUCTION = `Tu es un assistant vocal intégré dans une interface web simulant un appareil Rabbit R1.
            Tu peux répondre aux questions de l'utilisateur et exécuter certaines actions. Tu peux afficher du texte formaté en Markdown, y compris des listes, du gras, de l'italique, et des tableaux simples. Pour les questions simples ne nécessitant pas d'action, réponds directement en texte.
            Pour exécuter une action, commence ta réponse EXACTEMENT par "% nom_fonction %" suivi de ta réponse textuelle normale (qui peut être vide si l'action est évidente). Ne mets rien avant le %.
            N'utilise qu'une seule commande de fonction par réponse, au tout début.
            Les fonctions disponibles sont :
            - % start_timer % : Démarre ou reprend le minuteur.
            - % reset_timer % : Réinitialise le minuteur.
            - % play_pause_music % : Met en lecture ou en pause la musique (simulation).
            - % prev_track % : Passe à la piste précédente (simulation).
            - % next_track % : Passe à la piste suivante (simulation).
            - % capture_image % : Prend une photo simple (depuis l'écran Vision) et l'ajoute à la galerie. Doit être sur l'écran Vision pour fonctionner.
            - % go_home % : Affiche l'écran d'accueil.
            - % show_alarms % : Affiche l'écran des alarmes.
            - % show_timer % : Affiche l'écran du minuteur.
            - % show_music % : Affiche l'écran de musique.
            - % show_vision % : Affiche l'écran de vision (pour capture simple).
            - % show_calendar % : Affiche l'écran du calendrier (placeholder).
            - % show_notes % : Affiche l'écran des notes et charge la dernière note sauvegardée.
            - % save_current_note % : Sauvegarde le texte actuellement présent dans la zone de notes.
            - % show_gallery % : Affiche la galerie des photos capturées.
            - % look_and_ask % : Active le mode caméra spécial pour que l'utilisateur prenne une photo et pose une question dessus. Réponds avec un texte invitant l'utilisateur, par exemple "% look_and_ask % D'accord, montre-le moi. Capture l'image puis pose ta question."

            Exemple 1: User: "lance le minuteur" -> AI: "% start_timer % Minuteur démarré."
            Exemple 2: User: "quelle heure est-il ?" -> AI: "Il est [heure actuelle]." (pas de fonction)
            Exemple 3: User: "montre la galerie" -> AI: "% show_gallery % Voici vos photos."
            Exemple 4: User: "sauvegarde cette note" -> AI: "% save_current_note % Note sauvegardée."
            Exemple 5: User: "qu'est-ce que c'est ?" -> AI: "% look_and_ask % D'accord, montre-le moi. Capture l'image puis pose ta question."
            Adapte ta réponse textuelle après la commande pour confirmer l'action ou répondre à la question.`;

            // --- Core Functions ---

            /**
             * Switches the active screen, handling camera stream activation/deactivation.
             * @param {string} screenName - The target screen name (data-screen-name).
             */
            async function switchScreen(screenName) {
                console.log(`Switching to screen: ${screenName}`);
                const previousScreen = document.querySelector('.screen.active-screen');
                const previousScreenName = previousScreen?.dataset.screenName;

                let foundScreen = false;
                Object.values(screens).forEach(screen => {
                    const isTarget = screen.dataset.screenName === screenName;
                    screen.classList.toggle('active-screen', isTarget);
                    if (isTarget) foundScreen = true;
                });

                if (!foundScreen) {
                    console.error(`Screen "${screenName}" not found. Switching to home.`);
                    screenName = 'home';
                    screens.home.classList.add('active-screen');
                }

                // Update current index for scroll navigation
                const navigableIndex = screenOrder.indexOf(screenName);
                if (navigableIndex !== -1) currentScreenIndex = navigableIndex;

                // Handle screen-specific actions
                if (screenName === 'response') screens.response.scrollTop = 0;
                if (screenName === 'gallery') displayGallery();
                if (screenName === 'notes') loadNote();

                // Manage camera stream based on screen
                const needsCamera = ['vision', 'look_and_ask'].includes(screenName);
                const cameraWasActive = ['vision', 'look_and_ask'].includes(previousScreenName);

                if (needsCamera) {
                    await startVideoStream(screenName);
                } else if (cameraWasActive) {
                    stopVideoStream();
                }

                // Reset multimodal state if leaving look_and_ask screen
                 if (previousScreenName === 'look_and_ask' && screenName !== 'look_and_ask') {
                     resetLookAskState();
                 }
            }

            /**
             * Displays an error message on the dedicated error screen or fallback.
             * @param {string} message - The error message to display.
             */
            function showErrorScreen(message) {
                console.error("Displaying error:", message);
                if (errorMessageElement && screens.error) {
                    errorMessageElement.textContent = message;
                    switchScreen('error'); // Use await if switchScreen becomes async
                } else {
                    console.error("Error screen elements not found. Fallback display.");
                    switchScreen('response');
                    queryTextElement.textContent = "Erreur";
                    responseTextElement.innerHTML = `<p class="error-message">${message}</p>`;
                }
                lastInteractionTime = Date.now(); // Reset context timer on error too
            }

            /**
             * Updates the permission status message on the home screen.
             * @param {string} message - The message to display.
             * @param {boolean} [isError=false] - True if the message indicates an error.
             */
            function updatePermissionStatus(message, isError = false) {
                if (permissionStatusElement) {
                    permissionStatusElement.textContent = message;
                    permissionStatusElement.classList.toggle('error', isError);
                    console.log(`Permission status updated: "${message}" (isError: ${isError})`);
                }
            }

            // --- Speech Recognition Initialization ---
            async function initializeSpeechRecognition() {
                console.log("Initializing Speech Recognition...");
                updatePermissionStatus("Initialisation...");

                const SpeechRecognitionAPI = window.SpeechRecognition || window.webkitSpeechRecognition;
                if (!SpeechRecognitionAPI) {
                    updatePermissionStatus("Reconnaissance vocale non supportée.", true); return false;
                }
                if (window.location.protocol !== 'https:' && !['localhost', '127.0.0.1'].includes(window.location.hostname)) {
                    updatePermissionStatus("Connexion non sécurisée (HTTPS requis).", true); return false;
                }
                if (!navigator.mediaDevices?.getUserMedia) {
                    updatePermissionStatus("Accès aux périphériques média impossible.", true); return false;
                }

                // Request Permissions
                try {
                    updatePermissionStatus("Demande des permissions...");
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
                    permissionGranted = true;
                    updatePermissionStatus("Microphone et caméra prêts.");
                    stream.getTracks().forEach(track => track.stop()); // Stop tracks after permission granted

                    // Optional: Monitor permission changes
                    if (navigator.permissions?.query) {
                        const handlePermissionChange = (status, type) => {
                            console.log(`${type} permission state changed: ${status.state}`);
                            const isMic = type === 'microphone';
                            const currentlyGranted = status.state === 'granted';
                            if (isMic) permissionGranted = currentlyGranted; // Update mic permission state

                            updatePermissionStatus(
                                currentlyGranted ? "Microphone et caméra prêts." : `Accès ${type} refusé.`,
                                !currentlyGranted
                            );
                            if (isMic) pttButton.disabled = !currentlyGranted;
                            if (!currentlyGranted) {
                                if (isMic && recognitionActive) recognition?.abort();
                                stopVideoStream(); // Stop video if camera permission revoked
                            }
                        };
                        navigator.permissions.query({ name: 'microphone' })
                            .then(status => status.onchange = () => handlePermissionChange(status, 'microphone'))
                            .catch(e => console.warn("Cannot query microphone permission:", e));
                        navigator.permissions.query({ name: 'camera' })
                            .then(status => status.onchange = () => handlePermissionChange(status, 'camera'))
                            .catch(e => console.warn("Cannot query camera permission:", e));
                    }

                } catch (err) {
                    permissionGranted = false;
                    let userMessage = "Impossible d'accéder aux périphériques.";
                    if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') userMessage = "Accès microphone/caméra refusé.";
                    else if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') userMessage = "Aucun microphone/caméra trouvé.";
                    else if (err.name === 'NotReadableError') userMessage = "Périphérique déjà utilisé ou problème matériel.";
                    else userMessage = `Erreur accès périphériques: ${err.name}`;
                    updatePermissionStatus(userMessage, true);
                    return false;
                }

                // Initialize SpeechRecognition Instance
                try {
                    recognition = new SpeechRecognitionAPI();
                    recognition.lang = 'fr-FR';
                    recognition.continuous = true; // Keep listening until stopped
                    recognition.interimResults = false; // Only final results
                    speechApiAvailable = true;
                    if (pttButton) pttButton.disabled = false;

                    let currentTranscript = '';
                    recognition.onstart = () => {
                        console.log("SpeechRecognition: onstart");
                        recognitionActive = true;
                        currentTranscript = '';
                        pttButton?.classList.add('active');
                        const currentScreen = document.querySelector('.screen.active-screen')?.dataset.screenName;
                        if (currentScreen === 'look_and_ask') {
                            lookStatusText.textContent = "Écoute en cours...";
                        } else {
                            switchScreen('listening');
                        }
                    };

                    recognition.onresult = (event) => {
                        let segment = '';
                        for (let i = event.resultIndex; i < event.results.length; ++i) {
                            if (event.results[i].isFinal) segment += event.results[i][0].transcript + ' ';
                        }
                        if (segment) currentTranscript += segment;
                        console.log("Transcript final accumulé:", currentTranscript.trim());
                    };

                    recognition.onerror = (event) => {
                        console.error(`SpeechRecognition: onerror - ${event.error}`, event.message);
                        recognitionActive = false;
                        pttButton?.classList.remove('active');
                        let userMessage = `Erreur reconnaissance: ${event.error}`;
                        if (event.error === 'not-allowed') {
                            permissionGranted = false; updatePermissionStatus("Accès microphone refusé.", true); pttButton.disabled = true; userMessage = "Accès microphone refusé.";
                        } else if (event.error === 'no-speech') userMessage = "Je n'ai rien entendu.";
                        else if (event.error === 'audio-capture') userMessage = "Problème capture audio.";
                        else if (event.error === 'network') userMessage = "Erreur réseau reconnaissance.";

                        if (speechPromiseCallbacks?.reject && event.error !== 'aborted') {
                            speechPromiseCallbacks.reject(new Error(userMessage));
                        } else if (event.error !== 'aborted') {
                            const currentScreen = document.querySelector('.screen.active-screen')?.dataset.screenName;
                            if (currentScreen === 'look_and_ask') {
                                lookStatusText.textContent = userMessage; setTimeout(resetLookAskState, 3000);
                            } else { showErrorScreen(userMessage); }
                        }
                        speechPromiseCallbacks = null; isListening = false;
                    };

                    recognition.onend = () => {
                        console.log("SpeechRecognition: onend");
                        recognitionActive = false;
                        pttButton?.classList.remove('active');
                        if (speechPromiseCallbacks?.resolve) speechPromiseCallbacks.resolve(currentTranscript.trim());
                        speechPromiseCallbacks = null;
                        const currentScreen = document.querySelector('.screen.active-screen')?.dataset.screenName;
                        if (currentScreen === 'look_and_ask' && lookStatusText.textContent === "Écoute en cours...") {
                            lookStatusText.textContent = "Traitement...";
                        }
                    };
                } catch (error) {
                    console.error("Error initializing SpeechRecognition instance:", error);
                    updatePermissionStatus("Erreur init reconnaissance.", true); return false;
                }
                return true; // Success
            }

            // --- Start Speech Recognition ---
            async function startSpeechRecognition() {
                return new Promise(async (resolve, reject) => {
                    if (!speechApiAvailable || !recognition) return reject(new Error("Reco. non initialisée."));
                    if (recognitionActive) return reject(new Error("Écoute déjà en cours."));
                    if (permissionGranted === false) return reject(new Error("Accès microphone refusé."));

                    // Quick permission re-check
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                        stream.getTracks().forEach(track => track.stop());
                        permissionGranted = true; if (pttButton) pttButton.disabled = false;
                    } catch (err) {
                        permissionGranted = false; updatePermissionStatus("Accès microphone refusé.", true); if (pttButton) pttButton.disabled = true;
                        return reject(new Error("Accès microphone refusé."));
                    }

                    console.log("Attempting to start listening...");
                    speechPromiseCallbacks = { resolve, reject };
                    try {
                        recognition.start();
                    } catch (e) {
                        console.error("Immediate error on recognition.start():", e);
                        recognitionActive = false; speechPromiseCallbacks = null;
                        reject(new Error(`Erreur démarrage reco: ${e.message || e.name}`));
                    }
                });
            }

            // --- PTT Button Handlers ---
            function handlePttStart(event) {
                event.preventDefault();
                console.log("PTT Start");
                if (!speechApiAvailable || permissionGranted === false) { console.warn("PTT ignored: API/Permission issue."); return; }
                if (isListening || recognitionActive) { console.warn("PTT ignored: Already listening."); return; }

                // Check for multimodal context
                const currentScreen = document.querySelector('.screen.active-screen')?.dataset.screenName;
                isMultimodalPrompt = (currentScreen === 'look_and_ask' && !!capturedImageDataForPrompt);
                if (currentScreen === 'look_and_ask' && !capturedImageDataForPrompt) {
                    console.warn("PTT on Look&Ask screen but no image captured yet.");
                    lookStatusText.textContent = "Veuillez d'abord capturer une image.";
                    return; // Don't start listening without image
                }

                isListening = true;
                pttButton?.classList.add('active');
                pttButton?.setAttribute('aria-pressed', 'true');

                startSpeechRecognition()
                    .then(result => { console.log("Recognition promise resolved."); processSpeechResult(result); })
                    .catch(error => {
                        console.error("Recognition promise rejected:", error);
                        if (!error.message.includes("reconnaissance") && !error.message.includes("microphone")) {
                            if (isMultimodalPrompt) { lookStatusText.textContent = `Erreur: ${error.message}`; setTimeout(resetLookAskState, 3000); }
                            else { showErrorScreen(error.message); }
                        }
                        isListening = false; pttButton?.classList.remove('active'); pttButton?.setAttribute('aria-pressed', 'false');
                        isMultimodalPrompt = false; // Reset flag on error
                    });
            }

            function handlePttEnd(event) {
                event.preventDefault();
                console.log("PTT End");
                if (!isListening) { console.warn("PTT End ignored: Not listening."); return; }
                isListening = false;
                pttButton?.classList.remove('active');
                pttButton?.setAttribute('aria-pressed', 'false');

                if (recognitionActive && recognition) {
                    console.log("Stopping recognition via recognition.stop()...");
                    try { recognition.stop(); }
                    catch (e) {
                        console.error("Error on recognition.stop():", e);
                        if (speechPromiseCallbacks?.reject) speechPromiseCallbacks.reject(new Error("Échec arrêt reco."));
                        if (isMultimodalPrompt) { lookStatusText.textContent = "Erreur lors de l'arrêt."; setTimeout(resetLookAskState, 3000); }
                        else { showErrorScreen("Erreur lors de l'arrêt de l'écoute."); }
                        speechPromiseCallbacks = null; isMultimodalPrompt = false; // Reset flag
                    }
                } else {
                    console.warn("PTT End: Recognition not active.");
                    if (speechPromiseCallbacks?.reject) speechPromiseCallbacks.reject(new Error("Écoute terminée prématurément."));
                    speechPromiseCallbacks = null; isMultimodalPrompt = false; // Reset flag
                }
            }

            /**
             * Processes the final speech result (text or error), calls the appropriate Gemini function.
             * @param {string | Error} result - The recognized text or an Error object.
             */
            async function processSpeechResult(result) {
                console.log("Processing final speech result:", result);
                lastInteractionTime = Date.now(); // Update context timer

                const destinationScreen = isMultimodalPrompt ? 'look_and_ask' : 'response';
                if (!isMultimodalPrompt) switchScreen('response');
                else lookStatusText.textContent = "Traitement...";

                if (result instanceof Error) {
                    queryTextElement.textContent = "Erreur de reconnaissance";
                    responseTextElement.innerHTML = `<p class="error-message">${result.message}</p>`;
                    if (isMultimodalPrompt) { lookStatusText.textContent = `Erreur: ${result.message}`; setTimeout(resetLookAskState, 3000); }
                } else if (typeof result === 'string') {
                    const query = result.trim();
                    queryTextElement.textContent = query || "[Aucun texte reconnu]"; // Show query on standard response screen

                    if (!query) {
                        const noUnderstandMsg = "<p>Je n'ai pas compris ou rien entendu. Veuillez réessayer.</p>";
                        responseTextElement.innerHTML = noUnderstandMsg;
                        if (isMultimodalPrompt) { lookStatusText.textContent = "Rien entendu. Réessayez."; /* Don't reset image */ }
                    } else {
                        // Call API (normal or multimodal)
                        if (GEMINI_API_KEY && GEMINI_API_KEY !== 'YOUR_API_KEY') {
                            if (!isMultimodalPrompt) responseTextElement.innerHTML = "<p><i>Réflexion en cours...</i></p>";
                            try {
                                let answer;
                                if (isMultimodalPrompt && capturedImageDataForPrompt) {
                                    console.log("Calling Gemini with Image and Text");
                                    answer = await queryGeminiWithImage(query, capturedImageDataForPrompt);
                                    switchScreen('response'); // Show response on standard screen AFTER multimodal call
                                } else {
                                    console.log("Calling Gemini with Text only");
                                    answer = await queryGemini(query);
                                }
                                processApiResponse(answer); // Process function calls/text and display
                            } catch (geminiError) {
                                console.error("Gemini API call error:", geminiError);
                                const errorHtml = `<p class="error-message">Erreur IA : ${geminiError.message}</p>`;
                                responseTextElement.innerHTML = errorHtml;
                                if (isMultimodalPrompt) { lookStatusText.textContent = `Erreur IA: ${geminiError.message}`; setTimeout(resetLookAskState, 3000); }
                                if (isMultimodalPrompt) switchScreen('response'); // Ensure error shown on response screen
                            } finally {
                                // Clean up multimodal state AFTER API call attempt
                                if (isMultimodalPrompt) resetLookAskState();
                            }
                        } else {
                             // No API Key
                             const noApiKeyMsg = "<p><i>(Fonctionnalité IA non configurée)</i></p>";
                             responseTextElement.innerHTML = noApiKeyMsg;
                             addToHistory('user', query); addToHistory('model', "(Fonctionnalité IA non configurée)");
                             if (isMultimodalPrompt) { lookStatusText.textContent = "Fonctionnalité IA non configurée."; setTimeout(resetLookAskState, 3000); switchScreen('response'); }
                        }
                    }
                } else {
                     // Unexpected result type
                     const unexpectedMsg = '<p class="error-message">Problème inattendu (traitement voix).</p>';
                     queryTextElement.textContent = "Erreur Inattendue"; responseTextElement.innerHTML = unexpectedMsg;
                     if (isMultimodalPrompt) { lookStatusText.textContent = "Erreur inattendue."; setTimeout(resetLookAskState, 3000); switchScreen('response'); }
                }
                // Reset flag just in case
                 isMultimodalPrompt = false;
            }

            // --- Context and Function Calling ---

            /** Adds a message to the conversation history. */
            function addToHistory(role, text) {
                conversationHistory.push({ role, parts: [{ text }] });
                console.log("Added to history:", { role, text: text.substring(0, 50) + '...' });
            }

            /** Checks context timeout and clears history if needed. */
            function checkContextTimeout() {
                const now = Date.now();
                if (now - lastInteractionTime > CONTEXT_TIMEOUT) {
                    console.log("Context timeout. Clearing conversation history.");
                    conversationHistory = [];
                }
                lastInteractionTime = now; // Update on relevant interactions
            }

            /** Executes a local function based on the name provided by the AI. */
             function executeFunction(functionName) {
                console.log(`Executing function: ${functionName}`);
                try {
                    switch (functionName) {
                        // Existing functions
                        case 'start_timer': if (timerStartButton && !isTimerRunning) timerStartButton.click(); break;
                        case 'reset_timer': timerResetButton?.click(); break;
                        case 'play_pause_music': playPauseButton?.click(); break;
                        case 'prev_track': prevTrackButton?.click(); console.log("Simulating previous track"); break;
                        case 'next_track': nextTrackButton?.click(); console.log("Simulating next track"); break;
                        case 'capture_image': // Simple capture from Vision screen
                             if (document.querySelector('.screen.active-screen')?.dataset.screenName === 'vision') visionCaptureButton?.click();
                             else console.warn("Capture_image called outside Vision screen.");
                            break;
                        case 'go_home': switchScreen('home'); break;
                        case 'show_alarms': switchScreen('alarms'); break;
                        case 'show_timer': switchScreen('timer'); break;
                        case 'show_music': switchScreen('music'); break;
                        case 'show_vision': switchScreen('vision'); break;
                        // New functions
                        case 'show_calendar': switchScreen('calendar'); break;
                        case 'show_notes': switchScreen('notes'); break;
                        case 'save_current_note': saveNote(); break; // Call the save function
                        case 'show_gallery': switchScreen('gallery'); break;
                        case 'look_and_ask': switchScreen('look_and_ask'); break; // Switch to multimodal screen

                        default: console.warn(`Function "${functionName}" not recognized.`);
                    }
                } catch (error) { console.error(`Error executing function "${functionName}":`, error); }
            }

            /** Processes the API response, handles function calls, and displays text. */
            function processApiResponse(apiResponseText) {
                const functionCallRegex = /^\s*%\s*([a-zA-Z0-9_]+)\s*%([\s\S]*)/;
                const match = apiResponseText.match(functionCallRegex);
                let displayText = apiResponseText;

                if (match) {
                    const functionName = match[1].trim();
                    const remainingText = match[2].trim();
                    console.log(`Function call detected: ${functionName}`);
                    executeFunction(functionName);
                    displayText = remainingText || `(Action ${functionName} exécutée)`;
                }

                // Display the textual part of the response on the standard response screen
                displayMarkdownResponse(displayText, responseTextElement);

                // Add the RAW model response to history for context
                addToHistory('model', apiResponseText);
            }

            // --- Utility Functions (Timer, Music Simulation) ---
            function formatTime(seconds) { return `${Math.floor(seconds / 60).toString().padStart(2, '0')}:${(seconds % 60).toString().padStart(2, '0')}`; }
            timerStartButton?.addEventListener('click', () => {
                if (!timerDisplay) return;
                if (isTimerRunning) { clearInterval(timerInterval); timerStartButton.textContent = 'Reprendre'; }
                else { timerStartButton.textContent = 'Pause'; timerInterval = setInterval(() => { timerSeconds++; timerDisplay.textContent = formatTime(timerSeconds); }, 1000); }
                isTimerRunning = !isTimerRunning; timerStartButton.setAttribute('aria-label', isTimerRunning ? 'Mettre le minuteur en pause' : 'Reprendre le minuteur');
            });
            timerResetButton?.addEventListener('click', () => {
                if (!timerDisplay || !timerStartButton) return;
                clearInterval(timerInterval); timerSeconds = 0; isTimerRunning = false;
                timerDisplay.textContent = formatTime(timerSeconds); timerStartButton.textContent = 'Démarrer'; timerStartButton.setAttribute('aria-label', 'Démarrer le minuteur');
            });
            playPauseButton?.addEventListener('click', () => {
                const icon = playPauseButton?.querySelector('i'); if (!icon) return;
                isMusicPlaying = !isMusicPlaying;
                icon.classList.toggle('fa-play', !isMusicPlaying); icon.classList.toggle('fa-pause', isMusicPlaying);
                playPauseButton.setAttribute('aria-label', isMusicPlaying ? 'Pause' : 'Lecture');
                console.log(`Music ${isMusicPlaying ? 'playing' : 'paused'} (simulation)`);
            });
            prevTrackButton?.addEventListener('click', () => console.log("Previous track (simulation)"));
            nextTrackButton?.addEventListener('click', () => console.log("Next track (simulation)"));

            // --- Camera Management ---
            async function startVideoStream(targetScreenName) {
                if (videoStream) { console.log("Video stream potentially active, ensuring display."); attachVideoToScreen(targetScreenName); return true; }
                if (permissionGranted === false) { console.warn("Cannot start video: permission denied."); showErrorScreen("Accès caméra refusé."); return false; }

                try {
                    console.log(`Attempting to start video stream for ${targetScreenName}...`);
                    // Prefer back camera if available
                    const constraints = { video: { facingMode: "environment" } };
                    videoStream = await navigator.mediaDevices.getUserMedia(constraints)
                        .catch(async (e) => { // Fallback to default camera if environment fails
                            console.warn("Environment camera failed, trying default:", e);
                            if (e.name === 'OverconstrainedError' || e.name === 'NotFoundError') {
                                return navigator.mediaDevices.getUserMedia({ video: true });
                            }
                            throw e; // Rethrow other errors
                        });

                    videoElement.srcObject = videoStream;
                    videoElement.play();
                    await new Promise((resolve, reject) => { videoElement.onloadedmetadata = resolve; videoElement.onerror = reject; });
                    console.log("Video stream started successfully.");
                    attachVideoToScreen(targetScreenName);
                    return true;
                } catch (err) {
                    console.error("Error starting video stream:", err);
                    let userMessage = "Impossible de démarrer le flux vidéo.";
                     if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') userMessage = "Accès caméra refusé.";
                     else if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') userMessage = "Aucune caméra trouvée.";
                     else if (err.name === 'NotReadableError' || err.name === 'OverconstrainedError' || err.name === 'TrackStartError') userMessage = "Caméra déjà utilisée ou problème matériel.";
                     else userMessage = `Erreur caméra: ${err.message || err.name}`;
                    showErrorScreen(userMessage); videoStream = null; return false;
                }
            }

            function attachVideoToScreen(screenName) {
                const targetContainer = screenName === 'vision' ? visionCameraPlaceholder : (screenName === 'look_and_ask' ? lookCameraContainer : null);
                if (targetContainer) {
                    videoElement.style.display = 'block';
                    videoElement.classList.add('live-video');
                    targetContainer.appendChild(videoElement);
                    targetContainer.querySelector('i')?.style.setProperty('display', 'none', 'important'); // Hide icon forcefully
                } else {
                    videoElement.style.display = 'none'; // Hide if not on a camera screen
                    if (videoElement.parentElement) videoElement.remove(); // Detach if wrongly attached
                }
            }

            function stopVideoStream() {
                if (videoStream) {
                    console.log("Stopping video stream.");
                    videoStream.getTracks().forEach(track => track.stop());
                    videoStream = null; videoElement.srcObject = null;
                    if (videoElement.parentElement) videoElement.remove(); // Detach from DOM
                    videoElement.style.display = 'none';
                    // Restore placeholder icons
                    visionCameraPlaceholder?.querySelector('i')?.style.removeProperty('display');
                    lookCameraContainer?.querySelector('i')?.style.removeProperty('display');
                }
            }

            function captureImageFromVideo() {
                 if (!videoStream || !videoElement.videoWidth || !videoElement.videoHeight) {
                     console.error("Cannot capture: video stream not ready or dimensions invalid.");
                     showErrorScreen("Impossible de capturer l'image (flux vidéo non prêt)."); return null;
                 }
                 canvasElement.width = videoElement.videoWidth; canvasElement.height = videoElement.videoHeight;
                 try {
                    context.drawImage(videoElement, 0, 0, canvasElement.width, canvasElement.height);
                    const imageDataUrl = canvasElement.toDataURL('image/png'); // Use PNG for better quality
                    console.log('Image captured:', imageDataUrl.substring(0, 50) + '...');
                    return imageDataUrl;
                 } catch (e) { console.error("Error capturing or converting image:", e); showErrorScreen("Erreur lors de la capture."); return null; }
            }

            // --- Vision Screen Capture Handler ---
            visionCaptureButton?.addEventListener('click', () => {
                console.log('Vision Capture button clicked.');
                const imageDataUrl = captureImageFromVideo();
                if (imageDataUrl) {
                    capturedPhotos.push(imageDataUrl); // Add to gallery array
                    console.log(`Photo added to gallery. Total: ${capturedPhotos.length}`);
                    switchScreen('response');
                    queryTextElement.textContent = "Vision";
                    responseTextElement.innerHTML = "<p>Photo capturée et ajoutée à la galerie.</p>";
                    // Optionally switch to gallery: switchScreen('gallery');
                }
            });

            // --- Gallery Display ---
            function displayGallery() {
                if (!galleryContainer || !galleryEmptyMsg) return;
                galleryContainer.innerHTML = ''; // Clear previous items
                if (capturedPhotos.length === 0) {
                    galleryEmptyMsg.style.display = 'block';
                } else {
                    galleryEmptyMsg.style.display = 'none';
                    capturedPhotos.forEach((dataUrl, index) => {
                        const item = document.createElement('div'); item.className = 'gallery-item';
                        const img = document.createElement('img'); img.src = dataUrl; img.alt = `Photo capturée ${index + 1}`;
                        const downloadLink = document.createElement('a'); downloadLink.href = dataUrl; downloadLink.download = `rabbit_capture_${index + 1}.png`;
                        downloadLink.className = 'download-link'; downloadLink.innerHTML = '<i class="fas fa-download"></i>';
                        downloadLink.setAttribute('aria-label', 'Télécharger l\'image'); downloadLink.title = 'Télécharger';
                        item.appendChild(img); item.appendChild(downloadLink); galleryContainer.appendChild(item);
                    });
                }
            }

             // --- Notes Management ---
             function saveNote() {
                 if (notesTextarea) {
                     const noteContent = notesTextarea.value;
                     try {
                         localStorage.setItem('rabbit_note', noteContent);
                         console.log("Note saved to localStorage.");
                         if(notesFeedback) { notesFeedback.textContent = "Note enregistrée !"; setTimeout(() => { notesFeedback.textContent = ""; }, 2000); }
                     } catch (e) { console.error("Error saving note:", e); if(notesFeedback) notesFeedback.textContent = "Erreur sauvegarde."; }
                 }
             }
             function loadNote() {
                  if (notesTextarea) {
                     try {
                         const savedNote = localStorage.getItem('rabbit_note');
                         if (savedNote !== null) { notesTextarea.value = savedNote; console.log("Note loaded."); }
                     } catch (e) { console.error("Error loading note:", e); }
                 }
             }
             saveNoteButton?.addEventListener('click', saveNote); // Manual save

             // --- Look & Ask (Multimodal) Management ---
             function resetLookAskState() {
                 console.log("Resetting Look & Ask state.");
                 capturedImageDataForPrompt = null; isMultimodalPrompt = false;
                 lookStatusText.textContent = "Visez, puis capturez l'image.";
                 lookCaptureButton.disabled = false;
                 const preview = lookCameraContainer?.querySelector('.captured-image-preview');
                 if (preview) preview.remove();
                 // Ensure video is visible if stream active and attached
                 if (videoStream && videoElement.parentElement === lookCameraContainer) videoElement.style.display = 'block';
                 else if (!videoStream) lookCameraContainer?.querySelector('i')?.style.removeProperty('display'); // Show icon if no stream
             }

             lookCaptureButton?.addEventListener('click', () => {
                 console.log('Look & Ask Capture button clicked.');
                 const imageDataUrl = captureImageFromVideo();
                 if (imageDataUrl) {
                     capturedImageDataForPrompt = imageDataUrl;
                     lookStatusText.textContent = "Image capturée. Parlez maintenant pour poser votre question.";
                     lookCaptureButton.disabled = true; // Disable after capture

                     // Show preview overlay
                     const previewImg = document.createElement('img'); previewImg.src = imageDataUrl;
                     previewImg.className = 'captured-image-preview';
                     lookCameraContainer.appendChild(previewImg);
                     videoElement.style.display = 'none'; // Hide live video
                 } else { lookStatusText.textContent = "Échec de la capture. Réessayez."; }
             });

            // --- Gemini API Calls ---

            /** Calls Gemini API with text prompt and conversation history. */
            async function queryGemini(prompt) {
                console.log("Querying Gemini (Text):", prompt);
                checkContextTimeout();
                addToHistory('user', prompt); // Add current user query to history

                if (!GEMINI_API_KEY || GEMINI_API_KEY === 'YOUR_API_KEY') {
                    const errorMsg = "La clé API pour l'IA n'est pas configurée."; addToHistory('model', errorMsg); throw new Error(errorMsg);
                }

                // Build request content including system instruction and history
                const requestContents = [ { role: 'user', parts: [{ text: SYSTEM_INSTRUCTION }] }, ...conversationHistory ];

                try {
                    const response = await fetch(GEMINI_API_URL, {
                        method: 'POST', headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: requestContents,
                            safetySettings: [ // Basic safety settings
                                { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                                { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                                { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                                { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                            ]
                        })
                    });
                    const data = await response.json();

                    if (!response.ok) {
                        console.error('Gemini API Error:', response.status, data);
                        const errorMessage = data?.error?.message || `Erreur HTTP ${response.status}`;
                        const fullErrorMsg = `Erreur API IA : ${errorMessage}`;
                        addToHistory('model', `Erreur: ${fullErrorMsg}`); throw new Error(fullErrorMsg);
                    }
                    console.log("Gemini API Response (Raw):", data);

                    // Extract response text, handling blocked/empty cases
                    let responseText = "Désolé, je n'ai pas pu générer de réponse.";
                    if (data.candidates && data.candidates.length > 0) {
                        const candidate = data.candidates[0];
                        if (candidate.finishReason && candidate.finishReason !== 'STOP' && candidate.finishReason !== 'MAX_TOKENS') {
                            const reason = candidate.finishReason.replace(/_/g, ' ').toLowerCase();
                            responseText = (candidate.content?.parts?.[0]?.text || "") + `\n\n_(Réponse interrompue: ${reason}.)_`;
                        } else { responseText = candidate.content?.parts?.[0]?.text || "Format de réponse inattendu."; }
                    } else if (data.promptFeedback?.blockReason) {
                        const reason = data.promptFeedback.blockReason.replace(/_/g, ' ').toLowerCase();
                        responseText = `Réponse bloquée (${reason}).`;
                    }

                    // The response text is added to history by processApiResponse AFTER function parsing
                    return responseText;

                } catch (error) {
                    console.error('Error fetching Gemini (Text):', error);
                    if (!error.message.includes("Erreur API IA")) addToHistory('model', `Erreur réseau/fetch: ${error.message}`);
                    throw error; // Rethrow for processSpeechResult
                }
            }

            /** Calls Gemini API with multimodal input (image + text prompt). */
            async function queryGeminiWithImage(prompt, base64ImageData) {
                console.log("Querying Gemini (Multimodal):", prompt);
                checkContextTimeout();

                // Add ONLY the text part of the multimodal query to simple history for now
                // More complex history management could store image refs, but keep it simple here.
                addToHistory('user', prompt);

                if (!GEMINI_API_KEY || GEMINI_API_KEY === 'YOUR_API_KEY') {
                    const errorMsg = "La clé API pour l'IA n'est pas configurée."; addToHistory('model', errorMsg); throw new Error(errorMsg);
                }

                const pureBase64 = base64ImageData.split(',')[1]; // Remove data URL prefix

                // Build request: System instruction + history (excluding last text prompt) + multimodal prompt
                const requestContents = [
                    { role: 'user', parts: [{ text: SYSTEM_INSTRUCTION }] },
                    ...conversationHistory.slice(0, -1), // History BEFORE the current text prompt
                    { role: 'user', parts: [ // The actual multimodal prompt
                        { text: prompt },
                        { inline_data: { mime_type: 'image/png', data: pureBase64 } }
                    ]}
                ];

                // Update standard response screen during call
                 responseTextElement.innerHTML = "<p><i>Analyse de l'image et réflexion en cours...</i></p>";

                try {
                    // NOTE: Ensure your Gemini model (e.g., 1.5 Flash) supports multimodal input via generateContent
                    const response = await fetch(GEMINI_API_URL, {
                        method: 'POST', headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ contents: requestContents, safetySettings: [ /* ... same as text ... */ ] })
                    });
                    const data = await response.json();

                    if (!response.ok) {
                        console.error('Gemini API Error (Multimodal):', response.status, data);
                        const errorMessage = data?.error?.message || `Erreur HTTP ${response.status}`;
                        const fullErrorMsg = `Erreur IA (image) : ${errorMessage}`;
                        addToHistory('model', `Erreur: ${fullErrorMsg}`); throw new Error(fullErrorMsg);
                    }
                    console.log("Gemini API Response (Multimodal Raw):", data);

                    // Extract response text (similar logic to text-only)
                    let responseText = "Désolé, je n'ai pas pu analyser l'image.";
                     if (data.candidates && data.candidates.length > 0) {
                          const candidate = data.candidates[0];
                          if (candidate.finishReason && candidate.finishReason !== 'STOP' && candidate.finishReason !== 'MAX_TOKENS') {
                                const reason = candidate.finishReason.replace(/_/g, ' ').toLowerCase();
                                responseText = (candidate.content?.parts?.[0]?.text || "") + `\n\n_(Analyse interrompue: ${reason}.)_`;
                          } else { responseText = candidate.content?.parts?.[0]?.text || "Je n'ai pas de commentaire sur cette image."; }
                     } else if (data.promptFeedback?.blockReason) {
                          const reason = data.promptFeedback.blockReason.replace(/_/g, ' ').toLowerCase();
                          responseText = `Analyse bloquée (${reason}).`;
                     }

                    // Response text added to history by processApiResponse
                    return responseText;

                } catch (error) {
                    console.error('Error fetching Gemini (Multimodal):', error);
                    if (!error.message.includes("Erreur IA")) addToHistory('model', `Erreur réseau/fetch (image): ${error.message}`);
                    throw error; // Rethrow
                }
            }

            // --- Markdown Display ---
            function markdownToHtml(markdown) {
                 if (typeof markdown !== 'string') return '';
                let html = markdown;
                // Code blocks (```lang\ncode```) - Basic, no syntax highlighting
                html = html.replace(/```(?:[a-z]+\n)?([\s\S]*?)```/gs, (match, code) => `<pre><code>${code.trim().replace(/</g, '&lt;').replace(/>/g, '&gt;')}</code></pre>`);
                // Headings (#, ##, ###)
                html = html.replace(/^### (.*$)/gm, '<h3>$1</h3>'); html = html.replace(/^## (.*$)/gm, '<h2>$1</h2>'); html = html.replace(/^# (.*$)/gm, '<h1>$1</h1>');
                // HR (---, ***, ___)
                html = html.replace(/^(?:-{3,}|_{3,}|\*{3,})$/gm, '<hr>');
                // Blockquotes (> )
                html = html.replace(/^(?:> (?:.*\n?))+/gm, (match) => `<blockquote>${markdownToHtmlSimpleInline(match.replace(/^> /gm, '').trim())}</blockquote>`);
                 // Lists (*, -, +, 1.) - Basic handling, needs improvement for nested lists
                 html = html.replace(/^([*+-]) (.*(?:\n(?!\1 | {2,}).*)*)/gm, (match, marker, itemContent) => `<ul><li>${markdownToHtmlSimpleInline(itemContent.trim())}</li></ul>`);
                 html = html.replace(/^(\d+)\. (.*(?:\n(?!\d+\. | {2,}).*)*)/gm, (match, num, itemContent) => `<ol start="${num}"><li>${markdownToHtmlSimpleInline(itemContent.trim())}</li></ol>`);
                 html = html.replace(/<\/ul>\s*<ul>/g, ''); html = html.replace(/<\/ol>\s*<ol(?: start="\d+")?>/g, '');// Merge adjacent
                // Images (![alt](src))
                html = html.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, '<img src="$2" alt="$1">');
                // Links ([text](href))
                html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
                // Inline formatting
                html = markdownToHtmlSimpleInline(html);
                 // Paragraphs (split lines, wrap non-tags)
                 html = html.split('\n').map(line => {
                     line = line.trim(); if (line.length === 0) return '';
                     if (!line.match(/^<\/?(h[1-6]|ul|ol|li|blockquote|hr|pre|img|table|thead|tbody|tr|th|td|strong|em|code|a|br)/i)) return `<p>${line}</p>`;
                     return line;
                 }).join(''); // Join without newlines now handled by CSS/tags
                 // Cleanup empty paragraphs and merge adjacent blockquotes
                 html = html.replace(/<p>\s*<\/p>/g, ''); html = html.replace(/<\/blockquote>\s*<blockquote>/g, '');
                return html;
            }
            function markdownToHtmlSimpleInline(text) {
                text = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/__(.*?)__/g, '<strong>$1</strong>'); // Bold
                text = text.replace(/\*(.*?)\*/g, '<em>$1</em>').replace(/_(.*?)_/g, '<em>$1</em>'); // Italic
                text = text.replace(/`([^`]+)`/g, '<code>$1</code>'); // Inline code
                return text;
            }
            function displayMarkdownResponse(markdownText, element) {
                 if (element) {
                    element.innerHTML = markdownToHtml(markdownText); // Convert and display
                    element.style.opacity = 0; element.scrollTop = 0;
                    setTimeout(() => { element.style.opacity = 1; }, 50); // Fade in
                } else { console.error("Response display element not found."); }
            }

            // --- Scroll & Back Button Handlers ---
            scrollUpButton?.addEventListener('click', () => {
                const currentScreen = document.querySelector('.screen.active-screen')?.dataset.screenName;
                if (currentScreen === 'listening') return; // Prevent scroll during listening
                currentScreenIndex = (currentScreenIndex - 1 + screenOrder.length) % screenOrder.length;
                switchScreen(screenOrder[currentScreenIndex]);
            });
            scrollDownButton?.addEventListener('click', () => {
                const currentScreen = document.querySelector('.screen.active-screen')?.dataset.screenName;
                if (currentScreen === 'listening') return;
                currentScreenIndex = (currentScreenIndex + 1) % screenOrder.length;
                switchScreen(screenOrder[currentScreenIndex]);
            });
            document.querySelectorAll('.back-button').forEach(button => {
                button.addEventListener('click', (event) => {
                    const target = event.currentTarget.dataset.targetScreen || 'home';
                    switchScreen(target);
                });
            });

            // --- App Initialization ---
            async function initializeApp() {
                console.log("Initializing Rabbit R1 Web App...");
                switchScreen('home'); // Start at home screen
                loadNote(); // Load saved note on startup

                const speechReady = await initializeSpeechRecognition();

                if (speechReady && pttButton) {
                    // Attach PTT listeners (mouse & touch)
                    pttButton.addEventListener('mousedown', handlePttStart);
                    pttButton.addEventListener('mouseup', handlePttEnd);
                    pttButton.addEventListener('mouseleave', (e) => { if (isListening) handlePttEnd(e); }); // Handle mouse leaving button while pressed
                    pttButton.addEventListener('touchstart', handlePttStart, { passive: false }); // passive:false to allow preventDefault
                    pttButton.addEventListener('touchend', handlePttEnd);
                    pttButton.addEventListener('touchcancel', (e) => { if (isListening) handlePttEnd(e); }); // Handle touch cancel
                    console.log("PTT Handlers attached.");
                } else {
                    console.warn("PTT initialization failed (API not ready, permission denied, or button not found).");
                    if(pttButton) pttButton.disabled = true; // Ensure button is disabled
                }
                console.log("Application initialized.");
            }

            // Start the application
            initializeApp();

            // Cleanup: Stop video stream when leaving the page
            window.addEventListener('beforeunload', stopVideoStream);

        }); // End DOMContentLoaded
    </script>
</body>
</html>
