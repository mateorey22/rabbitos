<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Rabbit R1 Web App (v2)</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Press+Start+2P&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <style>
        /* Global Variables */
        :root {
            --rabbit-orange: #ff7e00;
            --off-white: #f8f8f8;
            --light-gray: #e0e0e0;
            --medium-gray: #cccccc;
            --dark-gray: #333333;
            --device-gray: #d0d0d0;
            --error-red: #d9534f;
            --success-green: #5cb85c;
            --info-blue: #5bc0de;
            --glass-bg: rgba(255, 255, 255, 0.3); /* Slightly more opaque */
            --glass-border: rgba(255, 255, 255, 0.5);
            --glass-blur: 6px;
        }

        /* Base Styles */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; overflow: hidden; /* Prevent body scroll */ }
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--off-white);
            color: var(--dark-gray);
            display: flex; justify-content: center; align-items: center;
            padding: 15px;
            -webkit-tap-highlight-color: transparent; /* Disable tap highlight */
            overscroll-behavior: none; /* Prevent pull-to-refresh */
        }

        /* Device Container */
        .device-container { width: 100%; max-width: 370px; margin: 0 auto; }
        .rabbit-device {
            background-color: var(--device-gray);
            border-radius: 28px; padding: 18px;
            box-shadow: 0 12px 25px rgba(0, 0, 0, 0.15), inset 0 -2px 4px rgba(0,0,0,0.1);
            display: flex; flex-direction: column; align-items: center; gap: 18px;
            border: 1px solid rgba(0,0,0,0.05);
        }

        /* Main Display */
        .main-display {
            background-color: var(--dark-gray); /* Darker bezel */
            border-radius: 18px; width: 100%;
            aspect-ratio: 1 / 1; overflow: hidden; position: relative;
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.2);
            border: 4px solid #444; /* Inner bezel */
        }

        /* Screens (General) */
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center;
            padding: 20px; opacity: 0; visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease, transform 0.3s ease;
            transform: translateX(20px);
            overflow-y: auto; /* Allow scrolling within screen */
            background-color: var(--off-white);
            color: var(--dark-gray);
            -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
            scrollbar-width: thin; /* Firefox */
            scrollbar-color: var(--medium-gray) var(--off-white); /* Firefox */
        }
        /* Scrollbar styling for WebKit */
        .screen::-webkit-scrollbar { width: 6px; }
        .screen::-webkit-scrollbar-track { background: var(--off-white); border-radius: 3px;}
        .screen::-webkit-scrollbar-thumb { background-color: var(--medium-gray); border-radius: 3px; border: 1px solid var(--off-white); }

        .active-screen { opacity: 1; visibility: visible; transform: translateX(0); }

        /* Back Button (Common) */
        .back-button {
            margin-top: auto; /* Push to bottom by default */
            padding: 8px 16px; background-color: var(--medium-gray);
            border: none; border-radius: 8px; color: var(--dark-gray); cursor: pointer;
            transition: background-color 0.2s, transform 0.1s ease; font-size: 14px; display: inline-flex;
            align-items: center; gap: 5px; z-index: 10; font-weight: 500;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        .back-button:hover { background-color: var(--light-gray); }
        .back-button:active { transform: scale(0.97); }

        /* Common Screen Title */
        .screen h2 {
            font-size: 20px; font-weight: 600; margin-bottom: 15px;
            text-align: center; width: 100%; color: var(--dark-gray);
            flex-shrink: 0; /* Prevent title from shrinking */
        }

        /* --- Specific Screen Styles --- */

        /* Home Screen */
        .home-screen { justify-content: center; text-align: center; }
        .datetime-display { font-size: 13px; color: #555; margin-bottom: 15px; font-weight: 500;}
        .greeting { font-size: 24px; font-weight: 600; margin-bottom: 10px; }
        .instruction { font-size: 16px; color: #666; margin-bottom: 15px; }
        .permission-status { font-size: 12px; color: #666; margin-top: 10px; min-height: 1.2em; font-weight: 500; padding: 0 10px;}
        .permission-status.error { color: var(--error-red); font-weight: 600; }
        .permission-status.success { color: var(--success-green); font-weight: 500; }

        /* Listening Screen */
        .listening-screen { justify-content: center; }
        .listening-indicator { text-align: center; }
        .listening-text { font-size: 18px; margin-bottom: 20px; animation: pulse 1.5s infinite alternate; }
        .waveform { display: flex; justify-content: center; align-items: center; gap: 5px; height: 40px; }
        .waveform span { display: inline-block; width: 5px; height: 20px; background-color: var(--rabbit-orange); border-radius: 2px; }
        .waveform span:nth-child(1) { animation: wave 0.5s infinite alternate; }
        .waveform span:nth-child(2) { animation: wave 0.5s infinite alternate 0.1s; }
        .waveform span:nth-child(3) { animation: wave 0.5s infinite alternate 0.2s; }
        .waveform span:nth-child(4) { animation: wave 0.5s infinite alternate 0.3s; }
        @keyframes wave { 0% { height: 10px; opacity: 0.7; } 100% { height: 30px; opacity: 1; } }
        @keyframes pulse { 0% { opacity: 0.6; } 100% { opacity: 1; } }

        /* Response Screen */
        .response-screen { justify-content: flex-start; align-items: flex-start; padding-bottom: 60px; /* Space for back button */ }
        .query-text { font-weight: 600; margin-bottom: 12px; align-self: flex-start; width: 100%; color: #555; border-bottom: 1px solid var(--light-gray); padding-bottom: 8px; word-wrap: break-word; font-size: 15px; }
        .response-text { width: 100%; font-size: 15px; line-height: 1.6; word-wrap: break-word; padding-bottom: 30px; /* Extra space at bottom */ }
        .response-text p:last-child { margin-bottom: 0; }
        .response-text p i { color: #666; }
        .response-text p.error-message { color: var(--error-red); font-weight: 600; background-color: rgba(217, 83, 79, 0.1); padding: 8px; border-radius: 4px; }
        .response-text p.info-message { color: var(--info-blue); font-weight: 500; background-color: rgba(91, 192, 222, 0.1); padding: 8px; border-radius: 4px; }
        /* Markdown Styles (via Marked.js) */
        .response-text h1, .response-text h2, .response-text h3 { margin-top: 1.2em; margin-bottom: 0.6em; line-height: 1.3; font-weight: 600;}
        .response-text h1 { font-size: 1.5em; border-bottom: 1px solid var(--light-gray); padding-bottom: 0.3em;}
        .response-text h2 { font-size: 1.3em; }
        .response-text h3 { font-size: 1.1em; }
        .response-text ul, .response-text ol { margin-left: 25px; margin-bottom: 1em; }
        .response-text li { margin-bottom: 0.5em; }
        .response-text code { background-color: #eee; padding: 0.2em 0.4em; border-radius: 3px; font-family: monospace; font-size: 0.9em; word-wrap: break-word; }
        .response-text pre { background-color: #eee; padding: 15px; border-radius: 5px; overflow-x: auto; margin-bottom: 1em; }
        .response-text pre code { background-color: transparent; padding: 0; font-size: 0.9em; word-wrap: normal; }
        .response-text blockquote { border-left: 4px solid var(--medium-gray); padding-left: 15px; margin: 1em 0; color: #555; font-style: italic; }
        .response-text table { border-collapse: collapse; width: 100%; margin: 1.5em 0; border: 1px solid var(--dark-gray); }
        .response-text th, .response-text td { border: 1px solid var(--dark-gray); padding: 10px; text-align: left; }
        .response-text th { background-color: var(--light-gray); font-weight: 600; }
        .response-text hr { border: none; border-top: 1px solid var(--light-gray); margin: 2em 0; }
        .response-text a { color: var(--rabbit-orange); text-decoration: none; font-weight: 500; }
        .response-text a:hover { text-decoration: underline; }
        .response-text img { max-width: 100%; height: auto; border-radius: 4px; margin: 0.5em 0; }

        /* Alarms Screen */
        .alarms-screen { justify-content: flex-start; }
        .alarms-list { list-style: none; width: 100%; padding: 0; }
        .alarms-list li { padding: 12px; border-bottom: 1px solid var(--light-gray); }

        /* Timer Screen */
        .timer-screen { justify-content: flex-start; }
        .timer-display { font-family: 'Press Start 2P', cursive; font-size: 36px; margin: 25px 0; color: var(--dark-gray); text-align: center; width: 100%; }
        .timer-status { font-size: 14px; color: #666; margin-bottom: 15px; text-align: center; min-height: 1.2em;}
        .timer-controls { display: flex; justify-content: center; gap: 15px; margin-bottom: 20px;}
        .timer-btn { padding: 10px 20px; background-color: var(--medium-gray); border: none; border-radius: 8px; color: var(--dark-gray); cursor: pointer; transition: background-color 0.2s, transform 0.1s ease; font-weight: 500; box-shadow: 0 1px 2px rgba(0,0,0,0.1);}
        .timer-btn:hover { background-color: var(--light-gray); }
        .timer-btn:active { transform: scale(0.97); }
        .timer-btn.active { background-color: var(--info-blue); color: white; }
        .timer-btn:disabled { background-color: var(--light-gray); color: #999; cursor: not-allowed; box-shadow: none; transform: none;}

        /* Music Screen */
        .music-screen { justify-content: flex-start; }
        .album-art { width: 130px; height: 130px; background-color: var(--medium-gray); border-radius: 12px; margin-bottom: 20px; display: flex; justify-content: center; align-items: center; font-size: 45px; color: #fff; background-image: linear-gradient(45deg, #aaa, #ccc); box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        .album-art::before { content: '\f001'; font-family: 'Font Awesome 6 Free'; font-weight: 900; }
        .track-info { text-align: center; margin-bottom: 20px; }
        .track-title { font-weight: 600; margin-bottom: 5px; font-size: 16px; }
        .artist-name { font-size: 14px; color: #666; }
        .music-controls { display: flex; gap: 20px; margin-bottom: 25px;}
        .music-btn { width: 45px; height: 45px; border-radius: 50%; background-color: var(--medium-gray); border: none; display: flex; justify-content: center; align-items: center; cursor: pointer; transition: background-color 0.2s, transform 0.1s ease; font-size: 18px; color: var(--dark-gray); box-shadow: 0 1px 3px rgba(0,0,0,0.1);}
        .music-btn:hover { background-color: var(--light-gray); }
        .music-btn:active { transform: scale(0.95); }
        .music-btn#play-pause.playing { background-color: var(--rabbit-orange); color: white; }

        /* --- Camera Screens Styling --- */
        .vision-screen, .look-at-this-screen {
            justify-content: flex-start; /* Align title at top */
            padding-bottom: 70px; /* More space for absolute back button */
        }
        /* Camera Container (Common for Vision & Look&Ask) */
        .camera-container {
            width: 100%;
            flex-grow: 1; /* Take remaining vertical space */
            background-color: var(--dark-gray); /* Dark background for camera */
            border-radius: 12px; /* Smoother corners */
            overflow: hidden; /* Clip video */
            position: relative; /* For positioning video and overlays */
            display: flex; justify-content: center; align-items: center;
            margin-bottom: 15px; /* Space before back button if not absolute */
            min-height: 150px; /* Ensure minimum height */
        }
        .camera-container i.placeholder-icon { /* Style for the placeholder icon */
            font-size: 54px; color: var(--medium-gray); z-index: 0;
        }
        /* Live Video Element */
        .live-video {
            display: block; /* Ensure it takes space */
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            object-fit: cover; /* Cover the container */
            z-index: 1; /* Below overlays */
            border-radius: 12px; /* Match container */
            background-color: #222; /* Fallback bg */
        }
        /* Captured Image Preview (Look&Ask) */
        .captured-image-preview {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            object-fit: cover; z-index: 2; /* Above video */
            border-radius: 12px;
        }
        /* Glassmorphism Overlay Style */
        .glass-overlay {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            background: var(--glass-bg);
            backdrop-filter: blur(var(--glass-blur));
            -webkit-backdrop-filter: blur(var(--glass-blur));
            border: 1px solid var(--glass-border);
            border-radius: 16px; /* More rounded */
            padding: 10px 18px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
            z-index: 3; /* Above video/preview */
            color: var(--dark-gray); /* Ensure text is readable */
            text-align: center;
            font-weight: 500;
        }
        /* Specific Overlays */
        .vision-capture-overlay { bottom: 18px; }
        .look-capture-overlay { bottom: 60px; }
        .look-status-overlay { bottom: 18px; font-size: 14px; min-width: 210px; padding: 8px 15px;}
        .capture-btn, .look-capture-btn { /* Style buttons within overlays */
            padding: 10px 20px; background-color: var(--rabbit-orange); border: none;
            border-radius: 12px; color: white; cursor: pointer;
            transition: background-color 0.2s, transform 0.1s ease; font-size: 16px; font-weight: 600;
            display: inline-flex; align-items: center; gap: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .capture-btn:hover, .look-capture-btn:hover { background-color: #e67200; }
        .capture-btn:active, .look-capture-btn:active { transform: scale(0.97); }
        .look-capture-btn:disabled { background-color: var(--medium-gray); cursor: not-allowed; box-shadow: none; opacity: 0.7;}

        /* Error Screen */
        .error-screen { justify-content: flex-start; text-align: center; padding-bottom: 60px; }
        .error-screen h2 { color: var(--error-red); }
        #error-message { margin-bottom: 20px; color: var(--error-red); font-weight: 500; background-color: rgba(217, 83, 79, 0.1); padding: 10px; border-radius: 8px; display: inline-block;}

        /* Calendar Screen */
        .calendar-screen { justify-content: flex-start; }
        .calendar-placeholder { width: 100%; max-width: 300px; height: 200px; background-color: #eee; border: 1px solid var(--light-gray); display: flex; justify-content: center; align-items: center; font-style: italic; color: #999; border-radius: 8px; }

        /* Notes Screen */
        .notes-screen { justify-content: flex-start; padding-bottom: 80px; }
        .notes-textarea { width: 100%; flex-grow: 1; margin-bottom: 15px; padding: 12px; border: 1px solid var(--light-gray); border-radius: 8px; font-family: inherit; font-size: 14px; resize: none; /* Disable manual resize */ box-shadow: inset 0 1px 3px rgba(0,0,0,0.05); }
        .save-note-btn { padding: 10px 20px; background-color: var(--success-green); color: white; border: none; border-radius: 8px; cursor: pointer; transition: background-color 0.2s, transform 0.1s ease; margin-bottom: 5px; font-weight: 500; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        .save-note-btn:hover { background-color: #4cae4c; }
        .save-note-btn:active { transform: scale(0.97); }
        #notes-feedback { font-size: 13px; color: var(--success-green); min-height: 1.2em; text-align: center; margin-bottom: 10px; font-weight: 500;}

        /* Gallery Screen */
        .gallery-screen { justify-content: flex-start; padding-bottom: 60px; }
        .gallery-container { display: grid; grid-template-columns: repeat(auto-fill, minmax(90px, 1fr)); gap: 12px; width: 100%; margin-top: 15px; }
        .gallery-item { position: relative; }
        .gallery-item img { display: block; width: 100%; height: 90px; object-fit: cover; border-radius: 8px; border: 1px solid var(--light-gray); box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .gallery-item .download-link { position: absolute; bottom: 6px; right: 6px; background-color: rgba(0,0,0,0.65); color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; justify-content: center; align-items: center; text-decoration: none; font-size: 11px; transition: background-color 0.2s, transform 0.1s ease; }
        .gallery-item .download-link:hover { background-color: rgba(0,0,0,0.8); }
        .gallery-item .download-link:active { transform: scale(0.9); }
        #gallery-empty-msg { font-style: italic; color: #999; text-align: center; width: 100%; margin-top: 20px; }

        /* Controls (Bottom) */
        .controls { display: flex; flex-direction: column; align-items: center; gap: 18px; width: 100%; margin-top: 5px; /* Small gap above controls */ }
        .ptt-button { width: 64px; height: 64px; border-radius: 50%; background-color: var(--rabbit-orange); border: none; display: flex; justify-content: center; align-items: center; cursor: pointer; color: white; font-size: 26px; box-shadow: 0 5px 12px rgba(255, 126, 0, 0.35); transition: transform 0.1s ease, background-color 0.2s, box-shadow 0.2s; user-select: none; -webkit-user-select: none; touch-action: manipulation; border: 2px solid rgba(255,255,255,0.5); }
        .ptt-button:active, .ptt-button.active { transform: scale(0.94); background-color: #e67200; box-shadow: 0 3px 6px rgba(255, 126, 0, 0.3); }
        .ptt-button.active { animation: ptt-pulse 1.5s infinite ease-in-out; }
        @keyframes ptt-pulse { 0% { box-shadow: 0 3px 6px rgba(255, 126, 0, 0.3); } 50% { box-shadow: 0 6px 15px rgba(255, 126, 0, 0.5); } 100% { box-shadow: 0 3px 6px rgba(255, 126, 0, 0.3); } }
        .scroll-controls { display: flex; gap: 25px; }
        .scroll-button { width: 44px; height: 44px; border-radius: 50%; background-color: var(--medium-gray); border: none; display: flex; justify-content: center; align-items: center; cursor: pointer; color: var(--dark-gray); transition: background-color 0.2s, transform 0.1s ease; user-select: none; -webkit-user-select: none; touch-action: manipulation; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        .scroll-button:active { background-color: var(--light-gray); transform: scale(0.95); }
        .ptt-button:disabled { background-color: var(--medium-gray); cursor: not-allowed; box-shadow: none; transform: none; animation: none; opacity: 0.7; border-color: rgba(0,0,0,0.1); }
        .ptt-button:disabled:active { transform: none; }

        /* Responsive */
        @media (max-width: 400px) {
            body { padding: 10px; }
            .device-container { max-width: 100%; }
            .rabbit-device { border-radius: 20px; padding: 15px; gap: 15px;}
            .main-display { border-radius: 16px; border-width: 3px; }
            .screen { padding: 15px; }
            .timer-display { font-size: 30px; }
            .album-art { width: 110px; height: 110px; }
            .response-text { font-size: 14px; }
            .gallery-container { grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 10px; }
            .gallery-item img { height: 80px; }
            .glass-overlay { padding: 8px 15px; border-radius: 14px;}
            .capture-btn, .look-capture-btn { font-size: 15px; padding: 9px 18px; }
            .look-status-overlay { font-size: 13px; min-width: 190px; }
            .ptt-button { width: 60px; height: 60px; font-size: 24px; }
            .scroll-button { width: 40px; height: 40px; }
            .scroll-controls { gap: 20px; }
        }
        @media (max-height: 680px) { /* Adjust layout for shorter screens */
             .rabbit-device { padding: 12px; gap: 12px; }
             .controls { gap: 12px; margin-top: 0;}
             .ptt-button { width: 58px; height: 58px; font-size: 22px; }
             .scroll-button { width: 38px; height: 38px; }
             .scroll-controls { gap: 18px; }
             .screen h2 { font-size: 18px; margin-bottom: 12px; }
             .home-screen .greeting { font-size: 22px; }
        }

    </style>
</head>
<body>
    <div class="device-container">
        <div class="rabbit-device">
            <div class="main-display" id="main-display">
                <div class="screen home-screen active-screen" data-screen-name="home">
                    <div class="datetime-display" id="datetime-display">--:-- | --- -- ----</div>
                    <div class="greeting">Bonjour Matéo</div>
                    <div class="instruction">Maintenez pour parler</div>
                    <div class="permission-status" id="permission-status">Vérification des permissions...</div>
                </div>

                <div class="screen listening-screen" data-screen-name="listening">
                    <div class="listening-indicator">
                        <div class="listening-text">Écoute en cours...</div>
                        <div class="waveform">
                            <span></span><span></span><span></span><span></span>
                        </div>
                    </div>
                </div>

                <div class="screen response-screen" data-screen-name="response">
                    <div class="query-text" id="query-text"></div>
                    <div class="response-text" id="response-text"></div>
                    <button class="back-button" data-target-screen="home" style="position: absolute; bottom: 15px; left: 50%; transform: translateX(-50%);"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                <div class="screen alarms-screen" data-screen-name="alarms">
                    <h2>Alarmes</h2>
                    <ul class="alarms-list">
                        <li>7:00 - Réveil</li>
                        <li>12:30 - Déjeuner</li>
                        <li>18:00 - Sport</li>
                    </ul>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                <div class="screen timer-screen" data-screen-name="timer">
                    <h2>Minuteur</h2>
                    <div class="timer-display" id="timer-display">00:00</div>
                    <div class="timer-status" id="timer-status">Prêt</div>
                    <div class="timer-controls">
                        <button class="timer-btn" id="timer-start-pause" aria-label="Démarrer le minuteur">Démarrer</button>
                        <button class="timer-btn" id="timer-reset" aria-label="Réinitialiser le minuteur">Réinitialiser</button>
                    </div>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                <div class="screen music-screen" data-screen-name="music">
                    <h2>Musique</h2>
                    <div class="album-art" role="img" aria-label="Pochette d'album"></div>
                    <div class="track-info">
                        <div class="track-title">Titre de la chanson</div>
                        <div class="artist-name">Nom de l'artiste</div>
                    </div>
                    <div class="music-controls">
                        <button class="music-btn" id="prev-track" aria-label="Piste précédente"><i class="fas fa-step-backward"></i></button>
                        <button class="music-btn" id="play-pause" aria-label="Lecture/Pause"><i class="fas fa-play"></i></button>
                        <button class="music-btn" id="next-track" aria-label="Piste suivante"><i class="fas fa-step-forward"></i></button>
                    </div>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                <div class="screen vision-screen" data-screen-name="vision">
                    <h2>Vision</h2>
                    <div class="camera-container" id="vision-camera-container">
                        <i class="fas fa-camera placeholder-icon"></i>
                        <div class="glass-overlay vision-capture-overlay">
                             <button class="capture-btn" id="vision-capture-btn" aria-label="Capturer l'image">
                                 <i class="fas fa-camera"></i> Capturer
                             </button>
                        </div>
                    </div>
                    <button class="back-button" data-target-screen="home" style="position: absolute; bottom: 15px; left: 50%; transform: translateX(-50%);"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                <div class="screen calendar-screen" data-screen-name="calendar">
                    <h2>Calendrier</h2>
                    <div class="calendar-placeholder">Placeholder Calendrier</div>
                    <button class="back-button" data-target-screen="home"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                <div class="screen notes-screen" data-screen-name="notes">
                    <h2>Notes</h2>
                    <textarea id="notes-textarea" class="notes-textarea" placeholder="Écrivez vos notes ici..."></textarea>
                    <button id="save-note-btn" class="save-note-btn"><i class="fas fa-save"></i> Enregistrer</button>
                    <div id="notes-feedback"></div>
                    <button class="back-button" data-target-screen="home" style="position: absolute; bottom: 15px; left: 50%; transform: translateX(-50%);"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                <div class="screen gallery-screen" data-screen-name="gallery">
                    <h2>Galerie Photos</h2>
                    <div id="gallery-container" class="gallery-container">
                        </div>
                    <p id="gallery-empty-msg" style="display: none;">Aucune photo capturée pour le moment.</p>
                    <button class="back-button" data-target-screen="home" style="position: absolute; bottom: 15px; left: 50%; transform: translateX(-50%);"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                 <div class="screen look-at-this-screen" data-screen-name="look_and_ask">
                    <h2>Regarder & Demander</h2>
                     <div class="camera-container" id="look-camera-container">
                         <i class="fas fa-camera placeholder-icon"></i>
                         <div class="glass-overlay look-capture-overlay">
                             <button class="look-capture-btn" id="look-capture-btn" aria-label="Capturer l'image pour l'IA">
                                 <i class="fas fa-camera"></i> Capturer
                             </button>
                         </div>
                         <div class="glass-overlay look-status-overlay" id="look-status-text">
                             Visez, puis capturez l'image.
                         </div>
                     </div>
                    <button class="back-button" data-target-screen="home" style="position: absolute; bottom: 15px; left: 50%; transform: translateX(-50%);"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

                <div class="screen error-screen" data-screen-name="error">
                    <h2>Erreur</h2>
                    <p id="error-message">Une erreur s'est produite.</p>
                    <button class="back-button" data-target-screen="home" style="position: absolute; bottom: 15px; left: 50%; transform: translateX(-50%);"><i class="fas fa-arrow-left"></i> Retour</button>
                </div>

            </div>

            <div class="controls">
                <button class="ptt-button" id="ptt-button" aria-label="Maintenir pour parler" aria-pressed="false" disabled>
                    <i class="fas fa-microphone"></i>
                </button>
                <div class="scroll-controls">
                    <button class="scroll-button" id="scroll-up" aria-label="Faire défiler vers le haut">
                        <i class="fas fa-chevron-up"></i>
                    </button>
                    <button class="scroll-button" id="scroll-down" aria-label="Faire défiler vers le bas">
                        <i class="fas fa-chevron-down"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Constants ---
            const CONTEXT_TIMEOUT = 5 * 60 * 1000; // 5 minutes
            // WARNING: Storing API keys client-side is insecure. Use a backend proxy in production.
            const GEMINI_API_KEY = 'AIzaSyBW5xJAUSzhJP5n5p8znA39QFDR8JqtwPY'; // REPLACE WITH YOUR ACTUAL KEY
            const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${GEMINI_API_KEY}`;
            const SCREEN_ORDER = [
                'home', 'calendar', 'notes', 'gallery', 'alarms',
                'timer', 'music', 'vision', 'look_and_ask' // Added look_and_ask here
            ];

            // --- DOM Elements ---
            const mainDisplay = document.getElementById('main-display');
            const pttButton = document.getElementById('ptt-button');
            const scrollUpButton = document.getElementById('scroll-up');
            const scrollDownButton = document.getElementById('scroll-down');
            const queryTextElement = document.getElementById('query-text');
            const responseTextElement = document.getElementById('response-text');
            const permissionStatusElement = document.getElementById('permission-status');
            const errorMessageElement = document.getElementById('error-message');
            const datetimeDisplay = document.getElementById('datetime-display');

            // Screen Elements (Dynamically collected)
            const screens = {};
            document.querySelectorAll('.screen').forEach(screen => {
                const screenName = screen.dataset.screenName;
                if (screenName) screens[screenName] = screen;
            });

            // Timer Elements
            const timerStartPauseButton = document.getElementById('timer-start-pause');
            const timerResetButton = document.getElementById('timer-reset');
            const timerDisplay = document.getElementById('timer-display');
            const timerStatus = document.getElementById('timer-status');

            // Music Elements
            const playPauseButton = document.getElementById('play-pause');
            const prevTrackButton = document.getElementById('prev-track');
            const nextTrackButton = document.getElementById('next-track');

            // Vision Elements
            const visionCaptureButton = document.getElementById('vision-capture-btn');
            const visionCameraContainer = document.getElementById('vision-camera-container');

            // Notes Elements
            const notesTextarea = document.getElementById('notes-textarea');
            const saveNoteButton = document.getElementById('save-note-btn');
            const notesFeedback = document.getElementById('notes-feedback');

            // Gallery Elements
            const galleryContainer = document.getElementById('gallery-container');
            const galleryEmptyMsg = document.getElementById('gallery-empty-msg');

            // Look & Ask Elements
            const lookCameraContainer = document.getElementById('look-camera-container');
            const lookCaptureButton = document.getElementById('look-capture-btn');
            const lookStatusText = document.getElementById('look-status-text');

            // --- State Variables ---
            let currentScreenIndex = 0;
            let isListening = false;
            let recognitionActive = false;
            let speechPromiseCallbacks = null;
            let recognition = null;
            let speechApiAvailable = false;
            let permissionGranted = null; // null (unchecked), true, false
            let conversationHistory = [];
            let lastInteractionTime = Date.now();
            let capturedPhotos = []; // In-memory gallery storage
            let capturedImageDataForPrompt = null; // Base64 image for multimodal
            let isMultimodalPrompt = false; // Flag for PTT handler in look&ask mode
            let isMusicPlaying = false;

            // Timer State
            let timerInterval = null;
            let timerSecondsRemaining = 0;
            let timerTotalDuration = 0; // Store originally set duration
            let isTimerRunning = false;

            // Media Elements (created once, attached/detached as needed)
            let videoStream = null;
            const videoElement = document.createElement('video');
            videoElement.setAttribute('playsinline', ''); // Essential for iOS inline playback
            videoElement.setAttribute('autoplay', ''); // Try to autoplay when attached
            videoElement.setAttribute('muted', ''); // Mute to allow autoplay without user gesture sometimes
            videoElement.classList.add('live-video');
            const canvasElement = document.createElement('canvas'); // For capturing frames
            const context = canvasElement.getContext('2d', { willReadFrequently: true }); // Optimize for frequent readbacks

            // --- System Instruction for Gemini (Pre-prompt) ---
            // Updated with new functions and argument parsing possibility
            const SYSTEM_INSTRUCTION = `Tu es un assistant vocal intégré dans une interface web simulant un appareil Rabbit R1.
            Tu peux répondre aux questions de l'utilisateur et exécuter certaines actions. Tu peux afficher du texte formaté en Markdown enrichi (listes, gras, italique, tableaux, etc.). Pour les questions simples ne nécessitant pas d'action, réponds directement en texte.
            Pour exécuter une action, commence ta réponse EXACTEMENT par "% nom_fonction(arguments_optionnels) %" suivi de ta réponse textuelle normale (qui peut être vide). Ne mets rien avant le %. Les arguments sont optionnels et entre parenthèses.
            N'utilise qu'une seule commande de fonction par réponse, au tout début.

            Les fonctions disponibles sont :
            - % start_timer % : Démarre ou reprend le minuteur (utilise la dernière durée définie ou une durée par défaut si aucune n'a été définie).
            - % pause_timer % : Met le minuteur en pause.
            - % reset_timer % : Réinitialise le minuteur à 0 ou à la dernière durée définie.
            - % set_timer(duration_seconds) % : Définit et démarre un minuteur pour une durée spécifique en secondes. Exemple: % set_timer(300) % pour 5 minutes.
            - % play_pause_music % : Met en lecture ou en pause la musique (simulation).
            - % prev_track % : Passe à la piste précédente (simulation).
            - % next_track % : Passe à la piste suivante (simulation).
            - % capture_image % : Prend une photo simple (depuis l'écran Vision) et l'ajoute à la galerie. Doit être sur l'écran Vision.
            - % go_home % : Affiche l'écran d'accueil.
            - % show_alarms % : Affiche l'écran des alarmes.
            - % show_timer % : Affiche l'écran du minuteur.
            - % show_music % : Affiche l'écran de musique.
            - % show_vision % : Affiche l'écran de vision (pour capture simple).
            - % show_calendar % : Affiche l'écran du calendrier (placeholder).
            - % show_notes % : Affiche l'écran des notes et charge la dernière note.
            - % save_current_note % : Sauvegarde le texte actuellement dans la zone de notes.
            - % show_gallery % : Affiche la galerie des photos capturées.
            - % look_and_ask % : Active le mode caméra spécial pour que l'utilisateur prenne une photo et pose une question dessus. Réponds avec un texte invitant.
            - % get_weather % : Affiche la météo actuelle (simulation).
            - % calculate(expression) % : Calcule une expression mathématique simple. Exemple: % calculate(5*8+2) %.

            Exemple 1: User: "mets un minuteur de 2 minutes" -> AI: "% set_timer(120) % Minuteur de 2 minutes démarré."
            Exemple 2: User: "quelle heure est-il ?" -> AI: "Il est [heure actuelle]." (pas de fonction)
            Exemple 3: User: "montre la galerie" -> AI: "% show_gallery % Voici vos photos."
            Exemple 4: User: "sauvegarde cette note" -> AI: "% save_current_note % Note sauvegardée."
            Exemple 5: User: "qu'est-ce que c'est ?" -> AI: "% look_and_ask % D'accord, montre-le moi. Capture l'image puis pose ta question."
            Exemple 6: User: "quel temps fait-il ?" -> AI: "% get_weather % Il fait beau et ensoleillé, 22°C."
            Exemple 7: User: "combien font 15 plus 30" -> AI: "% calculate(15+30) % 15 plus 30 égale 45."

            Adapte ta réponse textuelle après la commande pour confirmer l'action ou répondre à la question. Sois concis.`;

            // --- Core Functions ---

            /**
             * Switches the active screen, handling camera stream activation/deactivation.
             * @param {string} screenName - The target screen name (data-screen-name).
             * @param {boolean} [force=false] - Force switch even if already on the screen.
             */
            async function switchScreen(screenName, force = false) {
                const currentActiveScreen = document.querySelector('.screen.active-screen');
                const currentScreenName = currentActiveScreen?.dataset.screenName;

                if (currentScreenName === screenName && !force) {
                    console.log(`Already on screen: ${screenName}`);
                    return; // Already on the target screen
                }
                console.log(`Switching from ${currentScreenName || 'none'} to screen: ${screenName}`);

                // Stop ongoing operations on the old screen if necessary
                if (currentScreenName === 'listening' && recognitionActive) {
                    console.log("Screen switch interrupting listening, stopping recognition.");
                    stopSpeechRecognition(true); // Abort recognition
                }

                // Deactivate current screen
                currentActiveScreen?.classList.remove('active-screen');

                // Activate new screen
                const targetScreen = screens[screenName];
                if (targetScreen) {
                    targetScreen.classList.add('active-screen');
                    // Update current index for scroll navigation if it's in the main order
                    const navigableIndex = SCREEN_ORDER.indexOf(screenName);
                    if (navigableIndex !== -1) currentScreenIndex = navigableIndex;
                } else {
                    console.error(`Screen "${screenName}" not found. Switching to home.`);
                    screenName = 'home';
                    screens.home.classList.add('active-screen');
                    currentScreenIndex = 0;
                }

                // Handle screen-specific setup/cleanup
                if (screenName === 'response' || screenName === 'notes' || screenName === 'gallery') {
                    targetScreen.scrollTop = 0; // Scroll to top
                }
                if (screenName === 'gallery') displayGallery();
                if (screenName === 'notes') loadNote();
                if (screenName === 'timer') updateTimerDisplay(); // Ensure display is correct

                // Manage camera stream
                const needsCamera = ['vision', 'look_and_ask'].includes(screenName);
                const cameraWasActive = ['vision', 'look_and_ask'].includes(currentScreenName);

                // Detach video from previous container *before* potentially stopping or reattaching
                if (cameraWasActive && videoElement.parentElement) {
                     const oldContainer = videoElement.parentElement;
                     videoElement.remove(); // Detach from previous parent
                     oldContainer.querySelector('.placeholder-icon')?.style.removeProperty('display'); // Restore icon
                }

                if (needsCamera) {
                    await startVideoStream(screenName); // Start/ensure stream is running & attached
                } else if (cameraWasActive) {
                    stopVideoStream(); // Stop stream if leaving a camera screen
                }

                 // Reset multimodal state if leaving look_and_ask screen
                 if (currentScreenName === 'look_and_ask' && screenName !== 'look_and_ask') {
                     resetLookAskState();
                 }
                 // Reset timer state visually if leaving timer screen while running
                 if (currentScreenName === 'timer' && screenName !== 'timer' && isTimerRunning) {
                     // Timer continues in background, but update button state if needed when returning
                 }
            }

            /**
             * Displays an error message on the dedicated error screen or fallback.
             * @param {string} message - The error message to display.
             * @param {string} [origin='Unknown'] - Where the error originated (e.g., 'Speech', 'Camera', 'API').
             */
            function showErrorScreen(message, origin = 'Unknown') {
                const fullMessage = `[${origin} Error] ${message}`;
                console.error("Displaying error:", fullMessage);

                if (errorMessageElement && screens.error) {
                    errorMessageElement.textContent = message; // Show user-friendly message
                    screens.error.querySelector('h2').textContent = `Erreur (${origin})`; // Show origin in title
                    switchScreen('error', true); // Force switch to error screen
                } else {
                    // Fallback: Show error on the response screen
                    console.warn("Error screen elements not found. Fallback display.");
                    switchScreen('response', true);
                    queryTextElement.textContent = `Erreur (${origin})`;
                    responseTextElement.innerHTML = `<p class="error-message">${message}</p>`;
                }
                lastInteractionTime = Date.now(); // Reset context timer on error
            }

            /**
             * Updates the permission status message on the home screen.
             * @param {string} message - The message to display.
             * @param {'info' | 'error' | 'success' | 'warning'} type - Type of message for styling.
             */
            function updatePermissionStatus(message, type = 'info') {
                if (permissionStatusElement) {
                    permissionStatusElement.textContent = message;
                    permissionStatusElement.className = 'permission-status'; // Reset classes
                    if (type !== 'info') {
                        permissionStatusElement.classList.add(type);
                    }
                    console.log(`Permission status updated: "${message}" (type: ${type})`);
                }
            }

            // --- Speech Recognition ---
            function setupSpeechRecognition() {
                const SpeechRecognitionAPI = window.SpeechRecognition || window.webkitSpeechRecognition;
                if (!SpeechRecognitionAPI) {
                    console.error("Speech Recognition API not supported.");
                    speechApiAvailable = false;
                    return false;
                }

                recognition = new SpeechRecognitionAPI();
                recognition.lang = 'fr-FR';
                recognition.continuous = false; // Process after user stops talking
                recognition.interimResults = false; // We only want final results
                speechApiAvailable = true;

                recognition.onstart = () => {
                    console.log("SpeechRecognition: onstart");
                    recognitionActive = true;
                    pttButton?.classList.add('active');
                    pttButton?.setAttribute('aria-pressed', 'true');
                    const currentScreen = document.querySelector('.screen.active-screen')?.dataset.screenName;
                    if (currentScreen === 'look_and_ask') {
                        lookStatusText.textContent = "Écoute en cours...";
                    } else {
                        switchScreen('listening');
                    }
                };

                recognition.onresult = (event) => {
                    const transcript = event.results[event.results.length - 1][0].transcript.trim();
                    console.log("SpeechRecognition: onresult - Final transcript:", transcript);
                    if (speechPromiseCallbacks?.resolve) {
                        speechPromiseCallbacks.resolve(transcript);
                    } else {
                        console.warn("Recognition result received but no promise callbacks found.");
                        // If PTT was released very quickly, process anyway
                        if (!isListening && transcript) processSpeechResult(transcript);
                    }
                    speechPromiseCallbacks = null; // Consume callbacks
                };

                recognition.onerror = (event) => {
                    console.error(`SpeechRecognition: onerror - ${event.error}`, event.message);
                    let userMessage = `Erreur reconnaissance: ${event.error}`;
                    let shouldShowErrorScreen = true;

                    if (event.error === 'not-allowed' || event.error === 'service-not-allowed') {
                        permissionGranted = false;
                        updatePermissionStatus("Accès microphone refusé.", 'error');
                        if (pttButton) pttButton.disabled = true;
                        userMessage = "Accès microphone refusé.";
                        shouldShowErrorScreen = false; // Status already updated
                    } else if (event.error === 'no-speech') {
                        userMessage = "Je n'ai rien entendu. Veuillez réessayer.";
                    } else if (event.error === 'audio-capture') {
                        userMessage = "Problème matériel de capture audio.";
                    } else if (event.error === 'network') {
                        userMessage = "Erreur réseau pendant la reconnaissance.";
                    } else if (event.error === 'aborted') {
                        userMessage = "Écoute annulée.";
                        shouldShowErrorScreen = false; // Don't show error for manual abort
                        console.log("Recognition aborted, likely intentional.");
                    }

                    if (speechPromiseCallbacks?.reject) {
                        speechPromiseCallbacks.reject(new Error(userMessage));
                    } else if (shouldShowErrorScreen) {
                        const currentScreen = document.querySelector('.screen.active-screen')?.dataset.screenName;
                        if (currentScreen === 'look_and_ask') {
                            lookStatusText.textContent = userMessage;
                            setTimeout(resetLookAskState, 3000); // Reset state after showing error
                        } else {
                            showErrorScreen(userMessage, 'Speech');
                        }
                    }

                    // Cleanup state regardless of error type
                    recognitionActive = false;
                    isListening = false;
                    pttButton?.classList.remove('active');
                    pttButton?.setAttribute('aria-pressed', 'false');
                    speechPromiseCallbacks = null;
                };

                recognition.onend = () => {
                    console.log("SpeechRecognition: onend");
                    recognitionActive = false;
                    // Check if we were expecting a result but didn't get one via onresult (e.g., quick release)
                    if (speechPromiseCallbacks?.resolve) {
                        console.log("Recognition ended without a final result callback, resolving with empty string.");
                        speechPromiseCallbacks.resolve(""); // Resolve with empty if no result was captured
                    }
                    speechPromiseCallbacks = null; // Ensure callbacks are cleared
                    isListening = false; // Ensure listening state is false
                    pttButton?.classList.remove('active');
                    pttButton?.setAttribute('aria-pressed', 'false');

                    // Handle UI update if listening screen was active
                    const currentScreen = document.querySelector('.screen.active-screen')?.dataset.screenName;
                     if (currentScreen === 'listening') {
                         // Don't automatically switch back here, wait for processing result
                         console.log("Recognition ended, waiting for processing before screen switch.");
                     } else if (currentScreen === 'look_and_ask' && lookStatusText.textContent === "Écoute en cours...") {
                         // If ended while listening on look/ask, indicate processing
                         lookStatusText.textContent = "Traitement...";
                     }
                };

                return true;
            }

            async function checkAndRequestPermissions() {
                updatePermissionStatus("Vérification des permissions...", 'info');
                if (permissionGranted === true) {
                     updatePermissionStatus("Permissions accordées.", 'success');
                     if (pttButton) pttButton.disabled = false;
                     return true; // Already granted
                }
                if (permissionGranted === false) {
                    updatePermissionStatus("Permissions refusées.", 'error');
                    if (pttButton) pttButton.disabled = true;
                    return false; // Already denied
                }

                // Check HTTPS / Secure Context
                if (window.location.protocol !== 'https:' && !['localhost', '127.0.0.1'].includes(window.location.hostname)) {
                    updatePermissionStatus("Connexion non sécurisée (HTTPS requis).", 'error');
                    permissionGranted = false;
                    if (pttButton) pttButton.disabled = true;
                    return false;
                }
                if (!navigator.mediaDevices?.getUserMedia) {
                    updatePermissionStatus("Accès aux périphériques (getUserMedia) non supporté.", 'error');
                    permissionGranted = false;
                    if (pttButton) pttButton.disabled = true;
                    return false;
                 }

                try {
                    updatePermissionStatus("Demande des permissions...", 'info');
                    // Request both audio and video upfront
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
                    permissionGranted = true;
                    updatePermissionStatus("Permissions accordées.", 'success');
                    if (pttButton) pttButton.disabled = false;
                    // Stop the tracks immediately, we just needed the permission
                    stream.getTracks().forEach(track => track.stop());
                    return true;
                } catch (err) {
                    console.error("Permission request failed:", err);
                    permissionGranted = false;
                    let userMessage = "Impossible d'accéder aux périphériques.";
                    if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                        userMessage = "Accès microphone/caméra refusé.";
                    } else if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') {
                        userMessage = "Aucun microphone/caméra trouvé.";
                    } else if (err.name === 'NotReadableError') {
                        userMessage = "Périphérique déjà utilisé ou problème matériel.";
                    } else {
                        userMessage = `Erreur accès (${err.name})`;
                    }
                    updatePermissionStatus(userMessage, 'error');
                    if (pttButton) pttButton.disabled = true;
                    return false;
                }
            }

            function startSpeechRecognition() {
                return new Promise(async (resolve, reject) => {
                    if (!speechApiAvailable || !recognition) {
                        return reject(new Error("Reconnaissance vocale non initialisée."));
                    }
                    if (recognitionActive) {
                        console.warn("Attempted to start recognition while already active.");
                        return reject(new Error("Écoute déjà en cours."));
                    }
                     if (permissionGranted !== true) {
                         console.warn("Attempted to start recognition without permission.");
                         // Try asking again just in case state changed
                         const hasPermission = await checkAndRequestPermissions();
                         if (!hasPermission) {
                             return reject(new Error("Accès microphone refusé."));
                         }
                     }

                    console.log("Attempting to start listening...");
                    speechPromiseCallbacks = { resolve, reject };
                    try {
                        recognition.start();
                        // onstart event will handle UI changes
                    } catch (e) {
                        console.error("Immediate error on recognition.start():", e);
                        recognitionActive = false;
                        speechPromiseCallbacks = null; // Clear callbacks on immediate failure
                        pttButton?.classList.remove('active');
                        pttButton?.setAttribute('aria-pressed', 'false');
                        reject(new Error(`Erreur démarrage reco: ${e.message || e.name}`));
                    }
                });
            }

            /**
             * Stops speech recognition.
             * @param {boolean} [abort=false] - If true, uses abort() which might prevent final result.
             */
            function stopSpeechRecognition(abort = false) {
                 if (recognitionActive && recognition) {
                     console.log(`Stopping recognition (abort: ${abort})...`);
                     try {
                         if (abort) {
                             recognition.abort(); // Force stop, may prevent onresult
                         } else {
                             recognition.stop(); // Graceful stop, should trigger onresult/onend
                         }
                         // Let the onend/onerror handlers manage state cleanup
                     } catch (e) {
                         console.error(`Error on recognition.${abort ? 'abort' : 'stop'}():`, e);
                         // Force cleanup if stop/abort fails
                         recognitionActive = false;
                         isListening = false;
                         pttButton?.classList.remove('active');
                         pttButton?.setAttribute('aria-pressed', 'false');
                         if (speechPromiseCallbacks?.reject) {
                             speechPromiseCallbacks.reject(new Error("Échec arrêt reconnaissance."));
                         }
                         speechPromiseCallbacks = null;
                     }
                 } else {
                     console.log("Stop recognition called but not active.");
                     // Ensure state is clean even if called unnecessarily
                     isListening = false;
                     pttButton?.classList.remove('active');
                     pttButton?.setAttribute('aria-pressed', 'false');
                 }
            }

            // --- PTT Button Handlers ---
            function handlePttStart(event) {
                event.preventDefault(); // Prevent potential double actions or scrolling
                console.log("PTT Start");
                if (!speechApiAvailable || permissionGranted !== true) {
                    console.warn("PTT ignored: API unavailable or permission denied.");
                    // Optionally trigger a permission re-check here
                    checkAndRequestPermissions();
                    return;
                }
                if (isListening || recognitionActive) {
                    console.warn("PTT ignored: Already listening/recognizing.");
                    return;
                }

                // Check for multimodal context
                const currentScreen = document.querySelector('.screen.active-screen')?.dataset.screenName;
                isMultimodalPrompt = (currentScreen === 'look_and_ask' && !!capturedImageDataForPrompt);

                if (currentScreen === 'look_and_ask' && !capturedImageDataForPrompt) {
                    console.warn("PTT on Look&Ask screen but no image captured yet.");
                    lookStatusText.textContent = "Veuillez d'abord capturer une image.";
                    // Flash the capture button maybe?
                    lookCaptureButton.style.transition = 'none';
                    lookCaptureButton.style.backgroundColor = '#ffc107'; // Yellow flash
                    setTimeout(() => {
                        lookCaptureButton.style.transition = 'background-color 0.2s, transform 0.1s ease';
                        lookCaptureButton.style.removeProperty('background-color');
                    }, 300);
                    return; // Don't start listening without image
                }

                isListening = true; // Set listening state immediately

                startSpeechRecognition()
                    .then(result => {
                        console.log("Recognition promise resolved with:", result ? `"${result}"` : "(empty)");
                        processSpeechResult(result); // Process the final transcript
                    })
                    .catch(error => {
                        console.error("Recognition promise rejected:", error);
                        // Error display is handled by onerror/onend, but ensure state is clean
                        isListening = false;
                        isMultimodalPrompt = false; // Reset flag on error
                        // Ensure button is visually reset if error occurred before onend/onerror fired
                        pttButton?.classList.remove('active');
                        pttButton?.setAttribute('aria-pressed', 'false');
                    });
            }

            function handlePttEnd(event) {
                event.preventDefault();
                console.log("PTT End");
                if (!isListening) {
                    console.warn("PTT End ignored: Not in listening state.");
                    return;
                }
                isListening = false; // Update state immediately
                // Don't visually deactivate button here, let onend/onerror handle it for consistency

                if (recognitionActive) {
                    stopSpeechRecognition(); // Request graceful stop
                } else {
                    console.warn("PTT End: Recognition was not active.");
                    // If recognition stopped prematurely (e.g., error), ensure callbacks are cleared
                     if (speechPromiseCallbacks?.reject) {
                         speechPromiseCallbacks.reject(new Error("Écoute terminée prématurément."));
                     }
                     speechPromiseCallbacks = null;
                     isMultimodalPrompt = false; // Reset flag
                     // Ensure button is visually reset
                     pttButton?.classList.remove('active');
                     pttButton?.setAttribute('aria-pressed', 'false');
                }
            }

            /**
             * Processes the final speech result, calls Gemini, and handles the response.
             * @param {string} query - The recognized text.
             */
            async function processSpeechResult(query) {
                console.log("Processing final speech result:", query);
                lastInteractionTime = Date.now(); // Update context timer

                const wasMultimodal = isMultimodalPrompt; // Store before resetting
                const imageToSend = capturedImageDataForPrompt; // Store before resetting

                // Determine where to show initial feedback
                const feedbackScreen = wasMultimodal ? 'look_and_ask' : 'response';
                if (feedbackScreen === 'look_and_ask') {
                    lookStatusText.textContent = "Traitement...";
                } else {
                    // Switch to response screen immediately for normal queries
                    switchScreen('response');
                    queryTextElement.textContent = query || "[Aucun texte reconnu]";
                    responseTextElement.innerHTML = "<p><i>Réflexion en cours...</i></p>";
                }

                // Reset multimodal state *before* API call (except image data)
                isMultimodalPrompt = false;
                // capturedImageDataForPrompt will be cleared *after* the API call

                if (!query && !wasMultimodal) {
                    console.log("Empty query received.");
                    responseTextElement.innerHTML = "<p>Je n'ai pas compris ou rien entendu. Veuillez réessayer.</p>";
                    // No need to call API for empty query
                    return; // Exit early
                }
                 if (!query && wasMultimodal) {
                    console.log("Empty query received during multimodal.");
                    lookStatusText.textContent = "Rien entendu. Réessayez.";
                    // Don't reset image, allow user to try speaking again
                    return; // Exit early
                }

                // --- API Call ---
                if (GEMINI_API_KEY && GEMINI_API_KEY !== 'YOUR_API_KEY') {
                    try {
                        let answer;
                        if (wasMultimodal && imageToSend) {
                            console.log("Calling Gemini with Image and Text");
                            // Display query on response screen now for multimodal
                            switchScreen('response'); // Switch now to show query/response
                            queryTextElement.textContent = query;
                            responseTextElement.innerHTML = "<p><i>Analyse de l'image et réflexion...</i></p>";
                            answer = await queryGeminiWithImage(query, imageToSend);
                        } else {
                            console.log("Calling Gemini with Text only");
                            answer = await queryGemini(query);
                        }
                        processApiResponse(answer, query); // Process function calls/text and display

                    } catch (geminiError) {
                        console.error("Gemini API call failed:", geminiError);
                        // Ensure error is shown on the response screen
                        switchScreen('response', true); // Force switch if not already there
                        queryTextElement.textContent = query; // Show the query that failed
                        responseTextElement.innerHTML = `<p class="error-message">Erreur IA : ${geminiError.message}</p>`;
                        // Add raw error to history if needed
                        addToHistory('user', query);
                        addToHistory('model', `Erreur IA: ${geminiError.message}`);
                    } finally {
                        // Clean up multimodal state AFTER API call attempt
                        if (wasMultimodal) {
                            resetLookAskState(); // Clears image data, resets UI
                        }
                    }
                } else {
                    // No API Key
                    console.warn("Gemini API key not configured.");
                    switchScreen('response', true); // Show message on response screen
                    queryTextElement.textContent = query;
                    const noApiKeyMsg = "<p class='info-message'><i>Fonctionnalité IA non configurée (clé API manquante).</i></p>";
                    responseTextElement.innerHTML = noApiKeyMsg;
                    addToHistory('user', query);
                    addToHistory('model', "(Fonctionnalité IA non configurée)");
                    if (wasMultimodal) {
                        // Still need to reset look/ask state
                        resetLookAskState();
                    }
                }
            }


            // --- Context and Function Calling ---

            /** Adds a message to the conversation history. */
            function addToHistory(role, text) {
                // Basic validation
                if (!role || typeof text !== 'string') {
                    console.warn("Invalid input to addToHistory:", { role, text });
                    return;
                }
                conversationHistory.push({ role, parts: [{ text }] });
                // Optional: Limit history size
                // const MAX_HISTORY = 10; // Keep last 5 pairs (user+model) + system prompt
                // if (conversationHistory.length > MAX_HISTORY) {
                //     conversationHistory = conversationHistory.slice(-(MAX_HISTORY));
                // }
                console.log("Added to history:", { role, text: text.substring(0, 60) + (text.length > 60 ? '...' : '') });
            }

            /** Checks context timeout and clears history if needed. */
            function checkContextTimeout() {
                const now = Date.now();
                if (now - lastInteractionTime > CONTEXT_TIMEOUT) {
                    console.log(`Context timeout (${CONTEXT_TIMEOUT / 1000}s). Clearing conversation history.`);
                    conversationHistory = [];
                    // Optionally add a message to the user?
                    // responseTextElement.innerHTML += "<p><i>(Nouvelle conversation démarrée.)</i></p>";
                }
                // We update lastInteractionTime on *successful* user input processing or API response
            }

            /**
             * Executes a local function based on the name and arguments provided by the AI.
             * @param {string} functionName - The name of the function to execute.
             * @param {string | null} argsString - The arguments string (content inside parentheses), or null if none.
             */
            function executeFunction(functionName, argsString) {
                console.log(`Executing function: ${functionName}` + (argsString !== null ? ` with args: "${argsString}"` : ''));
                try {
                    switch (functionName) {
                        case 'start_timer':
                            if (timerStartPauseButton && !isTimerRunning) {
                                // Start with remaining time or default if 0
                                if (timerSecondsRemaining <= 0) timerSecondsRemaining = timerTotalDuration || 60; // Default 1 min if never set
                                startTimer();
                            }
                            break;
                        case 'pause_timer':
                            if (isTimerRunning) pauseTimer();
                            break;
                        case 'reset_timer':
                            resetTimer();
                            break;
                        case 'set_timer':
                            const duration = parseInt(argsString, 10);
                            if (!isNaN(duration) && duration > 0) {
                                setTimer(duration);
                            } else {
                                console.warn(`Invalid duration for set_timer: ${argsString}`);
                                // Optionally provide feedback to user?
                            }
                            break;
                        case 'play_pause_music':
                            playPauseButton?.click();
                            break;
                        case 'prev_track':
                            prevTrackButton?.click(); console.log("Simulating previous track");
                            break;
                        case 'next_track':
                            nextTrackButton?.click(); console.log("Simulating next track");
                            break;
                        case 'capture_image':
                             if (document.querySelector('.screen.active-screen')?.dataset.screenName === 'vision') {
                                 visionCaptureButton?.click();
                             } else {
                                 console.warn("Capture_image called outside Vision screen.");
                                 // Optionally switch screen and then capture? Needs careful handling.
                             }
                            break;
                        case 'go_home': switchScreen('home'); break;
                        case 'show_alarms': switchScreen('alarms'); break;
                        case 'show_timer': switchScreen('timer'); break;
                        case 'show_music': switchScreen('music'); break;
                        case 'show_vision': switchScreen('vision'); break;
                        case 'show_calendar': switchScreen('calendar'); break;
                        case 'show_notes': switchScreen('notes'); break;
                        case 'save_current_note':
                            if (document.querySelector('.screen.active-screen')?.dataset.screenName === 'notes') {
                                saveNote();
                            } else {
                                // Maybe switch to notes first? Or just save if textarea has content?
                                console.warn("Save note called outside Notes screen.");
                                // For now, only save if on the screen.
                            }
                            break;
                        case 'show_gallery': switchScreen('gallery'); break;
                        case 'look_and_ask': switchScreen('look_and_ask'); break;
                        case 'get_weather':
                            // Placeholder - replace with actual API call if desired
                            const weatherText = "Simulation: Il fait actuellement beau et ensoleillé, 22°C à Crans-Montana.";
                            displayMarkdownResponse(weatherText, responseTextElement);
                            // Need to manually add this response to history as it doesn't come from Gemini
                            addToHistory('model', weatherText); // Add the simulated response
                            break;
                        case 'calculate':
                            if (argsString) {
                                try {
                                    // VERY IMPORTANT: Using eval is a security risk if the AI can be manipulated
                                    // to provide malicious code. For a real application, use a safe math parser library.
                                    // This is acceptable ONLY in this sandboxed simulation context.
                                    const expression = argsString.replace(/[^-()\d/*+.]/g, ''); // Basic sanitization
                                    if (expression) {
                                        const result = eval(expression); // SECURITY RISK
                                        const calcText = `${expression} = ${result}`;
                                        displayMarkdownResponse(`Le résultat est : ${result}`, responseTextElement);
                                        addToHistory('model', `Le résultat est : ${result}`); // Add calc result
                                    } else {
                                        throw new Error("Expression invalide après nettoyage.");
                                    }
                                } catch (e) {
                                    console.error("Error evaluating calculation:", e);
                                    displayMarkdownResponse(`Désolé, je ne peux pas calculer cela (${e.message}).`, responseTextElement);
                                    addToHistory('model', `Erreur de calcul: ${e.message}`);
                                }
                            } else {
                                displayMarkdownResponse("Veuillez fournir une expression à calculer.", responseTextElement);
                                addToHistory('model', "Expression manquante pour le calcul.");
                            }
                            break;

                        default:
                            console.warn(`Function "${functionName}" not recognized.`);
                            // Optionally inform the user the function isn't implemented
                            // displayMarkdownResponse(`Désolé, la fonction '${functionName}' n'est pas encore implémentée.`, responseTextElement);
                    }
                } catch (error) {
                    console.error(`Error executing function "${functionName}":`, error);
                    // Show error to user on response screen
                    showErrorScreen(`Erreur interne lors de l'exécution de '${functionName}'.`, 'Function');
                }
            }

            /**
             * Processes the API response, handles function calls, and displays text.
             * @param {string} apiResponseText - The raw text response from the Gemini API.
             * @param {string} originalQuery - The user's query that led to this response.
             */
            function processApiResponse(apiResponseText, originalQuery) {
                // Add user query to history *before* processing the response
                addToHistory('user', originalQuery);

                // Regex to capture function name and optional arguments within parentheses
                const functionCallRegex = /^\s*%\s*([a-zA-Z0-9_]+)(?:\((.*?)\))?\s*%([\s\S]*)/;
                const match = apiResponseText.match(functionCallRegex);
                let displayText = apiResponseText; // Default to full response if no function call

                if (match) {
                    const functionName = match[1].trim();
                    // argsString will be null if no parentheses, or the content inside (can be empty)
                    const argsString = match[2] !== undefined ? match[2].trim() : null;
                    const remainingText = match[3] ? match[3].trim() : ''; // Text after the function call

                    console.log(`Function call detected: ${functionName}, Args: ${argsString}, Remaining Text: "${remainingText}"`);

                    // Execute the function. Function execution might update the display itself (e.g., weather).
                    executeFunction(functionName, argsString);

                    // Use the remaining text for display, or provide default confirmation if empty
                    displayText = remainingText || `(Action '${functionName}' exécutée.)`;

                    // Add the RAW model response (including function call) to history
                    addToHistory('model', apiResponseText);

                    // Only display the remaining text *unless* the function itself handled the display (like weather/calc)
                    // This check is a bit basic, might need refinement.
                    if (functionName !== 'get_weather' && functionName !== 'calculate') {
                         displayMarkdownResponse(displayText, responseTextElement);
                    } else if (!remainingText && (functionName === 'get_weather' || functionName === 'calculate')) {
                        // If function handled display and there's no remaining text, clear the "Thinking..." message
                        responseTextElement.innerHTML = ''; // Clear thinking message
                    } else if (remainingText) {
                        // If function handled display AND there's remaining text, append it
                         responseTextElement.innerHTML += markdownToHtml(remainingText); // Append remaining text
                    }


                } else {
                    // No function call, just display the text and add raw response to history
                    displayMarkdownResponse(displayText, responseTextElement);
                    addToHistory('model', apiResponseText); // Add the plain text response
                }
                 lastInteractionTime = Date.now(); // Update context timer after processing response
            }


            // --- Utility Functions ---

            /** Formats seconds into MM:SS */
            function formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }

            /** Safely parses markdown to HTML using Marked.js */
            function markdownToHtml(markdown) {
                if (typeof markdown !== 'string') return '';
                try {
                    // Configure marked for safety and basic GFM
                    marked.setOptions({
                        gfm: true, // Enable GitHub Flavored Markdown
                        breaks: true, // Convert single line breaks to <br>
                        sanitize: false, // IMPORTANT: Rely on Gemini's safety, DO NOT enable sanitize here as it breaks formatting. Ensure API safety settings are strict.
                        smartypants: true // Use "smart" typographic punctuation
                    });
                    return marked.parse(markdown);
                } catch (e) {
                    console.error("Error parsing Markdown:", e);
                    // Fallback to simple text display on error
                    return `<p>${markdown.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</p>`;
                }
            }

            /** Displays formatted HTML response, ensuring scrolling */
            function displayMarkdownResponse(markdownText, element) {
                 if (element) {
                     element.innerHTML = markdownToHtml(markdownText || "(Pas de réponse textuelle)"); // Provide fallback
                     // Animate opacity for smooth appearance
                     element.style.opacity = 0;
                     element.scrollTop = 0; // Scroll to top before showing
                     setTimeout(() => {
                         element.style.transition = 'opacity 0.3s ease';
                         element.style.opacity = 1;
                     }, 50); // Short delay to allow rendering before fade-in
                 } else {
                     console.error("Response display element not found.");
                 }
            }

            /** Updates the date and time display */
            function updateDateTime() {
                if (!datetimeDisplay) return;
                const now = new Date();
                const timeString = now.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });
                const dateString = now.toLocaleDateString('fr-FR', { weekday: 'short', day: 'numeric', month: 'short', year: 'numeric' });
                datetimeDisplay.textContent = `${timeString} | ${dateString}`;
            }


            // --- Timer Functions ---
            function updateTimerDisplay() {
                if (!timerDisplay) return;
                timerDisplay.textContent = formatTime(timerSecondsRemaining);

                if (isTimerRunning) {
                    timerStatus.textContent = `En cours (${formatTime(timerTotalDuration)})`;
                    timerStartPauseButton.textContent = 'Pause';
                    timerStartPauseButton.classList.add('active');
                    timerStartPauseButton.setAttribute('aria-label', 'Mettre le minuteur en pause');
                } else {
                    if (timerSecondsRemaining <= 0) {
                         timerStatus.textContent = timerTotalDuration > 0 ? `Terminé (${formatTime(timerTotalDuration)})` : "Prêt";
                    } else {
                         timerStatus.textContent = `En pause (${formatTime(timerSecondsRemaining)} / ${formatTime(timerTotalDuration)})`;
                    }
                    timerStartPauseButton.textContent = timerSecondsRemaining > 0 ? 'Reprendre' : 'Démarrer';
                    timerStartPauseButton.classList.remove('active');
                    timerStartPauseButton.setAttribute('aria-label', timerSecondsRemaining > 0 ? 'Reprendre le minuteur' : 'Démarrer le minuteur');
                }
                // Disable start/pause if timer is at 0 and not running
                timerStartPauseButton.disabled = timerSecondsRemaining <= 0 && !isTimerRunning && timerTotalDuration <= 0;
            }

            function timerTick() {
                if (timerSecondsRemaining > 0) {
                    timerSecondsRemaining--;
                    updateTimerDisplay();
                } else {
                    clearInterval(timerInterval);
                    timerInterval = null;
                    isTimerRunning = false;
                    updateTimerDisplay();
                    console.log("Timer finished!");
                    // Optional: Play a sound or show notification
                    timerStatus.textContent = `Terminé ! (${formatTime(timerTotalDuration)})`;
                    // Simple visual alert
                    timerDisplay.style.transition = 'none';
                    timerDisplay.style.color = 'var(--success-green)';
                    setTimeout(() => {
                         timerDisplay.style.transition = 'color 0.5s ease';
                         timerDisplay.style.removeProperty('color');
                    }, 1500);
                }
            }

            function startTimer() {
                if (isTimerRunning || timerSecondsRemaining <= 0) return;
                console.log(`Starting timer with ${timerSecondsRemaining}s remaining.`);
                isTimerRunning = true;
                // Ensure total duration is set if starting from 0
                if (timerTotalDuration <= 0) timerTotalDuration = timerSecondsRemaining;
                updateTimerDisplay(); // Update UI immediately
                timerInterval = setInterval(timerTick, 1000);
            }

            function pauseTimer() {
                if (!isTimerRunning) return;
                console.log("Pausing timer.");
                isTimerRunning = false;
                clearInterval(timerInterval);
                timerInterval = null;
                updateTimerDisplay();
            }

            function resetTimer() {
                console.log("Resetting timer.");
                clearInterval(timerInterval);
                timerInterval = null;
                isTimerRunning = false;
                // Reset to the last set duration, or 0 if none was set
                timerSecondsRemaining = timerTotalDuration;
                updateTimerDisplay();
            }

            function setTimer(durationSeconds) {
                console.log(`Setting timer to ${durationSeconds}s.`);
                clearInterval(timerInterval); // Stop any existing timer
                timerInterval = null;
                isTimerRunning = false;
                timerTotalDuration = durationSeconds;
                timerSecondsRemaining = durationSeconds;
                startTimer(); // Start immediately after setting
                switchScreen('timer'); // Show the timer screen
            }

            timerStartPauseButton?.addEventListener('click', () => {
                if (isTimerRunning) {
                    pauseTimer();
                } else {
                    // If timer is at 0, maybe require a duration to be set first?
                    // For now, let's restart with the last duration or a default
                    if (timerSecondsRemaining <= 0) {
                        timerSecondsRemaining = timerTotalDuration || 60; // Restart with last duration or 1 min default
                        if (timerTotalDuration <= 0) timerTotalDuration = timerSecondsRemaining; // Set total if it was 0
                    }
                    startTimer();
                }
            });
            timerResetButton?.addEventListener('click', resetTimer);


            // --- Music Simulation ---
            playPauseButton?.addEventListener('click', () => {
                const icon = playPauseButton?.querySelector('i'); if (!icon) return;
                isMusicPlaying = !isMusicPlaying;
                icon.classList.toggle('fa-play', !isMusicPlaying);
                icon.classList.toggle('fa-pause', isMusicPlaying);
                playPauseButton.classList.toggle('playing', isMusicPlaying); // Add class for styling
                playPauseButton.setAttribute('aria-label', isMusicPlaying ? 'Pause' : 'Lecture');
                console.log(`Music ${isMusicPlaying ? 'playing' : 'paused'} (simulation)`);
            });
            prevTrackButton?.addEventListener('click', () => console.log("Previous track (simulation)"));
            nextTrackButton?.addEventListener('click', () => console.log("Next track (simulation)"));


            // --- Camera Management ---
            async function startVideoStream(targetScreenName) {
                if (videoStream) {
                    console.log("Video stream already active, ensuring attachment.");
                    attachVideoToContainer(targetScreenName); // Re-attach if necessary
                    return true;
                }
                if (permissionGranted !== true) {
                    console.warn("Cannot start video: permission denied.");
                    const hasPermission = await checkAndRequestPermissions();
                    if (!hasPermission) {
                         showErrorScreen("Accès caméra refusé.", 'Camera');
                         return false;
                    }
                }

                const targetContainer = screenName === 'vision' ? visionCameraContainer : (screenName === 'look_and_ask' ? lookCameraContainer : null);
                if (!targetContainer) return false; // Should not happen if called correctly

                // Show placeholder while starting
                targetContainer.querySelector('.placeholder-icon')?.style.removeProperty('display'); // Hide if visible
                // Optional: Add a loading indicator?

                try {
                    console.log(`Attempting to start video stream for ${targetScreenName}...`);
                    // Prefer environment camera, fallback to default
                    const constraints = { video: { facingMode: "environment" } };
                    videoStream = await navigator.mediaDevices.getUserMedia(constraints)
                        .catch(async (e) => {
                            console.warn("Environment camera failed, trying default:", e.name);
                            // Only fallback if it's a known constraint issue
                            if (e.name === 'OverconstrainedError' || e.name === 'NotFoundError' || e.name === 'NotReadableError') {
                                return navigator.mediaDevices.getUserMedia({ video: true });
                            }
                            throw e; // Re-throw other errors
                        });

                    videoElement.srcObject = videoStream;
                    // Play is called automatically by the 'autoplay' attribute

                    // Wait for metadata to ensure dimensions are available
                    await new Promise((resolve, reject) => {
                        videoElement.onloadedmetadata = resolve;
                        videoElement.onerror = (e) => reject(new Error(`Video element error: ${e.message || 'Unknown'}`));
                        // Timeout for metadata loading
                        setTimeout(() => reject(new Error("Timeout waiting for video metadata")), 5000);
                    });

                    console.log("Video stream started successfully.");
                    attachVideoToContainer(targetScreenName); // Attach after successful start
                    return true;

                } catch (err) {
                    console.error("Error starting video stream:", err);
                    stopVideoStream(); // Ensure cleanup on failure
                    let userMessage = "Impossible de démarrer la caméra.";
                     if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') userMessage = "Accès caméra refusé.";
                     else if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') userMessage = "Aucune caméra trouvée.";
                     else if (err.name === 'NotReadableError' || err.name === 'TrackStartError' || err.name === 'AbortError') userMessage = "Caméra déjà utilisée ou problème matériel.";
                     else userMessage = `Erreur caméra (${err.message || err.name})`;

                    // Show error on the specific screen's container if possible
                    targetContainer.querySelector('.placeholder-icon')?.style.setProperty('display', 'block', 'important'); // Show icon again
                    targetContainer.querySelector('.placeholder-icon')?.classList.add('fa-video-slash'); // Indicate error
                    targetContainer.querySelector('.placeholder-icon')?.classList.remove('fa-camera');
                    // Don't switch to global error screen, show contextually
                    // showErrorScreen(userMessage, 'Camera');
                    return false;
                }
            }

            function attachVideoToContainer(screenName) {
                const targetContainer = screenName === 'vision' ? visionCameraContainer : (screenName === 'look_and_ask' ? lookCameraContainer : null);
                if (targetContainer && videoStream) {
                    if (videoElement.parentElement !== targetContainer) {
                        videoElement.remove(); // Remove from previous parent if any
                        targetContainer.appendChild(videoElement);
                        console.log(`Video attached to ${screenName} container.`);
                    }
                    // Ensure placeholder icon is hidden
                    targetContainer.querySelector('.placeholder-icon')?.style.setProperty('display', 'none', 'important');
                    // Reset error icon state if present
                    targetContainer.querySelector('.placeholder-icon')?.classList.remove('fa-video-slash');
                    targetContainer.querySelector('.placeholder-icon')?.classList.add('fa-camera');
                } else {
                    console.warn("Attach video called with no target container or no stream.");
                }
            }

            function stopVideoStream() {
                if (videoStream) {
                    console.log("Stopping video stream.");
                    videoStream.getTracks().forEach(track => track.stop());
                    videoStream = null;
                }
                // Clean up video element source and remove from DOM
                videoElement.srcObject = null;
                if (videoElement.parentElement) {
                    const parent = videoElement.parentElement;
                    videoElement.remove();
                    // Restore placeholder icon in the container it was removed from
                    parent.querySelector('.placeholder-icon')?.style.removeProperty('display');
                }
                // Explicitly restore icons on both potential containers just in case
                visionCameraContainer?.querySelector('.placeholder-icon')?.style.removeProperty('display');
                lookCameraContainer?.querySelector('.placeholder-icon')?.style.removeProperty('display');
                 // Reset error icon state
                 visionCameraContainer?.querySelector('.placeholder-icon')?.classList.remove('fa-video-slash');
                 visionCameraContainer?.querySelector('.placeholder-icon')?.classList.add('fa-camera');
                 lookCameraContainer?.querySelector('.placeholder-icon')?.classList.remove('fa-video-slash');
                 lookCameraContainer?.querySelector('.placeholder-icon')?.classList.add('fa-camera');
            }

            /** Captures an image from the currently active video stream */
            function captureImageFromVideo() {
                if (!videoStream || !videoElement.videoWidth || !videoElement.videoHeight || !videoElement.srcObject) {
                    console.error("Cannot capture: video stream not ready or dimensions unavailable.");
                     showErrorScreen("Impossible de capturer (flux vidéo non prêt).", 'Camera');
                    return null;
                }
                // Set canvas dimensions to match video
                canvasElement.width = videoElement.videoWidth;
                canvasElement.height = videoElement.videoHeight;
                try {
                    // Draw the current video frame onto the canvas
                    context.drawImage(videoElement, 0, 0, canvasElement.width, canvasElement.height);
                    // Get the image data as a PNG Base64 string
                    const imageDataUrl = canvasElement.toDataURL('image/png');
                    console.log('Image captured successfully.'); // Don't log the full data URL
                    return imageDataUrl;
                } catch (e) {
                    console.error("Error capturing or converting image:", e);
                    showErrorScreen("Erreur lors de la capture de l'image.", 'Camera');
                    return null;
                }
            }

            // --- Vision Screen Capture Handler ---
            visionCaptureButton?.addEventListener('click', () => {
                console.log('Vision Capture button clicked.');
                const imageDataUrl = captureImageFromVideo();
                if (imageDataUrl) {
                    capturedPhotos.push(imageDataUrl);
                    console.log(`Photo added to gallery. Total: ${capturedPhotos.length}`);
                    // Provide feedback on the response screen
                    switchScreen('response');
                    queryTextElement.textContent = "Vision";
                    responseTextElement.innerHTML = "<p>Photo capturée et ajoutée à la galerie.</p>";
                } else {
                    console.error("Failed to capture image for gallery.");
                    // Error is shown by captureImageFromVideo
                }
            });

            // --- Gallery Display ---
            function displayGallery() {
                if (!galleryContainer || !galleryEmptyMsg) return;
                galleryContainer.innerHTML = ''; // Clear previous items
                if (capturedPhotos.length === 0) {
                    galleryEmptyMsg.style.display = 'block';
                } else {
                    galleryEmptyMsg.style.display = 'none';
                    // Display in reverse order (newest first)
                    capturedPhotos.slice().reverse().forEach((dataUrl, index) => {
                         const originalIndex = capturedPhotos.length - 1 - index; // Get original index for download name
                         const item = document.createElement('div'); item.className = 'gallery-item';
                         const img = document.createElement('img'); img.src = dataUrl; img.alt = `Photo capturée ${originalIndex + 1}`;
                         img.loading = 'lazy'; // Lazy load images

                         const downloadLink = document.createElement('a');
                         downloadLink.href = dataUrl;
                         downloadLink.download = `rabbit_capture_${originalIndex + 1}.png`;
                         downloadLink.className = 'download-link';
                         downloadLink.innerHTML = '<i class="fas fa-download"></i>';
                         downloadLink.setAttribute('aria-label', 'Télécharger l\'image');
                         downloadLink.title = 'Télécharger';
                         // Prevent navigation for the link itself
                         downloadLink.addEventListener('click', (e) => e.stopPropagation());

                         item.appendChild(img);
                         item.appendChild(downloadLink);
                         galleryContainer.appendChild(item);
                    });
                }
            }

            // --- Notes Management ---
            function saveNote() {
                 if (notesTextarea) {
                     const noteContent = notesTextarea.value;
                     try {
                         localStorage.setItem('rabbit_note', noteContent);
                         console.log("Note saved to localStorage.");
                         if(notesFeedback) {
                             notesFeedback.textContent = "Note enregistrée !";
                             notesFeedback.style.color = 'var(--success-green)';
                             setTimeout(() => { notesFeedback.textContent = ""; }, 2500);
                         }
                     } catch (e) {
                         console.error("Error saving note:", e);
                         if(notesFeedback) {
                             notesFeedback.textContent = "Erreur sauvegarde (localStorage plein?).";
                             notesFeedback.style.color = 'var(--error-red)';
                         }
                     }
                 }
            }
            function loadNote() {
                 if (notesTextarea) {
                     try {
                         const savedNote = localStorage.getItem('rabbit_note');
                         if (savedNote !== null) {
                             notesTextarea.value = savedNote;
                             console.log("Note loaded from localStorage.");
                         } else {
                             notesTextarea.value = ''; // Clear if no saved note
                         }
                     } catch (e) {
                         console.error("Error loading note:", e);
                         notesTextarea.value = ''; // Clear on error
                     }
                 }
            }
            saveNoteButton?.addEventListener('click', saveNote);

            // --- Look & Ask (Multimodal) Management ---
            function resetLookAskState() {
                 console.log("Resetting Look & Ask state.");
                 capturedImageDataForPrompt = null;
                 isMultimodalPrompt = false; // Ensure flag is reset

                 if (lookStatusText) lookStatusText.textContent = "Visez, puis capturez l'image.";
                 if (lookCaptureButton) lookCaptureButton.disabled = false;

                 // Remove preview image if it exists
                 const preview = lookCameraContainer?.querySelector('.captured-image-preview');
                 if (preview) preview.remove();

                 // Ensure video is visible if stream is active and attached to this container
                 if (videoStream && videoElement.parentElement === lookCameraContainer) {
                     videoElement.style.display = 'block';
                 } else if (!videoStream) {
                     // If no stream, ensure placeholder is visible
                     lookCameraContainer?.querySelector('.placeholder-icon')?.style.removeProperty('display');
                 }
            }

            lookCaptureButton?.addEventListener('click', () => {
                 console.log('Look & Ask Capture button clicked.');
                 const imageDataUrl = captureImageFromVideo();
                 if (imageDataUrl) {
                     capturedImageDataForPrompt = imageDataUrl; // Store for API call
                     if (lookStatusText) lookStatusText.textContent = "Image capturée. Parlez maintenant.";
                     if (lookCaptureButton) lookCaptureButton.disabled = true; // Prevent recapture until reset

                     // Remove existing preview first
                     const existingPreview = lookCameraContainer?.querySelector('.captured-image-preview');
                     if (existingPreview) existingPreview.remove();

                     // Show new preview overlay
                     const previewImg = document.createElement('img');
                     previewImg.src = imageDataUrl;
                     previewImg.className = 'captured-image-preview';
                     lookCameraContainer?.appendChild(previewImg);

                     // Hide live video feed underneath
                     videoElement.style.display = 'none';
                 } else {
                     console.error("Failed to capture image for Look & Ask.");
                     if (lookStatusText) lookStatusText.textContent = "Échec de la capture. Réessayez.";
                     // Error is shown by captureImageFromVideo
                 }
            });

            // --- Gemini API Calls ---
            async function queryGemini(prompt) {
                console.log("Querying Gemini (Text):", prompt.substring(0, 100) + (prompt.length > 100 ? '...' : ''));
                checkContextTimeout();
                // History is added in processApiResponse *before* this call

                if (!GEMINI_API_KEY || GEMINI_API_KEY === 'YOUR_API_KEY') {
                    throw new Error("Clé API Gemini non configurée.");
                }

                // Construct payload including system instruction and history
                const requestContents = [
                    { role: 'user', parts: [{ text: SYSTEM_INSTRUCTION }] }, // System prompt first
                    ...conversationHistory // Existing conversation
                    // The current user prompt is added by the caller (processApiResponse) to history
                ];

                try {
                    const response = await fetch(GEMINI_API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: requestContents,
                            // Add safety settings - adjust as needed
                            safetySettings: [
                                { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                                { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                                { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                                { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" }
                            ],
                            generationConfig: {
                                // temperature: 0.7, // Adjust creativity vs factualness
                                maxOutputTokens: 1000 // Limit response length
                            }
                        })
                    });

                    const data = await response.json();

                    if (!response.ok) {
                        console.error('Gemini API Error:', response.status, data);
                        const errorMessage = data?.error?.message || `Erreur HTTP ${response.status}`;
                        throw new Error(`Erreur API IA : ${errorMessage}`);
                    }

                    console.log("Gemini API Response (Raw Text):", JSON.stringify(data).substring(0, 200) + '...');

                    // Extract text, handling potential blocking or missing content
                    let responseText = "Désolé, je n'ai pas pu générer de réponse.";
                    if (data.candidates?.length > 0) {
                        const candidate = data.candidates[0];
                        // Check for finish reason other than STOP
                        if (candidate.finishReason && candidate.finishReason !== 'STOP' && candidate.finishReason !== 'MAX_TOKENS') {
                             const reason = candidate.finishReason.replace(/_/g, ' ').toLowerCase();
                             console.warn(`Gemini response incomplete: ${reason}`);
                             // Combine partial text with reason
                             responseText = (candidate.content?.parts?.[0]?.text || "") + `\n\n_(Réponse interrompue: ${reason}.)_`;
                        } else if (candidate.content?.parts?.[0]?.text) {
                            responseText = candidate.content.parts[0].text;
                        } else {
                             console.warn("Gemini response candidate has no text part.");
                             responseText = "(Réponse vide reçue)";
                        }
                    } else if (data.promptFeedback?.blockReason) {
                        const reason = data.promptFeedback.blockReason.replace(/_/g, ' ').toLowerCase();
                        console.warn(`Gemini request blocked: ${reason}`);
                        responseText = `_(Votre demande a été bloquée car elle a été détectée comme ${reason}.)_`;
                    } else {
                         console.warn("Gemini response has no candidates or block reason.");
                    }

                    return responseText;

                } catch (error) {
                    // Catch fetch errors or errors thrown from response handling
                    console.error('Error fetching/processing Gemini (Text):', error);
                    // Re-throw the error to be handled by the caller
                    throw error;
                }
            }

            async function queryGeminiWithImage(prompt, base64ImageData) {
                console.log("Querying Gemini (Multimodal):", prompt.substring(0, 100) + (prompt.length > 100 ? '...' : ''));
                checkContextTimeout();
                 // History (text part) is added in processApiResponse *before* this call

                if (!GEMINI_API_KEY || GEMINI_API_KEY === 'YOUR_API_KEY') {
                    throw new Error("Clé API Gemini non configurée.");
                }
                if (!base64ImageData) {
                    throw new Error("Données d'image manquantes pour l'appel multimodal.");
                }

                // Remove the "data:image/png;base64," prefix
                const pureBase64 = base64ImageData.split(',')[1];
                if (!pureBase64) {
                     throw new Error("Format de données d'image invalide.");
                }

                // Construct payload for multimodal request
                const requestContents = [
                     { role: 'user', parts: [{ text: SYSTEM_INSTRUCTION }] }, // System prompt
                     ...conversationHistory.slice(0, -1), // History *excluding* the current text prompt (added below)
                     { // Current user turn with image and text
                         role: 'user',
                         parts: [
                             { text: prompt }, // The user's spoken question
                             { inline_data: { mime_type: 'image/png', data: pureBase64 } } // The image
                         ]
                     }
                ];

                try {
                    const response = await fetch(GEMINI_API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: requestContents,
                            safetySettings: [ // Same safety settings as text
                                { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                                { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                                { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                                { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" }
                            ],
                            generationConfig: { maxOutputTokens: 1000 }
                        })
                    });

                    const data = await response.json();

                    if (!response.ok) {
                        console.error('Gemini API Error (Multimodal):', response.status, data);
                        const errorMessage = data?.error?.message || `Erreur HTTP ${response.status}`;
                         throw new Error(`Erreur IA (image) : ${errorMessage}`);
                    }

                    console.log("Gemini API Response (Raw Multimodal):", JSON.stringify(data).substring(0, 200) + '...');

                    // Extract text response (similar logic to text-only)
                    let responseText = "Désolé, je n'ai pas pu analyser l'image.";
                     if (data.candidates?.length > 0) {
                         const candidate = data.candidates[0];
                         if (candidate.finishReason && candidate.finishReason !== 'STOP' && candidate.finishReason !== 'MAX_TOKENS') {
                             const reason = candidate.finishReason.replace(/_/g, ' ').toLowerCase();
                             console.warn(`Gemini multimodal response incomplete: ${reason}`);
                             responseText = (candidate.content?.parts?.[0]?.text || "") + `\n\n_(Analyse interrompue: ${reason}.)_`;
                         } else if (candidate.content?.parts?.[0]?.text) {
                             responseText = candidate.content.parts[0].text;
                         } else {
                             console.warn("Gemini multimodal response candidate has no text part.");
                             responseText = "(Je n'ai pas de commentaire sur cette image.)";
                         }
                     } else if (data.promptFeedback?.blockReason) {
                         const reason = data.promptFeedback.blockReason.replace(/_/g, ' ').toLowerCase();
                         console.warn(`Gemini multimodal request blocked: ${reason}`);
                         responseText = `_(L'analyse a été bloquée car l'image ou la question a été détectée comme ${reason}.)_`;
                     } else {
                          console.warn("Gemini multimodal response has no candidates or block reason.");
                     }

                    return responseText;

                } catch (error) {
                    console.error('Error fetching/processing Gemini (Multimodal):', error);
                    throw error; // Re-throw to be handled by caller
                }
            }


            // --- Scroll & Back Button Handlers ---
            scrollUpButton?.addEventListener('click', () => {
                const currentScreen = document.querySelector('.screen.active-screen')?.dataset.screenName;
                if (currentScreen === 'listening') return; // Don't scroll while listening
                currentScreenIndex = (currentScreenIndex - 1 + SCREEN_ORDER.length) % SCREEN_ORDER.length;
                switchScreen(SCREEN_ORDER[currentScreenIndex]);
            });
            scrollDownButton?.addEventListener('click', () => {
                 const currentScreen = document.querySelector('.screen.active-screen')?.dataset.screenName;
                 if (currentScreen === 'listening') return; // Don't scroll while listening
                currentScreenIndex = (currentScreenIndex + 1) % SCREEN_ORDER.length;
                switchScreen(SCREEN_ORDER[currentScreenIndex]);
            });
            document.querySelectorAll('.back-button').forEach(button => {
                button.addEventListener('click', (event) => {
                    const target = event.currentTarget.dataset.targetScreen || 'home';
                    switchScreen(target);
                });
            });

            // --- App Initialization ---
            async function initializeApp() {
                console.log("Initializing Rabbit R1 Web App v2...");
                switchScreen('home'); // Start on home screen
                updateDateTime(); // Initial date/time display
                setInterval(updateDateTime, 60000); // Update time every minute
                loadNote(); // Load saved note on startup

                // Initialize Speech Recognition FIRST
                const speechSetupOk = setupSpeechRecognition();

                // Then check/request permissions
                const permissionsOk = await checkAndRequestPermissions();

                if (speechSetupOk && permissionsOk && pttButton) {
                    pttButton.disabled = false; // Enable PTT button
                    // Use touchevents for mobile, mousedown/up for desktop
                    pttButton.addEventListener('touchstart', handlePttStart, { passive: false }); // Need passive false to prevent scroll
                    pttButton.addEventListener('touchend', handlePttEnd);
                    pttButton.addEventListener('touchcancel', handlePttEnd); // Handle cancellation
                    pttButton.addEventListener('mousedown', handlePttStart);
                    pttButton.addEventListener('mouseup', handlePttEnd);
                    // Add mouseleave to handle case where mouse button is released outside the button
                    pttButton.addEventListener('mouseleave', (e) => { if (isListening && e.buttons === 1) handlePttEnd(e); });
                    console.log("PTT Handlers attached.");
                } else {
                    console.warn("PTT initialization failed or permissions denied.");
                    if(pttButton) pttButton.disabled = true;
                    if (!speechSetupOk) updatePermissionStatus("Reconnaissance vocale non supportée.", 'error');
                    // Permission status is handled by checkAndRequestPermissions
                }

                // Initial timer display update
                updateTimerDisplay();

                console.log("Application initialized.");
            }

            // Start the application
            initializeApp();

            // Cleanup: Stop video stream when leaving the page/closing tab
            window.addEventListener('beforeunload', () => {
                console.log("beforeunload event: Stopping video stream.");
                stopVideoStream();
                // Note: Speech recognition usually stops automatically on page unload.
            });
             // Handle visibility change (e.g., switching tabs)
             document.addEventListener('visibilitychange', () => {
                 if (document.hidden) {
                     console.log("Page hidden: Stopping video stream and pausing timer.");
                     stopVideoStream(); // Stop camera when tab is not visible
                     if (isTimerRunning) pauseTimer(); // Pause timer
                     if (recognitionActive) stopSpeechRecognition(true); // Abort speech recognition
                 } else {
                     console.log("Page visible: Restarting video if needed.");
                     // Restart video only if on a camera screen
                     const currentScreen = document.querySelector('.screen.active-screen')?.dataset.screenName;
                     if (['vision', 'look_and_ask'].includes(currentScreen)) {
                         startVideoStream(currentScreen);
                     }
                     // Timer remains paused until user interaction
                 }
             });

        }); // End DOMContentLoaded
    </script>
</body>
</html>
